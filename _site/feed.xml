<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Orange</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://yangqiju.github.io/feed.xml" />
<link rel="alternate" type="text/html" href="http://yangqiju.github.io" />
<updated>2014-06-06T17:31:30+00:00</updated>
<id>http://yangqiju.github.io/</id>
<author>
  <name>yangqiju</name>
  <uri>http://yangqiju.github.io/</uri>
  <email>362991493@qq.com</email>
</author>


<entry>
  <title type="html"><![CDATA[Running Cassandra In Eclipse ]]></title>
  <link>http://yangqiju.github.io/cassandra-run-eclipse</link>
  <id>http://yangqiju.github.io/cassandra-run-eclipse</id>
  <published>2014-06-06T00:00:00+00:00</published>
  <updated>2014-06-06T00:00:00+00:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;pre&gt;&lt;code&gt;最近在Cassandra中发现一些问题，然后就打算调试一下Cassandra。
在官网上有RuningCassandraInEclipse的指导，但是总有些小问题。这里把他记录下来。

官方需要在本机安装ANT，并配置环境变量。
我自己在电脑上没有下载ANT，用Eclipse自带了ANT功能完成了类似的功能。

Step:
1.首先下个Cassandra的source包(http://cassandra.apache.org/download/)
2.下载后解压(example path: E:\apache-cassandra-2.0.8-src)
3.eclipse中新建项目:
	--&amp;gt;New
	--&amp;gt;Java Project--&amp;gt;
	--&amp;gt;Project Name:cassandra--&amp;gt;
	--&amp;gt;取消Use default location的选择--&amp;gt;
	--&amp;gt;location中写刚刚解压的path--&amp;gt;
	--&amp;gt;Next--&amp;gt;
	--&amp;gt;勾选Allow output folders for soure folders--&amp;gt;
	--&amp;gt;Default output folder中写cassandra/build/classes/main--&amp;gt;
	--&amp;gt;Finsh
4.找到build.xml --&amp;gt; 
	--&amp;gt;Run As --&amp;gt; 
	--&amp;gt;Ant Build(点第一个,默认jar,会下载包)--&amp;gt;
	--&amp;gt;设置项目Java Compiler:1.6或1.7--&amp;gt;
	--&amp;gt;再次build.xml--&amp;gt;
	--&amp;gt;Run As--&amp;gt;
	--&amp;gt;Ant Build(第二个，选择：build, generate-eclipse-files, jar)--&amp;gt;
	--&amp;gt;把项目刷新 重新编译。ok了。
5.在项目conf 中修改 cassandra.yaml 配置。(data,commitlog,save_cached..)
	Run CassandraDaemon 这个类，Run Configuratoins 
	VM arguments:
	-Dstorage-config=(conf地址)
	-Dcassandra-foreground 
	-ea -Xmx1G
	-Dlog4j.configuration=file:(conf地址)\log4j-server.properties
6.Run..


这样的话应该就能启动Cassandra了。我在本机能通过，不知道在别人那会不会有问题，
官方(http://wiki.apache.org/cassandra/RunningCassandraInEclipse)
&lt;/code&gt;&lt;/pre&gt;


  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/cassandra-run-eclipse&quot;&gt;Running Cassandra In Eclipse &lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on June 06, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[avro osgi 下遇到的ClassCaseException]]></title>
  <link>http://yangqiju.github.io/avro-osgi</link>
  <id>http://yangqiju.github.io/avro-osgi</id>
  <published>2014-06-06T00:00:00+00:00</published>
  <updated>2014-06-06T00:00:00+00:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;pre&gt;&lt;code&gt;最近公司做项目用到了avro去做序列化，并且在osgi环境下运行，遇到了很多问题，这个就是其中一个。
异常:
java.lang.ClassCastException: org.apache.avro.generic.GenericData$Record to...

-------------------serialize--------------------------------
Schema schema = etSchema (); 
ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
GenericDatumWriter&amp;lt;T&amp;gt; datumWriter = new ReflectDatumWriter&amp;lt;T&amp;gt;(schema);//问题所在
DataFileWriter&amp;lt;T&amp;gt; writer =
 		new DataFileWriter&amp;lt;T&amp;gt;(datumWriter).create(schema, outputStream);
writer.append(data);
writer.close();
outputStream.toByteArray();
-------------------serialize--------------------------------

-------------------deserialize--------------------------------
ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);
GenericDatumReader&amp;lt;T&amp;gt; datumReader = new ReflectDatumReader&amp;lt;T&amp;gt;(schema);//问题所在
DataFileStream&amp;lt;T&amp;gt; reader = new DataFileStream&amp;lt;T&amp;gt;(inputStream,datumReader);
datumReader.setExpected(schema);
T info = reader.next();
reader.close();
inputStream.close();
-------------------deserialize--------------------------------
这个问题很恶心，如果在非osgi的环境运行什么事都没有，放到osgi中deserialize的时候就
会发生ClassCaseException的问题。avro本来就是靠Schema去做序列和反序列，居然出现这种问题。让人费解。
最后查看了下源代码才发现问题所在:
在osgi中，bundle都有自己的classLoader，在使用 new ReflectDatumReader&amp;lt;T&amp;gt;(schema)
的时候，他只是用到了schema，没有获得这个类的classLoader，所以deserialize的时候，
得不到他的ClassLoader，当然也就new不了这个类了，所以就  new 了 GenericData$Record，用来存放属性。

所以问题就出现在他osgi中需要给他这个类的ClassLoader，解决方法就是 ReflectDatumReader&amp;lt;T&amp;gt;(clazz) 
参数把Schema换为他的class。他会去获得这个类的classLoader ，deserialize 的时候就没有问题了。
code:
 /** Construct for reading instances of a class. */
 	 public ReflectDatumReader(Class&amp;lt;T&amp;gt; c) {
	this(new ReflectData(c.getClassLoader()));//获得ClassLoader
	setSchema(getSpecificData().getSchema(c));
 	 }
&lt;/code&gt;&lt;/pre&gt;


  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/avro-osgi&quot;&gt;avro osgi 下遇到的ClassCaseException&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on June 06, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Cassandra Counter delete 之后update失效的问题]]></title>
  <link>http://yangqiju.github.io/cassandra-counter</link>
  <id>http://yangqiju.github.io/cassandra-counter</id>
  <published>2014-06-03T00:00:00+00:00</published>
  <updated>2014-06-03T00:00:00+00:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;pre&gt;&lt;code&gt;这两天在做项目的时候，发现Cassandra使用有点问题，所以把他记录下来，给自己提个醒，也希望也能帮到其他人。

1.运行版本：Cassandra-2.0.8
2.问题：使用Counter的delete之后，不能update。
3.结论：Counter 对一个key进行delete之后，就不能再对这个key进行操作。

实现步骤：
1.create table
	CREATE TABLE expendbulk (key text,expend counter,PRIMARY KEY (key));
2.insert data
	UPDATE expendbulk SET expend = expend + 1 WHERE key = &#39;TJ&#39;;
3.select data
	cqlsh:lottery&amp;gt; SELECT * FROM expendbulk ;
			key | expend
			----+-------
			TJ  | 1
4.delte data
	DELETE from expendbulk where key = &#39;TJ&#39;;
5.insert data
	UPDATE expendbulk SET expend = expend + 1 WHERE key = &#39;TJ&#39;;
6.select data
	cqlsh:lottery&amp;gt; SELECT * FROM expendbulk ;
			(0 rows)
这样一个流程下来，这个问题就出现了，只要对这个Key进行delete之后，update就失效了。
后来提给Cassandra提了一个关于这个的bug.
Datastax公司的人很快回复说：这个说Cassandra对counter的正常处理。
(原文:[https://issues.apache.org/jira/browse/CASSANDRA-7326])

额。。好吧，那就是说Counter就最好不要用delete了，试了一下，truncate表没有同样的问题。
所以。。建议大家，再用Cassandra的时候，不要踩到这个坑里面。
另外目前Cassandra的Counter功能并支持的不要，大概看了下，官方说会开发Counter2.0，来完善它的功能。
目前他就支持个原子的加减，不支持SetAndGet 等功能。很失望。
&lt;/code&gt;&lt;/pre&gt;


  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/cassandra-counter&quot;&gt;Cassandra Counter delete 之后update失效的问题&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on June 03, 2014.&lt;/p&gt;</content>
</entry>

</feed>
