<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Orange</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://yangqiju.github.io/feed.xml" />
<link rel="alternate" type="text/html" href="http://yangqiju.github.io" />
<updated>2021-08-11T11:09:33-04:00</updated>
<id>http://yangqiju.github.io/</id>
<author>
  <name>yangqiju</name>
  <uri>http://yangqiju.github.io/</uri>
  <email>362991493@qq.com</email>
</author>


<entry>
  <title type="html"><![CDATA[DICOM 扫盲]]></title>
  <link>http://yangqiju.github.io/DICOM%E6%89%AB%E7%9B%B2</link>
  <id>http://yangqiju.github.io/DICOM扫盲</id>
  <published>2021-08-10T00:00:00-04:00</published>
  <updated>2021-08-10T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;p&gt;DICOM 扫盲&lt;/p&gt;

&lt;h1 id=&quot;dicom介绍&quot;&gt;DICOM介绍&lt;/h1&gt;
&lt;p&gt;根据《医用电气设备DICOM在放射治疗中的应用指南》中描述到，在飞速增长的图像采集系统、显示工作站、归档系统与医院放射信息系统之间的互联和互相操作变得至关重要。为了简化和改善设备的互联性，专业医疗组织[美国放射学会(ACR)]联合医疗设备制造商们[美国国家电气制造商协会(NEMA)]国际化合作，共同开发DICOM(医学数字影像与通讯标准)。
 &lt;img src=&quot;../images/DICOM扫盲/5ea12350fa6d11ebb0fd49f3d06242d6.png&quot; alt=&quot;aaaaaaaaaaaa&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;目前，DICOM标准提供下列服务：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;网络图像传输&lt;/strong&gt;：
提供了两个设备间通讯发送对象的功能，诸如放射图像(例如CT、MR、CR、X射线血管造影与RF、PET、NM、US等)或RT图像与数据（RT结构集、计划、图像、剂量与治疗记录）。同事也可以识别和获取/传输远程设备上的图像/数据.网络传输是目前DICOM产品支持的最常用的互联特性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;在线图像检查管理&lt;/strong&gt;：
提供了医疗设备通过网络与各种信息系统想整合的功能，如医院信息系统（HIS）中的临床与管理数据，放射治疗信息系统（RIS）中的放射和放射治疗图像/数据。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;网络打印管理&lt;/strong&gt;：
提供了通过网络连接的打印机/相机打印图像的功能。这样的一个示例是多个扫描机或工作站在单个共享的硬拷贝介质上打印图像。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;开放式介质交换&lt;/strong&gt;：
提供了手工交换对象(图像或RT对象)与相关信息(例如报告或胶片信息)的功能，DICOM实现了通过文件格式、医疗目录结构与物理介质(例如CD、软盘)的标准化。示例包括用于出版的图像交换和用于远程会诊而发送患者图像序列。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;工作流程管理&lt;/strong&gt;：
DICOM标准经过扩展，能够定义设备工作列表和通用目标工作列表，该列表设计用于请求、规划与描述成像性能和其他过程操作。这些过程的整合可以和其他标准化机构保持一直。在这方面更进一步的服务正在考虑中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;dcm4che&quot;&gt;DCM4CHE&lt;/h1&gt;
&lt;p&gt;dcm4che 是面向医疗保健企业的开源应用程序和实用工具集合。项目使用java编写，实现了DICOM的标准。
dcm4che项目中包含了dcm4chee(额外的e代表‘enterprise’)，它是一个图像管理存储程序，该应用程序包含为医疗保健环境提供存储、检索和工作流所需的 DICOM、HL7 服务和接口。&lt;/p&gt;

&lt;h2 id=&quot;dcm4che-demo&quot;&gt;DCM4CHE demo&lt;/h2&gt;
&lt;p&gt;由于当前(2021-08)网络中存在的版本较老，部分搭建攻略也失效或不友好，这里记录一下如何快速搭建demo环境。&lt;/p&gt;
&lt;h4 id=&quot;使用docker运行minimum版本dcm4che&quot;&gt;使用docker运行minimum版本dcm4che.&lt;/h4&gt;
&lt;p&gt;详情如下:
&lt;a href=&quot;https://github.com/dcm4che/dcm4chee-arc-light/wiki/Run-minimum-set-of-archive-services-on-a-single-host&quot;&gt;minimum版本运行&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;运行起来后可以看到如下服务:
&lt;img src=&quot;../images/DICOM扫盲/45f52490faaa11ebbb1a1f11b0a3351c.png&quot; alt=&quot;aaaaaaaaaaaa&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;导入dcm数据&quot;&gt;导入DCM数据&lt;/h4&gt;
&lt;p&gt;通过storescu工具进行数据导入:
&lt;a href=&quot;https://github.com/dcm4che/dcm4che/blob/master/dcm4che-tool/dcm4che-tool-storescu/README.md&quot;&gt;storescu工具&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;storescu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;DCM4CHEE&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@localhost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11112&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dcm&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;DCM4CHEE是指定的AET,需要提前设定才能通过验证进行通讯.(该安装版本默认已经添加)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/DICOM扫盲/87119480faab11eba86d0501193eee8d.png&quot; alt=&quot;aaaaaaaaaaaa&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;查阅数据&quot;&gt;查阅数据&lt;/h4&gt;
&lt;p&gt;在Navigation -&amp;gt; studies 菜单中,以DCM4CHE进行搜索,便可以将上一步上传数据查阅出
&lt;img src=&quot;../images/DICOM扫盲/df6dd1c0faab11eba86d0501193eee8d.png&quot; alt=&quot;aaaaaaaaaaaa&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过查询出的结果工具中，可以查看相关图形数据。
&lt;img src=&quot;../images/DICOM扫盲/6a481580faac11ebb0fd49f3d06242d6.png&quot; alt=&quot;aaaaaaaaaaaa&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;使用oviyam查看图形&quot;&gt;使用oviyam查看图形&lt;/h4&gt;
&lt;p&gt;oviyam是一款开源的DICOM数据浏览器，可以使用docker进行部署。例如对刚刚的docker-compose.yml追加oviyam服务，将他们部署在同一套集群中&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nl&quot;&gt;oviyam:&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;informaticamedica&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;oviyam:&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.8&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;ports:&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;80:8080&quot;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1025:1025&quot;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;depends_on:&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arc&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;重新启动集群后,可以进入到oviyam管理端(admin:adm1n),添加相应的配置，并进行配置验证。
&lt;img src=&quot;../images/DICOM扫盲/f8a940a0faad11ebb494a1d4796cd9b0.png&quot; alt=&quot;aaaaaaaaaaaa&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样就可以将DCOM4CHEE中的数据查询出来。
&lt;img src=&quot;../images/DICOM扫盲/3187d0d0faae11ebb969dba37c0615cf.png&quot; alt=&quot;aaaaaaaaaaaa&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/DICOM扫盲/5cec5de0faae11eb9b14070fbd75ca5d.png&quot; alt=&quot;aaaaaaaaaaaa&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;名词解释&quot;&gt;名词解释&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;PACS:Picture Archiving and Communication Systems的缩写，意思为影像归档和通信系统。
是近年来随着数字成像技术、计算机技术和网络技术的进步而迅速发展起来的、旨在全面解决医学图像的获取、显示、存贮、传送和管理的综合系统。&lt;/li&gt;
  &lt;li&gt;DICOM:Digital Imaging and Communications in Medicine的英文缩写，即医学数字成像和通信标准
DICOM标准以计算机网络的工业化标准为基础，它能帮助更有效地在医学影像设备之间传输交换数字影像，这些设备不仅包括CT、MR、核医学和超声检查，而且还包括CR、胶片数字化系统、视频采集系统和HIS／RIS信息管理系统等&lt;/li&gt;
  &lt;li&gt;ACR（American College of Radiology,美国放射学会）&lt;/li&gt;
  &lt;li&gt;NEMA（National Electrical Manufactorers Association,国家电子制造商协会）&lt;/li&gt;
  &lt;li&gt;HIS:医院信息系统(Hospital Information System, HIS)
利用电子计算机和通讯设备，为医院所属各部门提供病人诊疗信息和行政管理信息的收集、存储、处理、提取和数据交换的能力，并满足所有授权用户的功能需求。&lt;/li&gt;
  &lt;li&gt;LIS:实验室信息管理系统(Laboratory Information Management System, LIS)
是专为医院检验科设计的一套信息管理系统，能将实验仪器与计算机组成网络，使病人样品登录、实验数据存取、报告审核、打印分发，实验数据统计分析等繁杂的操作过程实现了智能化、自动化和规范化管理。有助于提高实验室的整体管理水平，减少漏洞，提高检验质量。&lt;/li&gt;
  &lt;li&gt;RIS:放射信息管理系统(Radioiogy information system, RIS)
是优化医院放射科工作流程管理的软件系统,一个典型的流程包括登记预约、就诊、产生影像、出片、报告、审核、发片等环节&lt;/li&gt;
  &lt;li&gt;HL7:卫生信息交换标准（Health Level 7）
标准化的卫生信息传输协议，是医疗领域不同应用之间电子传输的协议。HL7汇集了不同厂商用来设计应用软件之间接口的标准格式，它将允许各个医疗机构在异构系统之间，进行数据交互。HL7的主要应用领域是HIS/RIS，主要是规范HIS/RIS系统及其设备之间的通信，它涉及到病房和病人信息管理、化验系统、药房系统、放射系统、收费系统等各个方面。&lt;/li&gt;
  &lt;li&gt;IHE:Integrating the Healthcare Enterprise整合医疗保健企业&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;其他&quot;&gt;其他&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.dicomserver.co.uk/WADO/&quot;&gt;https://www.dicomserver.co.uk/WADO/&lt;/a&gt;
&lt;a href=&quot;https://www.dicomstandard.org/current/&quot;&gt;https://www.dicomstandard.org/current/&lt;/a&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/74966427&quot;&gt;https://zhuanlan.zhihu.com/p/74966427&lt;/a&gt;&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/DICOM%E6%89%AB%E7%9B%B2&quot;&gt;DICOM 扫盲&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on August 10, 2021.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[mysql innodb 学习]]></title>
  <link>http://yangqiju.github.io/innnodb</link>
  <id>http://yangqiju.github.io/innnodb</id>
  <published>2020-05-15T00:00:00-04:00</published>
  <updated>2020-05-15T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;p&gt;INNODB学习&lt;/p&gt;

&lt;h1 id=&quot;问题&quot;&gt;问题&lt;/h1&gt;

&lt;h2 id=&quot;innodb如何保证了事务&quot;&gt;InnoDB如何保证了事务&lt;/h2&gt;

&lt;p&gt;事务是数据库区别与文件系统的重要特征之一，在文件系统中，如果正在写文件，但是操作系统突然崩溃了，这个文件就很有可能损坏。在数据库中，事务会把数据库从一种一致性状态转换为另一种一致性状态。在数据库提交工作时，可以保证要么所有修改都已经保存了，要么所有修改都不保存。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Atomicity，原子性。整个数据库事务是不可分割的工作单位，只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库应该退回到执行事务前的状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Consistency，一致性。一致性是指事务将数据库从一个状态转变为下一种一致性状态，在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。事务时一致性的单位，如果事务中某个动作失败了，系统可以自动此撤销事务（返回初始化的状态）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Isolation，隔离性。隔离性还有其他的称呼，如并发控制（concurrency
control）、可串行化（serializability）、锁（locking）等。事务的隔离性要求每个读写事务的对象对其他事务操作对象能相互分离，即该事务提交前对其他事务都不可见，通常这使用锁来实现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Durability，持久性。事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何实现了原子性&quot;&gt;如何实现了原子性&lt;/h3&gt;

&lt;p&gt;原子性是只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库应该退回到执行事务前的状态。&lt;/p&gt;

&lt;p&gt;对于原子性是undo log 保证的还是redo
log保证的，书本上（《MYSQL技术内幕》）和网上有着不同的说法。个人理解，应该是redo
log 和undo log 结合实现的，redo log
通过COMMIT记录保证了所有数据都执行成功才算事务成功，undo log
保证了事务未COMMIT可以回退到执行前的状态。&lt;/p&gt;

&lt;p&gt;在《数据库系统实现》一书中描述到，日志类型用到的几种形式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&amp;lt;START T&amp;gt;,表示事务T的开始&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&amp;lt;COMMIT T&amp;gt;,表示事务T已经完成并对数据库元素不再有修改&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&amp;lt;ABORT T&amp;gt;,表示事务T不能成功完成&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当系统崩溃后需要做两件事：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;按照从前往后做顺序，重做所有已提交的事务&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用redo log
恢复顺序为：1.确定已经提交的事务。2.从头扫描日志，如果T是已经COMMIT的事务，则将指写入到数据库3.如果T是未提交的事务，则在日志中写入&amp;lt;ABORT
T&amp;gt;记录并刷新日志&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;按照从后往前做顺序，撤销所有未提交的事务&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于ABORT的事务，将通过undo log 进行回滚操作恢复数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;undo-log实现&quot;&gt;Undo log实现&lt;/h4&gt;

&lt;p&gt;在对数据库进行修改时，InnoDB存储引擎不但会生成redo log 还会生成undo
log。这样如果用户的事务或语句失败了或者调用ROLLBACK语句请求回滚，就可以利用这些undo
log将数据进行回滚。&lt;/p&gt;

&lt;p&gt;Undo
log是逻辑日志，在回滚时，对于每个insert，引擎会执行一个delete，对于delete，引擎会执行一个insert。因此引擎回滚时他实际是做的与之前相反的工作。&lt;/p&gt;

&lt;h3 id=&quot;如何实现了持久性&quot;&gt;如何实现了持久性&lt;/h3&gt;

&lt;p&gt;Mysql 使用WAL( Write-Ahead
Logging)来保证事务的持久性，它的关键点就是先写日志，再写引擎数据。具体来说，当有一条记录需要更新的时候，InnoDB
引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。&lt;/p&gt;

&lt;p&gt;有了 redo log，InnoDB
就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为
crash-safe。&lt;/p&gt;

&lt;p&gt;Redo log 采用顺序写的操作，保证了写入速度。在具体的写redo
log过程中，为了保证日志能够安全的写入到磁盘中，引擎会调用一次fsync操作。这是因为redo
log没有使用O_DIRECT，因此当写入时只是写入到文件系统缓存（pagecache）。这样fsync的效率就取决于磁盘的性能，同样决定了事务的处理性能。&lt;/p&gt;

&lt;p&gt;参数innodb_flush_log_at_trx_commit用来控制redo
log刷新到磁盘的策略：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;默认值为1，表示事务提交必须调用fsync&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;0，表示事务提交时，重做日志缓存(redo log
buffer)并不立即写入重做日志文件，而是随着Master
Thread的间隔1秒进行fsync操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2，表示提交事务时，只写入文件缓存即可，不进行fsync操作。这种情况下能提升系统性能，但是无法保证数据安全。如果mysql宕机，系统没有宕机，数据不会丢失，但是如果系统也宕机了，那数据还在系统缓存中，没有刷如磁盘，数据将会丢失。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何实现了隔离性&quot;&gt;如何实现了隔离性&lt;/h3&gt;

&lt;p&gt;在看如何实现了隔离性之前，可以先问一个问题：为什么会有隔离性？&lt;/p&gt;

&lt;p&gt;数据库作为提供数据管理、查询的系统，不可避免的需要提供并行处理的能力，数据库需要保证并行事务的准确执行，并且要保证数据的准确性。&lt;/p&gt;

&lt;p&gt;如何并行处理还能保证数据的安全，最简单的就是通过加锁实现串行化了。而不同的业务，有不同的加锁需求，类似与java里面的读写锁，不同业务选择不同的数据安全程度，以控制数据在多个事务之间的可见度，所以数据库义了不同的”事务隔离等级”来控制锁的程度:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;未提交读(Read Uncommitted)：能读取到其他会话中未提交事务修改的数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提交读(Read Committed)：只能读取到已经提交的数据(不重复读)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可重复读(Repeated
Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先来看并发情况下，读操作可能存在的三类问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;脏读：当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。举例如下（以账户余额表为例）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;../images/innodb/image1.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。举例如下&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;../images/innodb/image2.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了（插入新的）。举例如下&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;../images/innodb/image3.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;SQL标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。隔离级别与读问题的关系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image4.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;innodb如何解决的这3个问题&quot;&gt;InnoDB如何解决的这3个问题？&lt;/h4&gt;

&lt;p&gt;这三个问题分别是脏读、不可重复读和幻读。&lt;/p&gt;

&lt;p&gt;在这之前需要了解一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一致性非锁定读（consistent nonlocking read）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Innodb引擎通过行多版本读取当前行数据。如果读取的行正在执行delete、update，这时的读取操作不会等待锁释放，而是读取行的快照数据。也叫快照读
(snapshot read)例如使用”select * from table ….;”语句。&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;../images/innodb/image5.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;一致性锁定读（consistent locking read）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;这种方式读取的是数据库当前版本数据也叫当前读 (current
read)有下面两个select的同时还有修改操作(update/insert/delete)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1.select * from table where ? lock in share mode;(共享锁:SLock)&lt;/p&gt;

&lt;p&gt;2.select * from table where ? for update;(排他锁:XLock)&lt;/p&gt;

&lt;p&gt;InnoDB默认使用可重复读的隔离等级，解决脏读、不可重复读、幻读等问题，使用的是MVCC：MVCC全称Multi-Version
Concurrency
Control，即多版本的并发控制协议，也被称乐观锁。多个版本的数据可以共存，主要是依靠数据的隐藏列(也可以称之为标记位)和undo
log。其中数据的隐藏列包括了该行数据的版本号、删除时间、指向undo
log的指针等等；当读取数据时，MySQL可以通过隐藏列判断是否需要回滚并找到回滚需要的undo
log，从而实现MVCC；&lt;/p&gt;

&lt;p&gt;原文5.5章：&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/10331633.html&quot;&gt;https://www.cnblogs.com/kismetv/p/10331633.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意：上面的原文中，描述的是一致性非锁定读，所以通过读取版本快照就解决了相关问题。但是在原文总结的时候，提出并不能innodb并不能保证完全隔离，事务B在T3插入了新记录，当事务A提交后余额还是被修改。&lt;strong&gt;这个总结应该是错误的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image6.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;
&lt;img src=&quot;../images/innodb/image7.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我理解是原文使用方式不对，因为如果使用一致性锁定读时，事务A将会使用Next-Key
Lock锁定相关范围（0-5），而事务B将插入失败。&lt;/p&gt;

&lt;p&gt;上面的示例就是一个幻读(幻像)问题(phantom
problem)，在同一事物下，连续执行两次相同的sql导致不同的查询结果，第二次的sql可能回返之前不存在的行。&lt;/p&gt;

&lt;p&gt;产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的”间隙”。因此，为了解决幻读问题，InnoDB
只好引入新的锁，也就是间隙锁 (Gap
Lock)。间隙锁，锁的就是两个值之间的空隙。间隙锁和行锁合称 next-key
lock，每个 next-key lock 是前开后闭区间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image8.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。这样执行select *
from t where d&amp;lt;5 for
update的时候，0-5的间隙是被锁住的，事务B对这个范围的insert是不被允许的。这样就避免了幻读问题。&lt;/p&gt;

&lt;p&gt;幻读的问题的描述(&lt;a href=&quot;https://time.geekbang.org/column/article/75173&quot;&gt;https://time.geekbang.org/column/article/75173&lt;/a&gt;)&lt;/p&gt;

&lt;h5 id=&quot;间隙锁在聚集索引和非聚集索引上的表现不同&quot;&gt;间隙锁在聚集索引和非聚集索引上的表现不同&lt;/h5&gt;

&lt;p&gt;锁的操作是建立在索引上的，如果共享锁（lock in share
mode）覆盖索引上，那它可以不锁定主键索引，所以其他事务操作范围内的主键可以update成功的。但是如果是for
update排他锁，那就会锁定主键索引，系统会猜测用户通过主键更新，所以相关记录会加上锁。&lt;/p&gt;

&lt;p&gt;更多情况查看以下内容：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/75659&quot;&gt;https://time.geekbang.org/column/article/75659&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;redo-log和binlog区别是什么&quot;&gt;Redo log和Binlog区别是什么&lt;/h2&gt;

&lt;h3 id=&quot;binlog-是什么&quot;&gt;Binlog 是什么&lt;/h3&gt;

&lt;p&gt;Binary
log记录了对mysql数据库执行更改的所有操作。Binlog主要有以下几个作用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Recovery恢复，用户可以通过日志进行point-in-time的恢复&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Replication复制，slave或standby通过复制执行binlog，进行实时同步&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Audit审计，通过日志进行审计，判断是否有对数据进行注入攻击&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;binlog
有statement模式、row模式、mixed模式（前两种的混合）。statement格式下，binlog记录的语句原文，可能遇到一个问题，备库同步完语句后，执行的效果（例如查询得索引选择）可能会不一样，导致同步数据有问题。这样可以选择使用row模式。row模式会明确指定主键id和内容。&lt;a href=&quot;https://time.geekbang.org/column/article/76446&quot;&gt;https://time.geekbang.org/column/article/76446&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;redo-log和binlog的区别&quot;&gt;Redo log和binlog的区别&lt;/h3&gt;

&lt;p&gt;因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是
MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB
是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe
能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现
crash-safe 能力。&lt;/p&gt;

&lt;p&gt;这两种日志有以下三点不同：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server
层实现的，所有引擎都可以使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;redo log 是物理日志，记录的是”在某个数据页上做了什么修改”；binlog
是逻辑日志，记录的是这个语句的原始逻辑，比如”给 ID=2 这一行的 c
字段加 1 “。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;redo log 是循环写的，空间固定会用完；binlog
是可以追加写入的。”追加写”是指 binlog
文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;redo-log和binlog的关系&quot;&gt;redo log和binlog的关系&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image9.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;执行器先找引擎取 ID=2 这一行。ID
是主键，引擎直接用树搜索找到这一行。如果 ID=2
这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是
N+1，得到新的一行数据，再调用引擎接口写入这行新数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log
里面，此时 redo log 处于 prepare
状态。然后告知执行器执行完成了，随时可以提交事务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行器生成这个操作的 binlog，并把 binlog 写入磁盘。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log
改成提交（commit）状态，更新完成。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果没有commit就crash了，恢复时可以通过它们有共同的数据字段（XID）去查记录，如果binlog是完整的，那么就可以将redo
log commit，这样主从都一致了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;提交方案为，先写redo log prepare 再写binlog，最后更新redo log
commit。为什么要两阶段提交？因为直接提交任意一个文件都有问题.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;先写redo
log，如果crash了，从库读取binlog读取不到这条，而master会通过redo
log恢复，数据不一致。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果先写binlog，crash了，备库会恢复这条数据，而master会从redo
log中恢复，发现没有这条数据，无法恢复。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mysql逻辑架构&quot;&gt;Mysql逻辑架构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image10.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，MySQL服务器逻辑架构从上往下可以分为三层：&lt;/p&gt;

&lt;p&gt;（1）第一层：处理客户端连接、授权认证等。&lt;/p&gt;

&lt;p&gt;（2）第二层：服务器层，负责查询语句的解析、优化、缓存以及内置函数的实现、存储过程等。&lt;/p&gt;

&lt;p&gt;（3）第三层：存储引擎，负责MySQL中数据的存储和提取。MySQL中服务器层不管理事务，事务是由存储引擎实现的。MySQL支持事务的存储引擎有InnoDB、NDB
Cluster等，其中InnoDB的使用最为广泛；其他存储引擎不支持事务，如MyIsam、Memory等。&lt;/p&gt;

&lt;h2 id=&quot;innodb都有什么索引&quot;&gt;InnoDB都有什么索引&lt;/h2&gt;

&lt;h3 id=&quot;自适应哈希索引&quot;&gt;自适应哈希索引&lt;/h3&gt;

&lt;p&gt;B+ tree 的查找取决于tree的高度，在生产环境中，B+
tree的高度一般为3~4层，也就是3到4此查询，而Hash
的时间复杂度了O(1)，大多情况下只需查询1次。&lt;/p&gt;

&lt;p&gt;InnoDB通过自动监控各个索引页的查询，判断热点页的条件符合程度建立相应的hash
index，这被称为自适应哈希索引（Adaptive Hash Index,AHI）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image11.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升。&lt;/p&gt;

&lt;p&gt;需要注意的是，AHI只能用来所有等值查询，不支持范围查找。&lt;/p&gt;

&lt;p&gt;通过下面的指令可以查看使用效果。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;o&quot;&gt;+--------------------------------------------------+&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;innodb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;......&lt;/span&gt;                                           &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34673&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;heap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.00&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;searches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.00&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;non&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;searches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;+--------------------------------------------------+&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/geaozhang/p/7252389.html&quot;&gt;https://www.cnblogs.com/geaozhang/p/7252389.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;b-tree-索引&quot;&gt;B+ tree 索引&lt;/h3&gt;

&lt;p&gt;InnoDB使用的是B+ tree 当索引，B是balanced平衡的意思。B+
tree并不能找到一个给定值的具体行，它会找到数据行所在的页，数据库通过把页读到内存中，再在内存中进行查找，得到要查询的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image12.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;B+树是为了磁盘或其他直接存取辅助设备设计的一种平衡查找树。所有的记录节点都是按照键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。B+
tree有个特点是高扇出(fan
out，例如下面为3)，这样在树的高度就为2到4层，也就是查询记录只需要2到4次磁盘IO。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image13.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;B+ tree索引可以分为聚集索引（clustered index）和辅助索引（secondary
index），他们不同的是，聚集索引叶子节点存放的是完整数据（数据页的形式），而辅助索引存储的是主键。&lt;/p&gt;

&lt;h4 id=&quot;聚集索引&quot;&gt;聚集索引&lt;/h4&gt;

&lt;p&gt;InnoDB存储引擎是索引组织表，即表中数据按照主键顺序存放，而聚集索引就是按照每张表的主键构造一个B+树，同时叶子节点存放的即为整张表的行记录数据，也将聚集索引的叶子节点成为数据页。这个特性决定了索引组织表中的数据也是索引的一部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image14.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;聚集索引使用主键构造树，可以在聚集索引的叶子节点上直接找到数据，由于定了数据的逻辑顺序，聚集索引能高效的针对范围值的查询。因此利用好主键实现业务逻辑能带来很高的查询效率。&lt;/p&gt;

&lt;h4 id=&quot;非聚集索引&quot;&gt;非聚集索引&lt;/h4&gt;

&lt;p&gt;辅助索引（也成为了非聚集索引），叶子节点并不包含行记录的全部数据。叶子节点包含键值以外，还包含一个书签。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnDB存储引擎表示索引组织表，因此辅助索引的书签就是相对应的行数据的聚集索引键。每张表上可以有多个辅助索引。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image15.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;联合索引&quot;&gt;联合索引&lt;/h4&gt;

&lt;p&gt;联合索引是指对表上的多个列进行索引，他同样是B+
tree，和单个索引的区别是有多个索引列（键值数量大于1）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image16.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假定两个列分别为a,b。如图叶子节点是按照(a,b)字段的顺序进行存放。因此where
a=x and b=x 是可以利用上索引的，对于where
a=x也是可以利用上索引的，但是where b=x就不能利用上索引。&lt;/p&gt;

&lt;h4 id=&quot;覆盖索引&quot;&gt;覆盖索引&lt;/h4&gt;

&lt;p&gt;覆盖索引（covering index
，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。&lt;/p&gt;

&lt;p&gt;例如下面的示例，name和age都不是主键索引，创建name和age的索引，在查询通过where
name=x即能查出age，而不需要回表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image17.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5da5d1966fb9a04e252c94bf&quot;&gt;https://juejin.im/post/5da5d1966fb9a04e252c94bf&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;对写有什么优化策略&quot;&gt;对写有什么优化策略？&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image18.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.6284722222222223in”}&lt;/p&gt;

&lt;h3 id=&quot;walmem策略&quot;&gt;WAL+MEM策略&lt;/h3&gt;

&lt;p&gt;在数据存储中，通常的写优化方案都是(WAL+内存)的方案：通过写内存保证插入速度，通过WAL解决内存容易丢失的问题。而WAL又是顺序写，所有速度能得到保证。redo
log 做WAL的实现。&lt;/p&gt;

&lt;h3 id=&quot;减少资源竞争&quot;&gt;减少资源竞争&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image18.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.6284722222222223in”}&lt;/p&gt;

&lt;p&gt;从InnoDB1.0.x开始，允许有多个缓冲池实例，每个页根据哈希值平均分配到不同的缓冲池实例，这样减少数据库内部的资源竞争。增加了并发处理能力。&lt;/p&gt;

&lt;h3 id=&quot;减少磁盘写&quot;&gt;减少磁盘写&lt;/h3&gt;

&lt;p&gt;前面提到InnoDB存储引擎是索引组织表，即表中数据按照主键顺序存放，聚集索引就是按照每张表的主键构造一个B+树，叶子节点就是数据。而非聚集索引是用来辅助的叶子节点是主键数据。&lt;/p&gt;

&lt;p&gt;所以当一个表内既有聚集索引又有非聚集索引的情况下，磁盘操作不但要有写数据的IO还要有聚集索引写入的IO。这里就需要分两个情况&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;聚集索引操作（例如insert/update/delete自定义主键的数据）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;当操作记录时，要通过索引找到要插入范围的索引页，判断是否主键冲突然后在插入。如果这条数据的范围需要插入的目标页（数据页和索引页？）在内存中，那插入内存后返回（通过脏页刷新的策略写入磁盘）。如果不在内存中，则需要先将数据页加载到内存进行处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;非聚集索引操作&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;存储引擎对此设计了insert buffer
，当对非unique的索引插入或更新操作时，不是每一次直接插入索引页中，而是判断索引页是否在buffer
pool，如果在则直接插入，如果不在则放到一个insert
buffer对象中。然后再以一定的频率和情况对insert
buffer和非聚集索引页子节点的merge操作。这能将多一个插入合并到一个操作(如果在一个索引页当中)。这样就提高了非聚集索引的插入性能。（change
buffer是insert buffer的升级版，增加了delete buffer ,purge buffer）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;aio刷新临近页&quot;&gt;AIO+刷新临近页&lt;/h3&gt;

&lt;p&gt;在内存中被update之后的数据变成了脏页，当达到刷新到磁盘的条件时，引擎会检测该页所在区（extent）的所有页，如果是脏页那么一起进行刷新。这样通过AIO就将多个IO操作合并成了一个。&lt;/p&gt;

&lt;p&gt;AIO（Asynchronous IO）相比Sync IO，不用等待每次IO完成，并且可以进行IO
Merge操作，将多个IO合并为一个，提高IOPS性能。在读取和写入都有一定的提升。&lt;/p&gt;

&lt;p&gt;在机械硬盘下有显著的优势，但是如果是SSD存储，该特性可能没有太大帮助。1.2.x版本以后可以通过innodb_flush_neighbors参数进行关闭。&lt;/p&gt;

&lt;h2 id=&quot;对读有什么优化策略&quot;&gt;对读有什么优化策略？&lt;/h2&gt;

&lt;h3 id=&quot;b树低io&quot;&gt;B+树低IO&lt;/h3&gt;

&lt;p&gt;数据查询使用B+树本身就是为了磁盘或其他直接存储辅助设备设计的一种平衡查找树，数据结构决定了在查询磁盘数据时的高效性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image15.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;B+树分为叶子节点和非叶子节点，叶子节点存储的是数据，非叶子节点存储的键值和指针。默认情况下页的大小为16k，粗略计算一条记录为1k，那每个叶子节点存储16条数据。&lt;/p&gt;

&lt;p&gt;假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，即16k/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720
条这样的数据记录。高度为3的B+树可以存放 ：1170*1170*16=21902400
条这样的记录。&lt;/p&gt;

&lt;p&gt;所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/QmlVJJhHLVzjM7XMCOGPmg&quot;&gt;https://mp.weixin.qq.com/s/QmlVJJhHLVzjM7XMCOGPmg&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;多种索引支持&quot;&gt;多种索引支持&lt;/h3&gt;

&lt;p&gt;覆盖索引、联合索引都是对具体业务根据不同的查询条件建立的索引，使用的当都能加快查询的速度。自适应哈希索引更是将热点页的数据将多次查询变为一次。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image11.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;内存查询&quot;&gt;内存查询&lt;/h3&gt;

&lt;p&gt;在磁盘之上增加内存来提升查询效率是最广泛的操作，mysql 的buffer
pool中存储了在写入时的最新数据，所以在数据查询时，如果内存中没有相关数据需要查询磁盘，加载数据也并返回，但是如果内存中有则能直接返回结果。&lt;/p&gt;

&lt;p&gt;可以通过show engine innodb status查看内存命中效果。&lt;/p&gt;

&lt;h4 id=&quot;全表查询会不会替换热数据&quot;&gt;全表查询会不会替换热数据？&lt;/h4&gt;

&lt;p&gt;当进行数据查询时，会将数据加载到内存当中，如果内存中有相应的数据则可以直接返回，这样在查询热点数据的情况下，效率会提升很多。那执行一个全表查询会不会将热点数据全部替换掉导致真实的热点数据不能利用缓存呢？&lt;/p&gt;

&lt;p&gt;InnoDB 内存管理用的是最近最少使用 (Least Recently Used, LRU)
算法，这个算法的核心就是淘汰最久未使用的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image19.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;InnoDB 管理 Buffer Pool 的 LRU 算法，是用链表来实现的。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在图 6 的状态 1 里，链表头部是 P1，表示 P1
是最近刚刚被访问过的数据页；假设内存里只能放下这么多数据页；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这时候有一个读请求访问 P3，因此变成状态 2，P3 被移到最前面；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;状态 3 表示，这次访问的数据页是不存在于链表中的，所以需要在 Buffer
Pool 中新申请一个数据页
Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾
Pm 这个数据页的内存，存入 Px 的内容，然后放到链表头部。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从效果上看，就是最久没有被访问的数据页 Pm，被淘汰了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么，按照这个算法扫描的话，就会把当前的 Buffer Pool
里的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。对于一个正在做业务服务的库，这可不妙。你会看到，Buffer
Pool 的内存命中率急剧下降，磁盘压力增加，SQL 语句响应变慢。&lt;/p&gt;

&lt;p&gt;所以，InnoDB 不能直接使用这个 LRU 算法。实际上，InnoDB 对 LRU
算法做了改进。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/innodb/image20.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 InnoDB 实现上，按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old
区域。图中 LRU_old 指向的就是 old 区域的第一个位置，是整个链表的 5/8
处。也就是说，靠近链表头部的 5/8 是 young 区域，靠近链表尾部的 3/8 是
old 区域。&lt;/p&gt;

&lt;p&gt;改进后的 LRU 算法的操作逻辑：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;扫描过程中，需要新插入的数据页，都被放到 old 区域 ;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过
1 秒，因此还是会被保留在 old 区域；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部（也就是
young 区域），很快就会被淘汰出去。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以看到，这个策略最大的收益，就是在扫描这个大表的过程中，虽然也用到了
Buffer Pool，但是对 young 区域完全没有影响，从而保证了 Buffer Pool
响应正常业务的查询命中率。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/79407&quot;&gt;https://time.geekbang.org/column/article/79407&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/10331633.html&quot;&gt;https://www.cnblogs.com/kismetv/p/10331633.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/68633&quot;&gt;https://time.geekbang.org/column/article/68633&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/geaozhang/p/7252389.html&quot;&gt;https://www.cnblogs.com/geaozhang/p/7252389.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008545713&quot;&gt;https://segmentfault.com/a/1190000008545713&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/QmlVJJhHLVzjM7XMCOGPmg&quot;&gt;https://mp.weixin.qq.com/s/QmlVJJhHLVzjM7XMCOGPmg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/79407&quot;&gt;https://time.geekbang.org/column/article/79407&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2&quot;&gt;https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/75173&quot;&gt;https://time.geekbang.org/column/article/75173&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/innnodb&quot;&gt;mysql innodb 学习&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on May 15, 2020.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[语法解析学习]]></title>
  <link>http://yangqiju.github.io/%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%AD%A6%E4%B9%A0</link>
  <id>http://yangqiju.github.io/语法解析学习</id>
  <published>2020-04-03T00:00:00-04:00</published>
  <updated>2020-04-03T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;现在很多newsql都支持了mysql协议，例如tidb底层是kv存储，实现了对mysql协议的支持。他们都可以实现对sql语句的解析，并完成相应的数据操作，这个是如何做到的呢？&lt;/p&gt;

&lt;h1 id=&quot;解析流程&quot;&gt;解析流程&lt;/h1&gt;

&lt;h2 id=&quot;概述-1&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image1.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”4.191666666666666in”}&lt;/p&gt;

&lt;p&gt;Sql的解析、优化、执行和编译器的工作原理是相同的，和c、golang这种语言解析上处理上都是类似的。&lt;/p&gt;

&lt;p&gt;大致分为前、中、后端，前端处理将语句进行解析，中部根据语言特性进行对应的优化，后端根据存储的不同进行不同的处理。&lt;/p&gt;

&lt;p&gt;下图为语言编译器的编译过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image2.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.9229166666666666in”}&lt;/p&gt;

&lt;h2 id=&quot;词法分析&quot;&gt;词法分析&lt;/h2&gt;

&lt;p&gt;词法分析（Lexical
Analysis）。通常，编译器的第一项工作叫做词法分析。就像阅读文章一样，文章是由一个个的中文单词组成的。程序处理也一样，将字符串解析成
Token。&lt;/p&gt;

&lt;p&gt;我们会识别出 if、else、int 这样的关键字，main、printf、age
这样的标识符，+、-、=
这样的操作符号，还有花括号、圆括号、分号这样的符号，以及数字字面量、字符串字面量等。这些都是
Token。&lt;/p&gt;

&lt;p&gt;通常词法分析可以使用有限状态自动机来完成。&lt;/p&gt;

&lt;p&gt;例如解析age = 45为标识符、比较操作符和数字字面量这三种 Token
的词法规则:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;标识符（ID）：第一个字符必须是字母，后面的字符可以是字母或数字。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;比较操作符：\ 和 =（其他比较操作符暂时忽略）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数字字面量：全部由数字构成。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image3.png&quot; alt=&quot;&quot; /&gt;{width=”4.094339457567804in”
height=”2.8452351268591425in”}&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;初始状态&lt;/strong&gt;：刚开始启动词法分析的时候，程序所处的状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;标识符状态&lt;/strong&gt;：在初始状态时，当第一个字符是字母的时候，迁移到状态
2。当后续字符是字母和数字时，保留在状态 2。如果不是，就离开状态
2，写下该 Token，回到初始状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;大于操作符（GT）&lt;/strong&gt;：在初始状态时，当第一个字符是 &lt;br /&gt;
时，进入这个状态。它是比较操作符的一种情况。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;大于等于操作符（GE）&lt;/strong&gt;：如果状态 3 的下一个字符是 =，就进入状态
4，变成 =。它也是比较操作符的一种情况。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;数字字面量&lt;/strong&gt;：在初始状态时，下一个字符是数字，进入这个状态。如果后续仍是数字，就保持在状态
5。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image4.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”1.56875in”}&lt;/p&gt;

&lt;p&gt;上面的例子虽然简单，但其实已经讲清楚了词法原理，就是依据构造好的有限自动机，在不同的状态中迁移，从而解析出
Token
来。你只要再扩展这个有限自动机，增加里面的状态和迁移路线，就可以逐步实现一个完整的词法分析器了。&lt;/p&gt;

&lt;p&gt;相关代码如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/craft/SimpleLexer.java&quot;&gt;https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/craft/SimpleLexer.java&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;有限状态自动机&quot;&gt;有限状态自动机&lt;/h3&gt;

&lt;p&gt;有限状态自动机（FSM &quot;finite state machine&quot; 或者FSA &quot;finite state
automaton&quot;
）是为研究有限内存的计算过程和某些语言类而抽象出的一种计算模型。有限状态自动机拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。有限状态自动机可以表示为一个有向图。&lt;/p&gt;

&lt;h2 id=&quot;语法分析&quot;&gt;语法分析&lt;/h2&gt;

&lt;p&gt;词法分析是识别一个个的单词，而语法分析（syntactic analysis，也叫
parsing）就是在词法分析的基础上识别出程序的语法结构。这个结构是一个树状结构，是计算机容易理解和执行的，这个树被称为抽象语法树（Abstract
Syntax Tree，AST）。&lt;/p&gt;

&lt;p&gt;例如”2+3*5”可以被抽象为下面的一棵树。形成 AST
以后有什么好处呢？就是计算机很容易去处理。比如，针对表达式形成的这棵树，从根节点遍历整棵树就可以获得表达式的值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image5.png&quot; alt=&quot;&quot; /&gt;{width=”3.7421380139982503in”
height=”2.198607830271216in”}&lt;/p&gt;

&lt;p&gt;要构建抽象语法树，语言处理器首先要知道将会接受哪些单词序列，也就是要处理怎样的程序，并确定希望构造出怎样的抽象语法树。通常这些设定由程序设计语言的语法（Grammer）决定。&lt;/p&gt;

&lt;p&gt;语法规定了单词的组合规则，例如双目运算表达式应该由哪些单词组成、if语句应该有怎样的结构等。这种语法可以通过BNF（巴科斯范式）用来表达。&lt;/p&gt;

&lt;p&gt;我们可以通过BNF定义SQL或者自定义脚本语言的语法，通过ANTLR工具来解析SQL或者解析自定义的脚本语句，并完成相应的执行代码。&lt;/p&gt;

&lt;h3 id=&quot;巴科斯范式&quot;&gt;巴科斯范式&lt;/h3&gt;

&lt;p&gt;巴科斯范式（英语：Backus Normal Form，缩写为
BNF），又称为巴科斯-诺尔范式（英语：Backus-Naur Form，缩写同样为
BNF，也译为巴科斯-瑙尔范式、巴克斯-诺尔范式），是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。&lt;/p&gt;

&lt;p&gt;广泛地使用于程序设计语言、指令集、通信协议的语法表示中。大多数程序设计语言或者形式语义方面的教科书都采用巴科斯范式。在各种文献中还存在巴科斯范式的一些变体，如扩展巴科斯范式
EBNF 或扩充巴科斯范式 ABNF。&lt;/p&gt;

&lt;h3 id=&quot;铁轨图&quot;&gt;铁轨图&lt;/h3&gt;

&lt;p&gt;由于BNF并不能很直观得表达语法规则，所以人们有时候会用铁路图来表示grammer。&lt;/p&gt;

&lt;p&gt;例如下面是And条件分支，可以选择一个、追加一个and或者无限and下去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image6.png&quot; alt=&quot;&quot; /&gt;{width=”3.791861329833771in”
height=”2.791809930008749in”}&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.h2database.com/html/grammar.html&quot;&gt;http://www.h2database.com/html/grammar.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;antlr&quot;&gt;ANTLR&lt;/h3&gt;

&lt;p&gt;ANTLR（全名：ANother Tool for Language
Recognition）是基于LL(*)算法实现的语法解析器生成器（parser
generator），用Java语言编写，如同一般的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8&amp;gt;&quot;&gt;词法分析器&lt;/a&gt;（lexer）和语法分析器（parser），ANTLR可以用来产生树状分析器（tree
parsers）。ANTLR 文法定义使用类似EBNF（Extended Backus-Naur
Form）的定义方式，形象十分简洁直观。&lt;/p&gt;

&lt;p&gt;ANTRL官方提供了很多grammer，包括mysql协议、java等。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/antlr/grammars-v4&quot;&gt;https://github.com/antlr/grammars-v4&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;idea-antlr插件&quot;&gt;IDEA ANTLR插件&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image7.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.170138888888889in”}&lt;/p&gt;

&lt;p&gt;通过安装ANTLR插件，可以对相应的grammer进行测试。在数据框中提供相应的语句，解析出AST。&lt;/p&gt;

&lt;h2 id=&quot;语义分析&quot;&gt;语义分析&lt;/h2&gt;

&lt;p&gt;语义分析就是要让计算机理解我们的真实意图，把一些模棱两可的地方消除掉。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;某个表达式的计算结果是什么数据类型？如果有数据类型不匹配的情况，是否要做自动转换？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果在一个代码块的内部和外部有相同名称的变量，我在执行的时候到底用哪个？
就像”我喜欢又聪明又勇敢的你”中的”你”，到底指的是谁，需要明确&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在同一个作用域内，不允许有两个名称相同的变量，这是唯一性检查。你不能刚声明一个变量
a，紧接着又声明同样名称的一个变量 a，这就不允许了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;生成中端代码&quot;&gt;生成中端代码&lt;/h2&gt;

&lt;h3 id=&quot;asm&quot;&gt;ASM&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html&quot;&gt;https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://houbb.github.io/2019/10/30/bytecode-byte-buddy-01-overview&quot;&gt;https://houbb.github.io/2019/10/30/bytecode-byte-buddy-01-overview&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://kahnsen.github.io/kahnblog/2017/11/29/ASM%E5%85%A8%E8%A7%A3%E6%9E%90/&quot;&gt;https://kahnsen.github.io/kahnblog/2017/11/29/ASM%E5%85%A8%E8%A7%A3%E6%9E%90/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhenbianshu.github.io/2018/11/control_jvm_byte_code.html&quot;&gt;https://zhenbianshu.github.io/2018/11/control_jvm_byte_code.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000022310393&quot;&gt;https://segmentfault.com/a/1190000022310393&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;字节码&quot;&gt;字节码&lt;/h4&gt;

&lt;p&gt;Java之所以可以”一次编译，到处运行”，一是因为JVM针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供JVM使用。因此，也可以看出字节码对于Java生态的重要性。之所以被称之为字节码，是因为字节码文件由十六进制值组成，而JVM以两个十六进制值为一组，即以字节为单位进行读取。在Java中一般是用javac命令编译源代码为字节码文件，一个.java文件从编译到运行的示例如图1所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image8.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.7194444444444446in”}&lt;/p&gt;

&lt;h4 id=&quot;字节码增强&quot;&gt;字节码增强&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image9.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.5493055555555557in”}&lt;/p&gt;

&lt;p&gt;Cglib就是用asm来实现的，同样byte
buddy也是用asm来显示aop。例如Mockito，Hibernate，Jackson，Google的Bazel等系统就是用byte
buddy实现。&lt;/p&gt;

&lt;h4 id=&quot;流程&quot;&gt;流程&lt;/h4&gt;

&lt;p&gt;ASM是一个很小的工具包，调用顺序为ClassReader加载字节码文件–\accept方法启动访问者模式–\把class文件拆分成各种visit事件，把拆分的事件循环遍历ClassVisitor中的各种visit方法（ClassVisitor类采用职责链循环递归）–\在ClassVisitor中如遇到visitField，visitMethod等，才用更细化的FieldVisitor等等继续visit–\整个流程完毕。&lt;/p&gt;

&lt;h4 id=&quot;idea-插件&quot;&gt;IDEA 插件&lt;/h4&gt;

&lt;p&gt;通过IDEA的ASM Bytecode Outline插件，可以产出相应代码的asm写法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image10.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.7534722222222223in”}&lt;/p&gt;

&lt;h4 id=&quot;book&quot;&gt;BOOK&lt;/h4&gt;

&lt;h4 id=&quot;用途&quot;&gt;用途&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;结合Instrument 和JVM TI 的Attach 技术，实现IDEA DEBUG&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://zhenbianshu.github.io/2018/11/control_jvm_byte_code.html&quot;&gt;https://zhenbianshu.github.io/2018/11/control_jvm_byte_code.html&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;AOP打印日志&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;性能监控&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据脱敏&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库事务管理&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lombok&quot;&gt;Lombok&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image12.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.48125in”}&lt;/p&gt;

&lt;p&gt;举例来说，现在有一个实现了Pluggable Annotation Processing
API的程序A，那么使用javac编译时的具体流程如下：&lt;/p&gt;

&lt;p&gt;1. javac编译器对源码进行分析，生成一个抽象的语法树（AST)&lt;/p&gt;

&lt;p&gt;2. javac编译器运行A程序&lt;/p&gt;

&lt;p&gt;3. A程序完成逻辑，一般是修改此语法树&lt;/p&gt;

&lt;p&gt;4. javac使用修改后的语法树生成可执行的字节码文件&lt;/p&gt;

&lt;h1 id=&quot;应用&quot;&gt;应用&lt;/h1&gt;

&lt;h2 id=&quot;sql解析优化&quot;&gt;SQL解析优化&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;美团开源的SQLAdvisor。它基于MySQL原生态词法解析，结合分析SQL中的where条件、聚合条件、多表Join关系给出索引优化建议。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;去哪儿开源的Inception。侧重于根据内置的规则，对SQL进行审核。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阿里的Cloud DBA。根据官方文档介绍，其也是提供SQL优化建议和改写。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阿里的Druid，为监控而生的数据库连接池&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/语法解析学习/image13.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”4.491666666666666in”}&lt;/p&gt;

&lt;h2 id=&quot;自定义脚本语言&quot;&gt;自定义脚本语言&lt;/h2&gt;

&lt;p&gt;理解完语法解析，通过ANTLR工具，可以实现一套属于自己的脚本语言。&lt;/p&gt;

&lt;h3 id=&quot;前提&quot;&gt;前提&lt;/h3&gt;

&lt;p&gt;计算机上运行各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。&lt;/p&gt;

&lt;p&gt;后来，人们用助记符号代替机器指令码而形成了汇编语言。汇编语言使指令容易理解和记忆，而且便于交流，使计算机软件的发展大大前进了一步。&lt;/p&gt;

&lt;p&gt;但是，由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。这种翻译就由编译器完成，具有这种翻译功能的程序就是汇编程序。&lt;/p&gt;

&lt;p&gt;为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言，如C语言。但是针对不同硬件，都需要编译一遍。&lt;/p&gt;

&lt;p&gt;Java语言的产生，实现了一次编译，多地运行的能力，因为他在机器指令和Java语言中间增加了一层中间解释器(JVM)，Java语言编写的代码并不会直接编译为机器指令码，而是编译成JVM字节码，JVM用来解释执行该字节码，所以大家吐槽Java没有C快，因为中间多了一层解释执行。&lt;/p&gt;

&lt;p&gt;为了解决该问题，JVM提供了JIT（Just-In-Time -
实时编译），它可以将字节码编译为机器指令码，当某个”热”代码被重复执行，可以能会转成机器指令码。&lt;/p&gt;

&lt;p&gt;Android Runtime为了提高速度，采用的AOT（Ahead-Of-Time -
预先编译）的方式。&lt;/p&gt;

&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;

&lt;p&gt;自己实现一个脚本语言，通过antlr生成语法和AST访问方法，并模拟了堆栈构机器（虚拟机分为寄存器机器和堆栈结构机器），并用jvm运行脚本语言。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/RichardGong/PlayWithCompiler&quot;&gt;https://github.com/RichardGong/PlayWithCompiler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;EvalVisitor是Druid SQL
Parser中用于对SQL表达式求值的Visitor。某些场景需要对sql中的部分表达式进行求值然后做特别处理，比如说分库分表时，需要根据其中一个表达式进行求值，以判断其对应的分库分表的规则。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/druid/wiki/EvalVisitor&quot;&gt;https://github.com/alibaba/druid/wiki/EvalVisitor&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;引用&quot;&gt;引用&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/302c56f9574d&quot;&gt;https://www.jianshu.com/p/302c56f9574d&lt;/a&gt;
&lt;a href=&quot;https://blog.mythsman.com/post/5d2c11c767f841464434a3bf/&quot;&gt;https://blog.mythsman.com/post/5d2c11c767f841464434a3bf/&lt;/a&gt;
&lt;a href=&quot;http://www.h2database.com/html/grammar.html#alias&quot;&gt;http://www.h2database.com/html/grammar.html#alias&lt;/a&gt;
&lt;a href=&quot;https://github.com/RichardGong/PlayWithCompiler&quot;&gt;https://github.com/RichardGong/PlayWithCompiler&lt;/a&gt;
&lt;a href=&quot;https://www.zhihu.com/question/61569096&quot;&gt;https://www.zhihu.com/question/61569096&lt;/a&gt;
&lt;a href=&quot;https://github.com/alibaba/druid/wiki/SQL-Parser&quot;&gt;https://github.com/alibaba/druid/wiki/SQL-Parser&lt;/a&gt;
&lt;a href=&quot;https://github.com/alibaba/druid/wiki/EvalVisitor&quot;&gt;https://github.com/alibaba/druid/wiki/EvalVisitor&lt;/a&gt;
&lt;a href=&quot;https://zhenglinj.github.io/technology/2017/08/05/antlr4-maven-examples/&quot;&gt;https://zhenglinj.github.io/technology/2017/08/05/antlr4-maven-examples/&lt;/a&gt;
&lt;a href=&quot;https://github.com/antlr/antlr4/blob/master/doc/go-target.md&quot;&gt;https://github.com/antlr/antlr4/blob/master/doc/go-target.md&lt;/a&gt;
&lt;a href=&quot;https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html&quot;&gt;https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html&lt;/a&gt;
&lt;a href=&quot;https://zhenglinj.github.io/technology/2017/08/05/antlr4-maven-examples/&quot;&gt;https://zhenglinj.github.io/technology/2017/08/05/antlr4-maven-examples/&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%AD%A6%E4%B9%A0&quot;&gt;语法解析学习&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on April 03, 2020.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[minio学习]]></title>
  <link>http://yangqiju.github.io/minio</link>
  <id>http://yangqiju.github.io/minio</id>
  <published>2020-03-05T00:00:00-05:00</published>
  <updated>2020-03-05T00:00:00-05:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;Minio
是一个基于Go语言的对象存储服务。它实现了大部分亚马逊S3云存储服务接口，可以看做是是S3的开源版本，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。&lt;/p&gt;

&lt;h1 id=&quot;对象存储&quot;&gt;对象存储&lt;/h1&gt;

&lt;p&gt;计算机的存储，大致分为块存储、文件存储和对象存储。&lt;/p&gt;

&lt;h2 id=&quot;块存储&quot;&gt;块存储&lt;/h2&gt;

&lt;p&gt;块存储又有两种常见的形式，DAS和SAN。&lt;/p&gt;

&lt;h3 id=&quot;das&quot;&gt;DAS&lt;/h3&gt;

&lt;p&gt;DAS即直接连接存储（Direct Attached Storage）。&lt;/p&gt;

&lt;p&gt;块存储是我们最常用的一种存储模式。比如个人PC上的硬盘，服务器上的硬盘。这种存储方式有一种很大的缺陷，其存储性能瓶颈来自于自家PC电脑或者服务器的卡槽的多少&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image1.png&quot; alt=&quot;&quot; /&gt;{width=”3.429738626421697in”
height=”2.414773622047244in”}&lt;/p&gt;

&lt;h3 id=&quot;san&quot;&gt;SAN&lt;/h3&gt;

&lt;p&gt;SAN即存储区域网络（Storage Area Network）。&lt;/p&gt;

&lt;p&gt;SAN是一个采用网状通道（简称FC）技术，通过FC交换机连接存储阵列和服务器主机，建立专用于数据存储的区域网络。对于用户来说，SAN好比是一块大磁盘，用户可以根据需要随意将SAN格式化成想要的文件系统来使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image2.png&quot; alt=&quot;&quot; /&gt;{width=”3.9341404199475067in”
height=”2.7102274715660544in”}&lt;/p&gt;

&lt;p&gt;从理论上来讲，SAN支持数以百计的磁盘，提供了海量的存储空间，解决了大容量存储问题，但SAN需要通过光纤交换机连接存储阵列和服务器，建立专用数据存储的网络。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;块存储需要格式化成文件系统（ext3、ext4、NTFS等）后才能被访问。它的优势是性能高、时延低，适合于OLTP数据库、NoSQL数据库等IO密集型的高性能、低时延应用工作负载。但是块存储无法容量弹性扩展，并且对共享访问的支持有限。因此，块存储主要还是针对单ECS的高性能，低时延的存储产品。&lt;/p&gt;

&lt;h2 id=&quot;文件存储&quot;&gt;文件存储&lt;/h2&gt;

&lt;p&gt;NAS（Network Attached
Storage）是一种通过网络达成存储目的的设备，NAS传输数据依靠的是TCP/IP网络协议栈，这是NAS存储于上文的DAS和SAN存储最大的不同之处。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image3.png&quot; alt=&quot;&quot; /&gt;{width=”3.511363735783027in”
height=”2.769776902887139in”}&lt;/p&gt;

&lt;p&gt;实现文件存储的方式有很多，比如
ftp协议、nfs协议、samba协议等，还有HDFS、GFS等。&lt;/p&gt;

&lt;h2 id=&quot;对象存储-1&quot;&gt;对象存储&lt;/h2&gt;

&lt;p&gt;相对于文件存储目录树的组织形式，对象存储采用扁平的文件组织形式，采用RESTFul
API接口访问，不支持文件随机读写，主要适用于互联网架构的海量数据的上传下载和分发。非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。&lt;/p&gt;

&lt;p&gt;它核心是将数据通路（数据读或写）和控制通路（元数据）分离，并且基于对象存储设备（Object-based
Storage
Device，OSD）构建存储系统，每个对象存储设备具有一定的智能，能够自动管理其上的数据分布。&lt;/p&gt;

&lt;p&gt;之所以出现了对象存储这种东西，是为了克服块存储与文件存储各自的缺点，发扬它俩各自的优点。简单来说块存储读写快，不利于共享，文件存储读写慢，利于共享。能否弄一个读写快，利于共享的出来呢。于是就有了对象存储。&lt;/p&gt;

&lt;h2 id=&quot;总结-1&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image4.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.2645833333333334in”}&lt;/p&gt;

&lt;h1 id=&quot;核心&quot;&gt;核心&lt;/h1&gt;

&lt;h2 id=&quot;存储架构&quot;&gt;存储架构&lt;/h2&gt;

&lt;p&gt;Standalone，集群&lt;/p&gt;

&lt;h3 id=&quot;分布元数据&quot;&gt;分布元数据&lt;/h3&gt;

&lt;h4 id=&quot;inode&quot;&gt;Inode&lt;/h4&gt;

&lt;p&gt;inode(index
node)是指在许多”类Unix文件系统”，文件系统创建（格式化）时，就把存储区域分为两大连续的存储区域。一个用来保存文件系统对象的元信息数据，这是由inode组成的表，每个inode默认是256字节或者128字节。另一个用来保存”文件系统对象”的内容数据，划分为512字节的扇区，以及由8个扇区组成的4K字节的块。块是读写时的基本单位。&lt;/p&gt;

&lt;p&gt;索引结点（Inode）对象存储了文件的相关元数据信息，如所有者、访问权限（读、写、执行）、类型（是文件还是目录）、内容修改时间、inode修改时间、上次访问时间、对应的文件系统存储块的地址，等等。知道了1个文件的inode号码，就可以在inode元数据中查出文件内容数据的存储地址。(&lt;a href=&quot;https://zh.wikipedia.org/wiki/Inode&quot;&gt;https://zh.wikipedia.org/wiki/Inode&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。&lt;/p&gt;

&lt;p&gt;以上能够了解元数据对存储系统的重要性。&lt;/p&gt;

&lt;h4 id=&quot;分布式文件存储hdfs&quot;&gt;分布式文件存储（HDFS）&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image5.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.472916666666667in”}&lt;/p&gt;

&lt;p&gt;NameNode
负责整个分布式文件系统的元数据（MetaData）管理，也就是文件路径名、数据块的
ID 以及存储位置等信息，DataNode 负责文件数据的存储和读写操作，HDFS
将文件数据分割成若干数据块。每个 DataNode
存储一部分数据块，这样文件就分布存储在整个 HDFS
服务器集群中。客户端可以对这些数据块进行并行访问，大大提高了访问速度。&lt;/p&gt;

&lt;p&gt;目前的大多数文件系统，如XFS/Ext4、GFS、HDFS，在元数据管理、缓存管理等实现策略上都侧重大文件。这些文件系统在面临海量时在性能和存储效率方面都大幅降低。&lt;/p&gt;

&lt;p&gt;在HDFS中，当小文件太多时，加重HDFS的namespace命名空间，因为过多的小文件意味着更多文件元数据信息需要NameNode来保存了。&lt;/p&gt;

&lt;p&gt;对于该问题也提供了相应解决方案:&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/Androidlushangderen/article/details/54176511&quot;&gt;https://blog.csdn.net/Androidlushangderen/article/details/54176511&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;文件归档&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文件归档在这里的意思是将文件再次进行整理和保存，使之更易管理和保存。通过二层索引文件的查找，进行最终文件的读取。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;改变写入方式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过改变文件的写出方式，写入到SequenceFile格式的文件中。这主要是因为SequenceFile独有的存储格式决定了它可以很好的满足小文件存储的需求。SequenceFile文件内部存储数据的方式是以key-value的形式拼接而成。因为考虑到小文件中的内容少，在这里我们可以以文件名作为key，文件内容作为value，直接写到SequenceFile中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;依赖外部系统的数据访问模式进行数据的管理，比如HBase。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;taobao-file-system&quot;&gt;Taobao File System&lt;/h4&gt;

&lt;p&gt;对于海量小文件应用，常见的I/O流程复杂也是造成磁盘性能不佳的原因。对于小文件，磁盘的读写所占用的时间较少，而用于文件的open()操作占用了绝大部分系统时间，导致磁盘有效服务时间非常低，磁盘性能低下。针对于问题的根源，优化的思路大体上分为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;针对数据布局低效，采用小文件合并策略，将小文件合并为大文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;针对元数据管理低效，优化元数据的存储和管理&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image6.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”3.825in”}&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;小文件合并&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小文件合并为大文件后，首先减少了大量元数据，提高了元数据的检索和查询效率，降低了文件读写的I/O操作延时。其次将可能连续访问的小文件一同合并存储，增加了文件之间的局部性，将原本小文件间的随机访问变为了顺序访问，大大提高了性能。&lt;/p&gt;

&lt;p&gt;访问流程由原来许多的open操作转变为了seek操作，定位到大文件具体的位置即可。利用一个旁路数据库来记录每个小文件在这个大文件中的偏移量和长度等信息。其实小文件合并的策略本质上就是通过分层的思想来存储元数据。中控节点存储一级元数据，也就是大文件与底层块的对应关系；数据节点存放二级元数据，也就是最终的用户文件在这些一级大块中的存储位置对应关系，经过两级寻址来读写数据。(与HDFS的归档方案一致)&lt;/p&gt;

&lt;p&gt;淘宝的TFS就采用了小文件合并存储的策略。TFS中默认Block大小为64M，每个块中会存储许多不同的小文件，但是这个块只占用一个Inode。假设一个Block为64M，数量级为1PB。那么NameServer上会有
1 1024 1024 * 1024 / 64 =
16.7M个Block。假设每个Block的元数据大小为0.1K，则占用内存不到2G。在TFS中，文件名中包含了Block
ID和File ID，通过Block
ID定位到具体的DataServer上，然后DataServer会根据本地记录的信息来得到File
ID所在Block的偏移量，从而读取到正确的文件内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image7.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.7180555555555554in”}&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;元数据管理优化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说元数据信息包括名称、文件大小、设备标识符、用户标识符、用户组标识符等等，在小文件系统中可以对元数据信息进行精简，仅保存足够的信息即可。元数据精简可以减少元数据通信延时，同时相同容量的Cache能存储更多的元数据，从而提高元数据使用效率。另外可以在文件名中就包含元数据信息，从而减少一个元数据的查询操作。最后针对特别小的一些文件，可以采取元数据和数据并存的策略，将数据直接存储在元数据之中，通过减少一次寻址操作从而大大提高性能。&lt;/p&gt;

&lt;p&gt;TFS中文件命名就隐含了位置信息等部分元数据，从而减少了一个元数据的查询操作。在Rerserfs中，对于小于1KB的小文件，Rerserfs可以将数据直接存储在Inode中。&lt;/p&gt;

&lt;h4 id=&quot;对象存储系统&quot;&gt;对象存储系统&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image8.png&quot; alt=&quot;&quot; /&gt;{width=”3.3522725284339456in”
height=”2.629233377077865in”}&lt;/p&gt;

&lt;p&gt;对象存储结构由对象(Object)、对象存储设备（Object-based Storage
Device，OSD）、元数据服务器（Metadata
Server，MDS）、对象存储服务（OSS）的客户端四部分组成。&lt;/p&gt;

&lt;p&gt;按照上面业务发展的分析，目前对象存储的架构大致就可以为上图。&lt;/p&gt;

&lt;p&gt;传统的存储结构元数据服务器通常提供两个主要功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;为计算结点提供一个存储数据的逻辑视图（Virtual File
System，VFS层），文件名列表及目录结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;MDS控制Client与OSD对象的交互，为客户端提供元数据，主要是为计算结点提供一个存储数据的逻辑视图（Virtual
 File
 System，VFS层），包括文件与目录的组织关系、每个文件所对应的OSD等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image9.png&quot; alt=&quot;&quot; /&gt;{width=”4.215908792650919in”
height=”2.4074212598425198in”}&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;组织物理存储介质的数据分布（inode层）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image10.png&quot; alt=&quot;&quot; /&gt;{width=”3.21042104111986in”
height=”2.3295450568678917in”}&lt;/p&gt;

&lt;p&gt;对象存储的数据存储服务中的Object也包含了元数据信息（TFS同样提到名字中就包含BlockID信息的思路）。元数据的VFS部分通常是元数据服务器的10％的负载，剩下的90％工作（inode部分）是在存储介质块的数据物理分布上完成的。在对象存储结构，inode工作分布到每个OSD，每个OSD负责管理数据分布和检索，这样90%的元数据管理工作分布到OSD，从而提高了系统元数据管理的性能。另外，分布的元数据管理，在增加更多的OSD到系统中时，可以同时增加元数据的性能和系统存储容量。&lt;/p&gt;

&lt;p&gt;对象存储体系结构定义了一个新的、数据访问接口。OSD是与网络连接的设备，它自身包含存储介质，并具备元数据。计算结点直接与OSD通信，访问它存储的数据，不需要元数据服务器的介入。如果将文件系统的数据分布在多个OSD上，能支持并发数据访问。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/liuaigui/article/details/17973039&quot;&gt;https://blog.csdn.net/liuaigui/article/details/17973039&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;minio元数据管理&quot;&gt;Minio元数据管理&lt;/h3&gt;

&lt;p&gt;Minio的Metadata管理没有采用集中式的管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image11.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.0763888888888888in”}&lt;/p&gt;

&lt;p&gt;在Minio白皮书中写到：Minio没有单独的元数据存储，所有的操作都和对象操作一致，同样都采用了纠删码和bitrot哈希进行数据保护，即使集群崩溃也不会丢数据。另一个优点是这个设计是强一致性，这对分布式机器学习和大数据工作负载很重要。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image12.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.1645833333333333in”}&lt;/p&gt;

&lt;p&gt;在Minio白皮书中的线性扩展测试一章中描述：&lt;/p&gt;

&lt;p&gt;测试结果表明，Minio集群的读写性能，随着服务器数量的增加而线性增加。具备这种线性扩展的能力的一个原因是因为minio它使用自身进行元数据的存储，而不是使用元数据服务器。这样的目的是避免了中央元数据服务器可能的瓶颈。结果是，在扩展minio对象存储时不需要考虑重要元数据服务器的性能对服务的影响。&lt;/p&gt;

&lt;h2 id=&quot;数据安全&quot;&gt;数据安全&lt;/h2&gt;

&lt;p&gt;在分布式系统中，都会采用数据冗余的方式保证数据安全性。比如mysql
主从复制，cassandra、elasticsearch的多副本存储策略。当任何一个副本损坏或丢失的情况下，其他副本都能保证系统整体数据安全。&lt;/p&gt;

&lt;p&gt;但是采用副本的方式，会要求存储空间以倍数的方式增加。而RS纠错码冗余策略在保证数据安全的同时，对存储空间的要求更低。&lt;/p&gt;

&lt;p&gt;例如：RS纠删码语序我们选择数据片和校验片的数量，可以将一个完整的对象平均分为4个数据片和2个校验片，共6个分片，其中4个数据分片是原始大小的25%，另外2个校验片也为25%。这6个分片将会存储在6个不同的数据服务节点上，只需要其中任意4个就可以恢复出完整的对象。也就是允许2块损坏。这样存储要求是150%，抵抗能力是2.&lt;/p&gt;

&lt;p&gt;总体来说，对于一个M+N的RS码（M个数据片，N个校验片）对存储的要求是（M+N）/M*100%，抵抗能力是N。&lt;/p&gt;

&lt;p&gt;Minio使用了Reed-Solomon纠删码和校验和来保护数据免受硬件故障和无声数据损坏。在高级别的冗余下，可以在失去N/2的数据存储下恢复数据。&lt;/p&gt;

&lt;p&gt;针对不同应用所需的数据安全级别不同，Minio还提供了存储级别（Storage
Class）的配置，调整数据块和校验块的比例，做到对空间的最佳使用。比如在将比例调整为14:2后，存储100M的数据占用的空间仅为114M&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image13.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.9652777777777777in”}&lt;/p&gt;

&lt;p&gt;纠删码的工作原理和RAID或者副本不同，像RAID6可以在损失两块盘的情况下不丢数据，而Minio纠删码可以在丢失一半的盘的情况下，仍可以保证数据安全。
而且Minio纠删码是作用在对象级别，可以一次恢复一个对象，而RAID是作用在卷级别，数据恢复时间很长。
Minio对每个对象单独编码，存储服务一经部署，通常情况下是不需要更换硬盘或者修复。&lt;/p&gt;

&lt;h3 id=&quot;reed-solomon纠删码&quot;&gt;Reed-Solomon纠删码&lt;/h3&gt;

&lt;p&gt;纠删码是一种恢复丢失和损坏数据的数学算法， Minio默认采用Reed-Solomon
code将数据拆分成N/2个数据块和N/2个奇偶校验块。这就意味着如果是16块盘，一个对象会被分成8个数据块、8个奇偶校验块，你可以丢失任意8块盘（不管其是存放的数据块还是校验块），你仍可以从剩下的盘中的数据进行恢复。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image14.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.5840277777777776in”}&lt;/p&gt;

&lt;p&gt;开源的golang实现&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/klauspost/reedsolomon&quot;&gt;https://github.com/klauspost/reedsolomon&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;raid技术&quot;&gt;RAID技术&lt;/h3&gt;

&lt;p&gt;数据存储在单个磁盘上，存在一些缺陷：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;访问速度慢：单一的IO接口，无法并发&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;容量小：单个磁盘的提升，无法满足爆发时增长的数据存储需求&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安全性差：容易成为单个故障节点&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RAID就是通过对多个磁盘进行联合提供存储服务，已解决上面的问题。&lt;/p&gt;

&lt;p&gt;单个磁盘数据是以扇区为基本单位进行存储和访问，RADI抽象出一个类似于扇区的最小数据访问单位：条带（stripe），这是一种虚拟化的设计方法，他是在多个磁盘之间建立一个逻辑映射关系，将多个物理磁盘抽象为一个容量更大的、IO并发能力更高的虚拟硬盘，一条带作为基本单位进行管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image15.tiff&quot; alt=&quot;&quot; /&gt;{width=”3.875in” height=”3.735974409448819in”}&lt;/p&gt;

&lt;p&gt;途中单个条带跨过的磁盘个数，成为条带宽度，单个条带在单个次攀升分配的字节数，成为条带深度，条带深度一版为磁盘基本块的整数倍。基本快指访问磁盘的最小粒度，例如扇区。&lt;/p&gt;

&lt;h4 id=&quot;raid0&quot;&gt;RAID0&lt;/h4&gt;

&lt;p&gt;RAID 0
并不是真正的RAID结构，没有数据冗余，没有数据校验的磁盘陈列。实现RAID
0至少需要两块以上的硬盘，它将两块以上的硬盘合并成一块，数据连续地分割在每块盘上。
因为带宽加倍，所以读/写速度加倍， 但RAID
0在提高性能的同时，并没有提供数据保护功能，只要任何一块硬盘损坏就会丢失所有数据。因此RAID
0 不可应用于需要数据高可用性的关键领域。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image16.tiff&quot; alt=&quot;&quot; /&gt;{width=”3.2086745406824146in”
height=”2.9479166666666665in”}&lt;/p&gt;

&lt;h4 id=&quot;raid1&quot;&gt;RAID1&lt;/h4&gt;

&lt;p&gt;RAID 1通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互
为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID
1可以提高读取性能。RAID
1是磁盘阵列中单位成本最高的，但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image17.tiff&quot; alt=&quot;&quot; /&gt;{width=”1.2054199475065617in”
height=”2.1979166666666665in”}&lt;/p&gt;

&lt;h4 id=&quot;raid5&quot;&gt;RAID5&lt;/h4&gt;

&lt;p&gt;RAID5以一个或者多个基本块作为条带深度均分数据，同时基于异或运算生成一个与数据块同等大小的校验块。因此RAID5提供的IO能力以及可用存储空间为所有磁盘的(N-1)/N，N为磁盘个数，亦即RAID5的条带宽度。&lt;/p&gt;

&lt;p&gt;由异或运算性质，如果条带中任意一个数据块出错，都可以通过其他任然正常的数据块和校验块执行异或运算恢复数据。因此RAID5至多允许一块磁盘异常。&lt;/p&gt;

&lt;h4 id=&quot;raid6&quot;&gt;RAID6&lt;/h4&gt;

&lt;p&gt;RAID6在RAID5的基础上进一步提高了容错能力，在每一个条带增加了一个校验块，达到每个条带有两个校验块，具备最多允许两块磁盘异常。&lt;/p&gt;

&lt;h4 id=&quot;rs-raid&quot;&gt;RS-RAID&lt;/h4&gt;

&lt;p&gt;简单理解纠删的原理（实际实现复杂的多）：RAID5基于条带将数据均匀切分成多个数据块：d1,d2,d3..dn，然后将数据块建立联系，例如加法:d1+d2+d3+…dn=c。c就是基于加法的校验块，这样任意一个数据块损坏，都可以根据上面公式进行数据恢复。&lt;/p&gt;

&lt;p&gt;RAID6或者更高的容忍方案，就是利用条带中N个数据块通过编码得到m个校验块（m为同时允许损坏磁盘个数），如果磁盘故障，通过编码逆向过程，可以还原所有缺失数据。&lt;/p&gt;

&lt;h3 id=&quot;覆盖写问题&quot;&gt;覆盖写问题&lt;/h3&gt;

&lt;p&gt;覆盖写就是针对对象已有的内容进行改写，普通磁盘数据操作并不需要特别注意，但当数据使用了纠删码情况就不一样了。&lt;/p&gt;

&lt;p&gt;纠删码通过引入条带的概念，将条带变成了更新对象数据的最小单位，即更新条带中任意数据块的同时必须更新校验块，否则后续无法数据恢复，如果覆盖写的起始或结束地址没有尽心条带对其，那么对于不足一个完整条带的部分，写入只能通过”读取完整条带-\修改数据-&lt;br /&gt;
基于条带重新计算校验数据-\ 写入”，这个过程被称为RMW（Read Modify
Write）。&lt;/p&gt;

&lt;p&gt;RMW过程中的R，是为了和待改写的内容一起，再次拼凑出完整的条带，以完成纠删码所要求的重新编码计算，因此这个读也被称为补齐读，在RMW过程R最耗时。&lt;/p&gt;

&lt;p&gt;对于覆盖写的场景，纠删码非常容易产生大量的RMW操作，这使得纠删码的综合写性能比多副本方案差，适合的场景为追加或者删除。&lt;/p&gt;

&lt;h3 id=&quot;并发读&quot;&gt;并发读&lt;/h3&gt;

&lt;p&gt;多副本方案实现中，因为副本间保存的内容相同，读取一个文件即可，这个过程是同步的。然而纠删码则不同，因为同一个对象的数据被分片并且存储在多个数据节点中，此时的读操作会是多个节点的并发读。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/minio/image18.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.8229166666666665in”}&lt;/p&gt;

&lt;p&gt;读取数据过程中包括网络的耗时和纠删码的计算耗时，因此使用纠删码不适合时延敏感的应用。&lt;/p&gt;

&lt;h1 id=&quot;拓展&quot;&gt;拓展&lt;/h1&gt;

&lt;h2 id=&quot;gateway&quot;&gt;Gateway&lt;/h2&gt;

&lt;h2 id=&quot;消息通知&quot;&gt;消息通知&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.min.io/docs/minio-bucket-notification-guide.html&quot;&gt;https://docs.min.io/docs/minio-bucket-notification-guide.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;s3-select&quot;&gt;S3 Select&lt;/h2&gt;

&lt;p&gt;S3 提供了select
API，可以让用户使用简单的sql语句，对csv、json、parquet格式的数据进行select
操作。&lt;/p&gt;

&lt;h3 id=&quot;语法解析器&quot;&gt;语法解析器&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alecthomas/participle&quot;&gt;https://github.com/alecthomas/participle&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;nsq&quot;&gt;NSQ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://nsq.io/&quot;&gt;https://nsq.io/&lt;/a&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37081073&quot;&gt;https://zhuanlan.zhihu.com/p/37081073&lt;/a&gt;
参考
====
&lt;a href=&quot;https://github.com/jihonghe/fucking-algorithm&quot;&gt;https://github.com/jihonghe/fucking-algorithm&lt;/a&gt;
&lt;a href=&quot;https://blog.csdn.net/Androidlushangderen/article/details/54176511&quot;&gt;https://blog.csdn.net/Androidlushangderen/article/details/54176511&lt;/a&gt;
&lt;a href=&quot;https://blog.csdn.net/liuaigui/article/details/17973039&quot;&gt;https://blog.csdn.net/liuaigui/article/details/17973039&lt;/a&gt;
&lt;a href=&quot;https://blog.csdn.net/gui951753/article/details/82714065&quot;&gt;https://blog.csdn.net/gui951753/article/details/82714065&lt;/a&gt;
&lt;a href=&quot;https://www.zhihu.com/question/21536660&quot;&gt;https://www.zhihu.com/question/21536660&lt;/a&gt;
&lt;a href=&quot;https://www.redhat.com/zh/topics/data-storage/file-block-object-storage&quot;&gt;https://www.redhat.com/zh/topics/data-storage/file-block-object-storage&lt;/a&gt;
&lt;a href=&quot;http://tech.dianwoda.com/2018/12/04/fen-bu-shi-cun-chu-xi-tong-miniojian-jie/&quot;&gt;http://tech.dianwoda.com/2018/12/04/fen-bu-shi-cun-chu-xi-tong-miniojian-jie/&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/minio&quot;&gt;minio学习&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on March 05, 2020.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Prometheus学习]]></title>
  <link>http://yangqiju.github.io/prometheus%E5%AD%A6%E4%B9%A0</link>
  <id>http://yangqiju.github.io/prometheus学习</id>
  <published>2019-12-16T00:00:00-05:00</published>
  <updated>2019-12-16T00:00:00-05:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;时序数据库&quot;&gt;时序数据库&lt;/h1&gt;

&lt;p&gt;时序数据是基于时间的一系列的数据。在有时间的坐标中将这些数据点连成线，往过去看可以做成多纬度报表，揭示其趋势性、规律性、异常性；往未来看可以做大数据分析，机器学习，实现预测和预警。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/prometheus学习/image1.jpeg&quot; alt=&quot;æ¶åºæ°æ®åºæ·±å¥æµåºä¹å­å¨ç¯&quot; /&gt;{width=”5.768055555555556in”
height=”1.9765201224846893in”}&lt;/p&gt;

&lt;p&gt;时序数据库就是存放时序数据的数据库，并且需要支持时序数据的快速写入、持久化、多纬度的聚合查询等基本功能。&lt;/p&gt;

&lt;h2 id=&quot;特点&quot;&gt;特点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;数据模式： 时序数据随时间增长，相同维度重复取值，指标平滑变化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写入：
持续高并发写入，无更新操作：时序数据库面对的往往是百万甚至千万数量级终端设备的实时数据写入（如摩拜单车2017年全国车辆数为千万级），但数据大多表征设备状态，写入后不会更新。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询：
按不同维度对指标进行统计分析，且存在明显的冷热数据，一般只会频繁查询近期数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;传统数据库的问题&quot;&gt;传统数据库的问题&lt;/h2&gt;

&lt;p&gt;很多人可能认为在传统关系型数据库上加上时间戳一列就能作为时序数据库。数据量少的时候确实也没问题。但时序数据往往是由百万级甚至千万级终端设备产生的，写入并发量比较高，属于海量数据场景。&lt;/p&gt;

&lt;p&gt;MySQL在海量的时序数据场景下存在如下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;存储成本大：对于时序数据压缩不佳，需占用大量机器资源；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;维护成本高：单机系统，需要在上层人工的分库分表，维护成本高；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写入吞吐低：单机写入吞吐低，很难满足时序数据千万级的写入压力；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询性能差：适用于交易处理，海量数据的聚合分析性能差。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，使用Hadoop生态（Hadoop、Spark等）存储时序数据会有以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;数据延迟高：离线批处理系统，数据从产生到可分析，耗时数小时、甚至天级；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询性能差：不能很好的利用索引，依赖MapReduce任务，查询耗时一般在分钟级。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到时序数据库需要解决以下几个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;时序数据的写入：如何支持每秒钟上千万上亿数据点的写入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时序数据的读取：如何支持在秒级对上亿数据的分组聚合运算。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;成本敏感：由海量数据存储带来的是成本问题。如何更低成本的存储这些数据，将成为时序数据库需要解决的重中之重。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;概况&quot;&gt;概况&lt;/h1&gt;

&lt;p&gt;Prometheus 是由前 Google 工程师从 2012 年开始在 Soundcloud
以开源软件的形式进行研发的系统监控和告警工具包，自此以后，许多公司和组织都采用了
Prometheus 作为监控告警工具。Prometheus
的开发者和用户社区非常活跃，它现在是一个独立的开源项目，可以独立于任何公司进行维护。为了证明这一点，Prometheus
于 2016 年 5 月加入 CNCF 基金会，成为继 Kubernetes 之后的第二个 CNCF
托管项目。&lt;/p&gt;

&lt;h2 id=&quot;优势&quot;&gt;优势&lt;/h2&gt;

&lt;p&gt;Prometheus 的主要优势有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;由指标名称和和键/值对标签标识的时间序列数据组成的多维数据模型。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;强大的查询语言 PromQL。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不依赖分布式存储；单个服务节点具有自治能力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时间序列数据是服务端通过 HTTP 协议主动拉取获得的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;也可以通过中间网关来推送时间序列数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以通过静态配置文件或服务发现来获取监控目标。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持多种类型的图表和仪表盘。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;架构&quot;&gt;架构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/prometheus学习/image2.jpeg&quot; alt=&quot;https://hugo-picture.oss-cn-beijing.aliyuncs.com/images/9Qt5yi.jpg&quot; /&gt;{width=”5.768055555555556in”
height=”3.4635662729658794in”}&lt;/p&gt;

&lt;p&gt;Prometheus Server
直接从监控目标中或者间接通过推送网关来拉取监控指标，它在本地存储所有抓取到的样本数据，并对此数据执行一系列规则，以汇总和记录现有数据的新时间序列或生成告警。可以通过
Grafana 或者其他工具来实现监控数据的可视化。&lt;/p&gt;

&lt;p&gt;Prometheus 生态系统由多个组件组成，其中有许多组件是可选的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Prometheus Server 作为服务端，用来存储时间序列数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;客户端库用来检测应用程序代码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用于支持临时任务的推送网关。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Exporter 用来监控 HAProxy，StatsD，Graphite 等特殊的监控目标，并向
Prometheus 提供标准格式的监控样本数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;alartmanager 用来处理告警。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;适用场景&quot;&gt;适用场景&lt;/h2&gt;

&lt;p&gt;Prometheus
适用于记录文本格式的时间序列，它既适用于以机器为中心的监控，也适用于高度动态的面向服务架构的监控。在微服务的世界中，它对多维数据收集和查询的支持有特殊优势。Prometheus
是专为提高系统可靠性而设计的，它可以在断电期间快速诊断问题，每个
Prometheus Server
都是相互独立的，不依赖于网络存储或其他远程服务。当基础架构出现故障时，你可以通过
Prometheus 快速定位故障点，而且不会消耗大量的基础架构资源。&lt;/p&gt;

&lt;h2 id=&quot;不适用场景&quot;&gt;不适用场景&lt;/h2&gt;

&lt;p&gt;Prometheus
非常重视可靠性，即使在出现故障的情况下，你也可以随时查看有关系统的可用统计信息。如果你需要百分之百的准确度，例如按请求数量计费，那么
Prometheus
不太适合你，因为它收集的数据可能不够详细完整。这种情况下，你最好使用其他系统来收集和分析数据以进行计费，并使用
Prometheus 来监控系统的其余部分。&lt;/p&gt;

&lt;h1 id=&quot;存储结构&quot;&gt;存储结构&lt;/h1&gt;

&lt;p&gt;Prometheus 1.0之前重度依赖LevelDB（V2版本存储实现），Prometheus
2.0版本之后，推出了V3版本存储实现，也就是这里要介绍的Prometheus
TSDB项目。Prometheus
TSDB的写入性能异常出众，在其原理博客中提到Prometheus
TSDB在单机上可以支撑每秒百万级时序点的写入。&lt;/p&gt;

&lt;h2 id=&quot;facebook-gorilla简介&quot;&gt;Facebook Gorilla简介&lt;/h2&gt;

&lt;p&gt;Prometheus TSDB实现参考了Facebook 2015年发表的论文《Gorilla: A Fast,
Scalable, In-Memory Time Series
DataBase》（&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.718.197&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.718.197&amp;amp;rep=rep1&amp;amp;type=pdf&lt;/a&gt;），其中详细介绍了Gorilla时序数据库的原理，英文阅读吃力的读者可以参考一些翻译文章（&lt;a href=&quot;https://yq.aliyun.com/articles/72871&quot;&gt;https://yq.aliyun.com/articles/72871&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;在时序场景中，每个时序点的核心本质是一对64位的值，一个表示该点的timestamp，另一个表示该点的value值。Prometheus
TSDB借鉴了Facebook Gorilla论文的压缩方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;delta-of-delta方式压缩timestamp&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XOR压缩时序点的value值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;时间序列压缩&quot;&gt;时间序列压缩&lt;/h2&gt;

&lt;p&gt;在时序场景中，每条时序中的每个时序点都有一个对应的timestamp，一条时序中相邻时序点间隔是有规律，例如秒级、分钟级别。这样，相邻两点的timestamp差值是固定的。&lt;/p&gt;

&lt;p&gt;Facebook
Gorill的相关论文中提出了delta-of-delta（差值的差值）压缩timestamp的方式，下面具体来看delta-of-delta时间戳压缩方式是什么含义。&lt;/p&gt;

&lt;p&gt;由于网络延迟等原因，可能某两个时序点的timestamp差值会略大或略小于60秒。假设该实例中相邻时序点之间的timestamp差值分别为60、60、59、60、61、59，dod（delta-of-delta）就是用当前timestamp差值减去前一个timestamp差值得到的差值，那么得出的dod（delta-of-delta）为0、-1、1、1、-2，如图2-1所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/prometheus学习/image3.jpeg&quot; alt=&quot;https://pic3.zhimg.com/80/v2-81800333cac2271155e934e6bcdf9532_hd.jpg&quot; /&gt;{width=”5.768055555555556in”
height=”0.9698873578302712in”}&lt;/p&gt;

&lt;p&gt;Prometheus TSDB对这些dod值（delta-of-delta）的变长编码规则如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在存储时序的第一个数据点的时间戳t0时，会将其完整的存储起来。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在存储时序第二个数据点对应的时间戳t1时，实际上存储的是t1-t0这个差值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于后续的时间戳tn，首先会计算dod（delta-of-delta）值：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/prometheus学习/image4.png&quot; alt=&quot;&quot; /&gt;{width=”3.805751312335958in”
 height=”0.6111428258967629in”}&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果dod值为0，则使用一个单独的bit存储一个”0”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果dod值在[-8191,
8192]范围中，则存储”10”这两位作为标识，然后使用14个bit位存储该dod值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果dod值在[-65535,
65536]范围中，则存储”110”这三位作为标识，然后使用17个bit位存储该dod值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果dod值在[-524287,
524288]范围中，则存储”1110”这四位作为标识，然后使用20个bit位存储该dod值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果dod值超出了上述返回，则存储”1111”这四位作为标识，然后使用64个bit位存储该dod值。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图展示了Gorilla中时间戳最终值的分布情况，大约96%的timestamp能够按照dod值为0的条件分支进行存储，这样就可以大大减少timestamp的存储所占的空间以及IO。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/prometheus学习/image5.png&quot; alt=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/5c1be53b23edefeb52c2c92b0389c151.png&quot; /&gt;{width=”5.768055555555556in”
height=”4.042750437445319in”}&lt;/p&gt;

&lt;h2 id=&quot;值压缩&quot;&gt;值压缩&lt;/h2&gt;

&lt;p&gt;在很多监控场景中，同一条时序中相邻时序点的value值不会发生明显变化。时序点的value值大都是浮点类型，当两个value值非常接近的时候，这两个浮点数的符号位、指数位和尾数部分的前几位都是完全相同的，这一点也是Prometheus
TSDB对value值进行压缩的基础。&lt;/p&gt;

&lt;p&gt;下面我们可以将时序中相邻两时序点的value值做如下操作，实现压缩效果。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;时序中第一个时序点的value值不做压缩，直接保存。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从第二个时序点开始，将其value值与前一时序点的value值进行XOR运算。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果XOR运算的结果为0，则表示这两个时序点的value值相同，只需要使用一个bit位存储”0”值即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果XOR运算的结果不是0，则需要使用到2个bit值的控制位，这里首先将控制位的第一个bit存储为”1”，接下来看控制位的第二个bit值：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;控制位第二个bit为”0”时，表示此次计算得到的XOR结果中间非0的部分被前一个XOR运算结果包含。例如，与前一个XOR运算结果相比，此次XOR运算结果也有同样多的前置0和同样多的尾部0，那么我们就只需要存储XOR结果中非0的部分即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;控制位第二个bit位为”1”时，需要用5个bit位来存储XOR结果中前置0的数量，然后用6个bit位来存储XOR结果中间非0位的长度，最后再存储中间非0位。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图描述了实际的数据分布情况，大约有59%值只用了1位存储，也就是当前值和前序值完全一样；28.3%控制位为’10’(上面提到的规则a)，平均占用26.6位；余下12.6%的控制位为’11’，平均占用36.9位，位数多是因为对前置0和中间非0位的长度编码需要额外13位。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/prometheus学习/image6.png&quot; alt=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/9b95f281f04d7ce2503f46a277ed571f.png&quot; /&gt;{width=”5.768055555555556in”
height=”4.2976738845144355in”}&lt;/p&gt;

&lt;p&gt;这种压缩算法同时使用了前序值和前序XOR值，这样会使最终的结果值具有更好的压缩率，这是因为一段连续XOR值的前置0和尾部0个数往往非常接近，见图4。这种算法对整型的压缩效果更好，整型值经过XOR运算后的中间段位的位置一般在整个时间序列中对齐的，意味着大多数XOR值有相同个数的尾部0。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/prometheus学习/image7.png&quot; alt=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/370d2f719a5503e3beac0e68dae450c1.png&quot; /&gt;{width=”5.768055555555556in”
height=”3.8886811023622045in”}&lt;/p&gt;

&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/prometheus学习/image8.png&quot; alt=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/856703572628a6f9f22c97e6d93d6fac.png&quot; /&gt;{width=”5.768055555555556in”
height=”3.451388888888889in”}&lt;/p&gt;

&lt;p&gt;第一块为时间（02:00:00），第二块为62秒，value为12.&lt;/p&gt;

&lt;p&gt;02:02:02-02:01:02
时间间隔为60，在[-63,64]之间，存’10’。后面为7位，本次间隔60减去上次间隔62，结果为-2，value值也为12，所以记为0.&lt;/p&gt;

&lt;p&gt;02:03:02-02:02:02
时间间隔为60，与上次间隔相同,记为0。本次值为浮点数24，上次值为浮点数12,Xor值为0x0010000000000000，XOR结果非0，控制位的第一位存’1’，前一个数据块的非0也不被前一个包含，记为11（2位表示）。十六进制换算后，前面有11个0，再记为11（5位表示），中间非0的长度（1位表示），最后再存储中间非0位’1’（本次1位）&lt;/p&gt;

&lt;p&gt;问题：&lt;/p&gt;

&lt;p&gt;为什么Xor值为0x0010000000000000，前面的0的位数是11？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/prometheus学习/image9.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.6555555555555554in”}&lt;/p&gt;

&lt;h1 id=&quot;存储设计&quot;&gt;存储设计&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../images/prometheus学习/image10.png&quot; alt=&quot;https://images2017.cnblogs.com/blog/440956/201710/440956-20171022132056521-1693764367.png&quot; /&gt;{width=”5.768055555555556in”
height=”3.107275809273841in”}&lt;/p&gt;

&lt;p&gt;整体流程是 抓取数据写到head chunk，写满120
sample或到达估算时间，就再生成新的块，完成的块，是不可再变更的根据配置文件的设置，有一部份chunk会被保留在内存里，按照LRU算法，定期将块写进磁盘文件内。&lt;/p&gt;

&lt;p&gt;每一个head chunk 使用xxhash算法对labels进行hash，提供了16384大小的series
hash空间。新数据通过对label进行hash，找到对应的series进行append[append(series,time,value)]，每个chunk的头部是全量数据，后续为压缩数据，超过120个sample之后，新建立一个chunk。&lt;/p&gt;

&lt;p&gt;这样保证了热数据都在内存中，并且相应需要聚合的数据都在一个chunk或相邻的chunk中，提高了聚合效率。&lt;/p&gt;

&lt;p&gt;Prometheus
TSDB会将时序数据按照时间进行切分，默认配置中以2小时为一个单位。Prometheus
TSDB将最近一个时间单位的时序数据存储在内存中，再之前的每个单位中的时序数据会对应持久化到一个block目录下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/prometheus学习/image11.jpeg&quot; alt=&quot;https://pic3.zhimg.com/80/v2-f8def31e53db8210a4b0cd371315f3da_hd.jpg&quot; /&gt;{width=”5.768055555555556in”
height=”1.5125120297462817in”}&lt;/p&gt;

&lt;p&gt;之所以有这样的设计是因为时序数据的特点：越是距离当前时间近的时序数据，读写频率就越高；距离当前时间越远的时序数据，读写频率就越低。例如上述的机器监控场景中，机器上报的监控都是近期的数据，用户经常查询的也是近期的监控时序；而历史监控数据的修改和查询就比较少。从这个角度看，Prometheus
TSDB实际上是一个内存型+持久型的TSDB。&lt;/p&gt;

&lt;p&gt;在每个持久化的block目录下，可能会包含如下文件（或目录）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;chunks目录：chunks目录中包含多个chunk文件，chunk文件用于保存时序数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;index文件：index文件可以帮助我们通过metric
name（指标名称）以及labels信息查找对应时序数据所在的chunk文件以及在chunk文件中的具体位置。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;metadata文件：meta文件主要用于记录当前block目录涉及到一些元数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WAL日志文件:Prometheus
TSDB默认将最新写入的时序数据保存在内存block中，当达到2小时后，Prometheus
TSDB会将内存中的block直接持久化到磁盘中。为了防止程序崩溃导致内存block中的数据丢失，Prometheus
TSDB实现了WAL（write-ahead-log）机制，即会在向内存block写入数据的同时向WAL日志文件追加日志。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tombstone文件：主要用于记录删除时序数据的信息。Prometheus
TSDB在删除时序数据时并不会立即将时序数据从chunk文件中删除，而是在关联的tombstone文件中进行记录，在后续block压缩的时候，才会真正完成删除的操作。这种”懒删除”方式在很多场景中都会用到，例如Redis、Kafka的代码中都能看到该方案的影子。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;随着Prometheus运行时间的推移，Prometheus
TSDB会将内存block持久化到磁盘，同时也会将磁盘上2小时的block目录压缩成更大的block目录（例如，5个2小时的block目录进行压缩，得到的block目录负责存储对应10小时范围的数据，具体的压缩行为可以根据用户需求进行配置），在上述压缩操作完成之后，会将原有的2小时block目录删除。当然，这里得到的10小时block目录还可以继续压缩，具体压缩层级也是可以配置的。Prometheus
TSDB的压缩方案实际上与LevelDB、RocksDB等基于LSM树实现存储思路一致。另外，在压缩过程中还会根据tombstone文件清理已删除的时序数据。&lt;/p&gt;

&lt;h1 id=&quot;引用&quot;&gt;引用&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/liukuan73/article/details/79950329&quot;&gt;https://blog.csdn.net/liukuan73/article/details/79950329&lt;/a&gt;
&lt;a href=&quot;https://www.cnblogs.com/vovlie/p/7709312.html&quot;&gt;https://www.cnblogs.com/vovlie/p/7709312.html&lt;/a&gt;
&lt;a href=&quot;https://yq.aliyun.com/articles/174535&quot;&gt;https://yq.aliyun.com/articles/174535&lt;/a&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59691668&quot;&gt;https://zhuanlan.zhihu.com/p/59691668&lt;/a&gt;
&lt;a href=&quot;https://fabxc.org/tsdb/&quot;&gt;https://fabxc.org/tsdb/&lt;/a&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60212547&quot;&gt;https://zhuanlan.zhihu.com/p/60212547&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/prometheus%E5%AD%A6%E4%B9%A0&quot;&gt;Prometheus学习&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on December 16, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[docker网络学习]]></title>
  <link>http://yangqiju.github.io/docker-network</link>
  <id>http://yangqiju.github.io/docker-network</id>
  <published>2019-10-15T00:00:00-04:00</published>
  <updated>2019-10-15T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;p&gt;Docker网络&lt;/p&gt;

&lt;h1 id=&quot;flannel&quot;&gt;Flannel&lt;/h1&gt;

&lt;p&gt;Flannel通过在每一个节点上启动一个叫flanneld的进程，负责每一个节点上的子网划分，并将相关的配置信息如各个节点的子网网段、外部IP等保存到etcd当中，而具体的网络包转发交给具体的Backend来实现。&lt;/p&gt;

&lt;p&gt;flanneld可以在启动的时候通过配置文件来指定不同的Backend来进行网络通信，目前比较成熟的Backend有VXLAN、host-gw以及UDP三种方式，也已经有诸如AWS，GCE
and
AliVPC这些还在实验阶段的Backend。VXLAN是目前官方最推崇的一种Backend实现方式，host-gw一般用于对网络性能要求比较高的场景，但需要基础架构本身的支持，UDP则一般用于Debug和一些比较老的不支持VXLAN的Linux内核。&lt;/p&gt;

&lt;h2 id=&quot;udp&quot;&gt;UDP&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image1.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.8777777777777778in”}&lt;/p&gt;

&lt;p&gt;假设在节点A上有容器A（10.244.1.96），在节点B上有容器B（10.244.2.194），此时容器A向容器发送一个ICMP请求报文（ping），我们来逐步分析一下ICMP报文是如何从容器A到达容器B的。&lt;/p&gt;

&lt;p&gt;当采用UDP模式时，flanneld进程在启动时会通过打开/dev/net/tun的方式生成一个TUN设备，TUN设备可以简单理解为Linux当中提供的一种内核网络与用户空间（应用程序）通信的一种机制，即应用可以通过直接读写tun设备的方式收发RAW
IP包。&lt;/p&gt;

&lt;p&gt;flanneld进程会对flannel0进行监听，会持续的从flannel0中poll数据，当有数据时会通过udp数据封装，并进行数据发送。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;容器A当中发出ICMP请求报文，通过IP封装后形式为：10.244.1.96 -&lt;br /&gt;
10.244.2.194，此时通过容器A内的路由表匹配到应该将IP包发送到网关10.244.1.1（cni0网桥）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;此时到达cni0的IP包目的地IP
10.244.2.194匹配到节点A上第一条路由规则（10.244.0.0），内核将RAW
IP包发送给flannel0接口。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flannel0为tun设备，发送给flannel0接口的RAW
IP包（无MAC信息）将被flanneld进程接收到，flanneld进程接收到RAW
IP包后在原有的基础上进行UDP封包，UDP封包的形式为：172.16.130.140:src
port -\ 172.16.130.164:8285。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flanneld将封装好的UDP报文经eth1发出，从这里可以看出网络包在通过eth1发出前先是加上了UDP头（8个字节），再然后加上了IP头（20个字节）进行封装，这也是为什么flannel0的MTU要比eth1的MTU小28个字节的原因（防止封装后的以太网帧超过eth1的MTU而在经过eth1时被丢弃）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网络包经节点A和节点B之间的网络连接到达host B&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host
B收到UDP报文后经Linux内核通过UDP端口号8285将包交给正在监听的应用flanneld&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;运行在host B当中的flanneld将UDP包解包后得到RAW IP包：10.244.1.96 -&lt;br /&gt;
10.244.2.194&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解封后的RAW IP包匹配到host B上的路由规则（10.244.2.0），内核将RAW
IP包发送到cni0&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cni0将IP包转发给连接在cni0网桥上的container B&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;vxlan&quot;&gt;VXLAN&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image2.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.7916666666666665in”}&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;同UDP Backend模式，容器A当中的IP包通过容器A内的路由表被发送到cni0&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;到达cni0当中的IP包通过匹配host
A当中的路由表（route）发现通往10.244.2.194的IP包应该交给flannel.1接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flannel.1作为一个VTEP设备，收到报文后将按照VTEP的配置进行封包，首先通过etcd得知10.244.2.194属于节点B，并得到节点B的IP，通过节点A当中的转发表(FDB)得到节点B对应的VTEP的MAC，根据flannel.1设备创建时的设置的参数（VNI、local
IP、Port）进行VXLAN封包&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过host A跟host B之间的网络连接，VXLAN包到达host B的eth1接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过端口8472，VXLAN包被转发给VTEP设备flannel.1进行解包&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解封装后的IP包匹配host
B当中的路由表（10.244.2.0），内核将IP包转发给cni0&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cni0将IP包转发给连接在cni0上的容器B&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;VXLAN替代了UDP模式下的程序封包处理，在内核中进行数据包的处理。当hostA的flannel.1要向hostB
的flannel.1发送数据时，会先ARP探测，HostB回应后记录到fdb中，当下次再进行向HostB的flannel.1发送消息时，会直接确定ip。例如CD:37为HostB的flannel.1的MAC地址，VXLAN是三层实现二层协议，构建的数据包通过MAC通讯。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image3.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”0.7784722222222222in”}&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.just4coding.com/blog/2017/05/21/vxlan/&quot;&gt;http://www.just4coding.com/blog/2017/05/21/vxlan/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;host-gw&quot;&gt;HOST-GW&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image4.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.8993055555555554in”}&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;同UDP、VXLAN模式一致，通过容器A的路由表IP包到达cni0&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;到达cni0的IP包匹配到host
A当中的路由规则（10.244.2.0），并且网关为172.16.130.164，即host
B，所以内核将IP包发送给host B（172.16.130.164）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IP包通过物理网络到达host B的eth1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;到达host B eth1的IP包匹配到host
B当中的路由表（10.244.2.0），IP包被转发给cni0&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cni0将IP包转发给连接在cni0上的容器B&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;采用host-gw模式后flanneld的唯一作用就是负责主机上路由表的动态更新。&lt;/p&gt;

&lt;p&gt;host-gw模式其中一个局限性就是，由于是通过节点上的路由表来实现各个节点之间的跨节点网络通信，那么就得保证两个节点是可以直接路由过去的。按照内核当中的路由规则，网关必须在跟主机当中至少一个IP处于同一网段，故造成的结果就是采用host-gw这种Backend方式时则集群中所有的节点必须处于同一个网络当中，这对于集群规模比较大时需要对节点进行网段划分的话会存在一定的局限性。另外一个则是随着集群当中节点规模的增大，flanneld需要维护主机上成千上万条路由表的动态更新也是一个不小的压力。&lt;/p&gt;

&lt;h1 id=&quot;docker-routing-mesh&quot;&gt;Docker Routing Mesh&lt;/h1&gt;

&lt;h2 id=&quot;docker-swarm&quot;&gt;Docker Swarm&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image5.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.5993055555555555in”}&lt;/p&gt;

&lt;p&gt;Docker Swarm 为Docker 提供了集群服务，Swarm
集群的管理工作是由manager节点实现。如上图所示，manager节点实现的功能主要包括：node
discovery,scheduler,cluster管理等。同时，为了保证Manager
节点的高可用，Manager 节点需要时刻维护和保存当前 Swarm
集群中各个节点的一致性状态。Worker节点接收并执行从Manager节点分派的任务。默认情况下，Manager节点还将服务作为Worker节点运行，但也可以将它们配置为仅运行Manage任务。&lt;/p&gt;

&lt;h2 id=&quot;跨主机网络&quot;&gt;跨主机网络&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image6.png&quot; alt=&quot;006.png&quot; /&gt;{width=”5.768055555555556in”
height=”4.4215277777777775in”}&lt;/p&gt;

&lt;p&gt;所有的container都会接入到vxlan构建的br0网桥，组成一个局域网。&lt;/p&gt;

&lt;p&gt;跨主机网络通过vxlan实现，下面以bjdt_overlay为测试：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image7.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.4229166666666666in”}&lt;/p&gt;

&lt;p&gt;通过执行以下命令，可以查看vxlan的id编号:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  &lt;span class=&quot;o&quot;&gt;--------------------------------------&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;docker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inspect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bjdt&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_overlay&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;--------------------------------------&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image8.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”0.42430555555555555in”}&lt;/p&gt;

&lt;p&gt;通过 docker stack
deploy构建出overlay后，可以通过查看network，获得network
id，例如5mckih8b5zq5，在相应的namespace目录下会生成一个以”1-“开头的namespace文件，/run/docker/netns/1-5mckih8b5zq5，通过nsenter
指令可进行该namespace的处理。可以看到编号为4097的vxlan已经生成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image9.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”1.8875in”}&lt;/p&gt;

&lt;p&gt;通过 ip
addr可以看到，该namespace构建了一个ip为10.0.0.1的网桥，用于vxlan的通讯。在该overlay网络下，各个服务模块之间的通讯将会使用该网络的ip进行数据通讯。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image10.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.8986111111111112in”}&lt;/p&gt;

&lt;h2 id=&quot;内部负载均衡&quot;&gt;内部负载均衡&lt;/h2&gt;

&lt;p&gt;以下描述为(docker stack
deploy模式下，单独启动servcie参考&lt;a href=&quot;https://anoyi.com/p/dba9342071d8&quot;&gt;https://anoyi.com/p/dba9342071d8&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image11.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;{width=”5.768055555555556in”
height=”2.9483792650918637in”}&lt;/p&gt;

&lt;p&gt;Docker swarm 内部 service
的负载均衡默认是基于vip来实现的，例如当client请求多个web的时候，docker内部的DNS
server会解析出一个VIP。通过vip可以在client感知的情况下进行web的负载均衡。&lt;/p&gt;

&lt;p&gt;如上图所示，具体实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;client通过内部的DSN server获得VIP，进行数据发送&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据发往到vip，vip绑定到了一个loadbalance 的network sandbox的网卡中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在该sandbox中，将会使用iptables
对mangle表进行数据打标签，再通过ipvs进行数据转发&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后走overlay网络到达实际容器进行业务处理&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;

&lt;p&gt;以示例业务举例：&lt;/p&gt;

&lt;p&gt;bjdt_bjdt-dzwl-web
为web前端，后端业务为3个节点的bjdt_bjdt-dzwl服务。他们都是基于bjdt_overlay网络。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image13.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.4215277777777777in”}&lt;/p&gt;

&lt;p&gt;通过以下指令可以看到服务的vip：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;o&quot;&gt;+-----------------------------------------------+&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;docker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inspect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bjdt&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_bjdt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dzwl&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\#\#\#\#\#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;输出内容&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\#\#\#\#\#\#\#\#&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;VirtualIPs\&quot;: \[                            ||
| {                                             |
| \&quot;NetworkID\&quot;: \&quot;t17rqrj45unnb42hefovj68mh\&quot;, |
| \&quot;Addr\&quot;: \&quot;10.255.0.41/16\&quot;                  |
| },                                            |
| {                                             |
| \&quot;NetworkID\&quot;: \&quot;5mckih8b5zq55feis4xheef5z\&quot;, |
| \&quot;Addr\&quot;: \&quot;10.0.0.20/24\&quot;&lt;/span&gt;                    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;                                             &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;                                            &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;+-----------------------------------------------+&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;使用docker stack
deploy后，系统会自动添加前缀为”lb_“的负载namespace文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image14.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.6430555555555557in”}&lt;/p&gt;

&lt;p&gt;在该namespace下通过执行ip addr 可以看到 bjdt_bjdt-dzwl
的vip在该网卡下绑定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image15.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”4.363194444444445in”}&lt;/p&gt;

&lt;p&gt;通过iptables可以看到为目标地址为10.0.0.20的数据包添加了0X149(10进制为329)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image16.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.361111111111111in”}&lt;/p&gt;

&lt;p&gt;通过ipvsadm可以看到对于有0X149标签的数据包会转发到以下三个ip中，而该三个ip分别为实际业务后台的ip地址。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image17.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”4.24375in”}&lt;/p&gt;

&lt;h3 id=&quot;多负载&quot;&gt;多负载&lt;/h3&gt;

&lt;p&gt;在一个我们实际业务场景中，会将一个stack部署在同一个overlay中，也可能会存在多个service，但是并不会产生多个loadbalance，而是统一会生成一个以”lb_“为开头，后缀为overlay
id的network
namespace。而这个loadbalance负责了整个overlay网络的负载均衡。&lt;/p&gt;

&lt;h2 id=&quot;routing-mesh&quot;&gt;Routing Mesh&lt;/h2&gt;

&lt;p&gt;Docker Swarm
的overlay网络解决了跨主机网络通讯的问题的同时，还提供了负载均衡。&lt;/p&gt;

&lt;p&gt;以下面的图片示例：当请求负载到三台机器的任何一台机器，都会进行swarm load
balancer，即使请求到了没有实际应用的node3，swarm也会将数据负载到node2节点，完成业务处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image19.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;{width=”5.768055555555556in”
height=”3.1595166229221348in”}&lt;/p&gt;

&lt;p&gt;实际数据包的走向如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image20.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;{width=”5.768055555555556in”
height=”3.3570253718285215in”}&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Host1的8000端口收到数据包后，通过iptables
DNAT转发到ingress-sbox(network sandbox)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ingress-sbox使用iptables 进行打标签，并转发到vxlan组成的overlay网络&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;请求通过overlay网络跨主机到达实际的处理容器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Routing mesh 和 业务overlay的网络组合如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/docker_net/image21.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;{width=”5.768055555555556in”
height=”3.646311242344707in”}&lt;/p&gt;

&lt;p&gt;可以简单的理解为：routing mesh（ingress
network）解决了服务在对外publish了端口之间的负载均衡，每个主机都会连接ingress
network，他负责将流量送达到前置服务。后续多个容器或服务之间的业务数据交换，将会在自定义的overlay网络进行网络包流转。&lt;/p&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.just4coding.com/blog/2017/05/21/vxlan/&quot;&gt;http://www.just4coding.com/blog/2017/05/21/vxlan/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jkzhao.github.io/2017/09/05/overlay%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/&quot;&gt;https://jkzhao.github.io/2017/09/05/overlay%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/goldsunshine/p/10740928.html&quot;&gt;https://www.cnblogs.com/goldsunshine/p/10740928.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/huangjun0210/article/details/86478157&quot;&gt;https://blog.csdn.net/huangjun0210/article/details/86478157&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.daocloud.io/docker1-12lb/&quot;&gt;http://blog.daocloud.io/docker1-12lb/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://success.docker.com/article/ucp-service-discovery-swarm&quot;&gt;https://success.docker.com/article/ucp-service-discovery-swarm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhoujinl.github.io/2018/09/20/docker-swarm-scheduler/&quot;&gt;https://zhoujinl.github.io/2018/09/20/docker-swarm-scheduler/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.51cto.com/jerry12356/2384159&quot;&gt;https://blog.51cto.com/jerry12356/2384159&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMTUwMDMyOQ==&amp;amp;mid=2247492160&amp;amp;idx=1&amp;amp;sn=6ff4c4423f4834042e0ad3b476bafd9f&amp;amp;chksm=e8396486df4eed90bc1c401e2a20b070931e700b9e6f6931bdaf9820f3d0974fdac3cdf09c31&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1014dpS7QNtyWCQ5uBg8fZXc&amp;amp;sharer_sharetime=1571068017820&amp;amp;sharer_shareid=5604a26ad45580769f078004811e0dc5&amp;amp;key=e224974e93afb4cc75358c6974746b3e9438b850e7120ca8338645c3298c01d5e11619cd726cb256c5983147aa2ec180fe77b69962fe6295a15e791f61c4ba4c4a18e46d56aa0b9ab4d318d81d1a4e7a&amp;amp;ascene=0&amp;amp;uin=NDEyMzAwMDgw&amp;amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.15+build(19A583)&amp;amp;version=12020010&amp;amp;nettype=WIFI&amp;amp;lang=zh_CN&amp;amp;fontScale=100&amp;amp;pass_ticket=1PafF1oOL%2FoCfZqc5Sh0obHz6PGNO15q%2FGD4MvDPcv3pPTVOEXb5JOZ4vjFCbh8E&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzIyMTUwMDMyOQ==&amp;amp;mid=2247492160&amp;amp;idx=1&amp;amp;sn=6ff4c4423f4834042e0ad3b476bafd9f&amp;amp;chksm=e8396486df4eed90bc1c401e2a20b070931e700b9e6f6931bdaf9820f3d0974fdac3cdf09c31&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1014dpS7QNtyWCQ5uBg8fZXc&amp;amp;sharer_sharetime=1571068017820&amp;amp;sharer_shareid=5604a26ad45580769f078004811e0dc5&amp;amp;key=e224974e93afb4cc75358c6974746b3e9438b850e7120ca8338645c3298c01d5e11619cd726cb256c5983147aa2ec180fe77b69962fe6295a15e791f61c4ba4c4a18e46d56aa0b9ab4d318d81d1a4e7a&amp;amp;ascene=0&amp;amp;uin=NDEyMzAwMDgw&amp;amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.15+build(19A583)&amp;amp;version=12020010&amp;amp;nettype=WIFI&amp;amp;lang=zh_CN&amp;amp;fontScale=100&amp;amp;pass_ticket=1PafF1oOL%2FoCfZqc5Sh0obHz6PGNO15q%2FGD4MvDPcv3pPTVOEXb5JOZ4vjFCbh8E&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;问题&quot;&gt;问题&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;UDP模式，这里有一个问题就是flanneld怎么知道10.244.2.194这个容器到底是在哪个节点上呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;flanneld在启动时会将该节点的网络信息通过api-server保存到etcd当中，故在发送报文时可以通过查询etcd得到10.244.2.194这个容器的IP属于host
 B，且host B的IP为172.16.130.164。实现逻辑没有确认。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;VXLAN的转发表作用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;


  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/docker-network&quot;&gt;docker网络学习&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on October 15, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[KCP学习]]></title>
  <link>http://yangqiju.github.io/kcp%E5%AD%A6%E4%B9%A0</link>
  <id>http://yangqiju.github.io/kcp学习</id>
  <published>2019-09-09T00:00:00-04:00</published>
  <updated>2019-09-09T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;

&lt;p&gt;如何网络加速？网络加速的不是说固定宽带为10m，让你用出了20m的速度。而是10m的带宽不加速的情况下像是1m带宽，通过一些手段尽量提升到5m的体验。&lt;/p&gt;

&lt;h2 id=&quot;vpn&quot;&gt;Vpn&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image1.jpeg&quot; alt=&quot;https://pic2.zhimg.com/80/e823ad92b0301746ac7fef82f09d8663_hd.jpg&quot; /&gt;{width=”5.768055555555556in”
height=”3.4079877515310586in”}&lt;/p&gt;

&lt;p&gt;缩短客户端与服务器的链路，并且用更优的线路。&lt;/p&gt;

&lt;h2 id=&quot;kcp&quot;&gt;KCP&lt;/h2&gt;

&lt;p&gt;利用现有的链路，通过传输速率，网络加速的不是说固定宽带为10m，让你用出了20m的速度。而是10m的带宽不加速的情况下像是1m带宽，通过一些手段尽量提升到5m的体验。&lt;/p&gt;

&lt;p&gt;如果网络永远不卡，那 KCP/TCP
表现类似，但是网络本身就是不可靠的，丢包和抖动无法避免（否则还要各种可靠协议干嘛）。在内网这种几乎理想的环境里直接比较，大家都差不多，但是放到公网上，放到3G/4G网络情况下，或者使用内网丢包模拟，差距就很明显了。公网在高峰期有平均接近10%的丢包，wifi/3g/4g下更糟糕，这些都会让传输变卡。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image2.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.7729166666666667in”}&lt;/p&gt;

&lt;h1 id=&quot;tcp基础&quot;&gt;TCP基础&lt;/h1&gt;

&lt;p&gt;在学习TCP协议之前，首先我们需要知道OSI模型，它是以太网最基本也是最重要的知识，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image3.png&quot; alt=&quot;https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png&quot; /&gt;{width=”5.768055555555556in”
height=”3.123254593175853in”}&lt;/p&gt;

&lt;p&gt;如图所示，OSI定义了网络互联的七层框架，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。&lt;/p&gt;

&lt;p&gt;而TCP/IP模型基于OSI模型，又构建了自己的5层模型，它与OSI模型的对应关系如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image4.png&quot; alt=&quot;https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234827195-1493107425.png&quot; /&gt;{width=”5.768055555555556in”
height=”2.092962598425197in”}&lt;/p&gt;

&lt;p&gt;其中，TCP 是以太网协议和 IP 协议的上层协议，也是应用层协议的下层协议。&lt;/p&gt;

&lt;h2 id=&quot;tcp报文&quot;&gt;TCP报文&lt;/h2&gt;

&lt;p&gt;以太网数据包（packet）的大小是固定的，1500
字节是负载（payload），22字节是头信息（head）。IP
数据包在以太网数据包的负载里面，它也有自己的头信息，ipv4最少需要20字节，所以
IP 数据包的负载最多为1480字节。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image5.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”2.06875in”}&lt;/p&gt;

&lt;p&gt;TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP
数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP
协议往往有额外的头信息（例如SACK），所以 TCP 负载实际为1400字节左右。&lt;/p&gt;

&lt;p&gt;TCP头信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image6.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.3680555555555554in”}&lt;/p&gt;

&lt;p&gt;其中一些比较重要的字段含义如下：&lt;/p&gt;

&lt;p&gt;source port和destination port用来定义一个tcp链接。&lt;/p&gt;

&lt;p&gt;sequence number和acknowledgment
number是用于唯一标识一个tcp报文的，acknowledgment
number还用来确认报文的可达性。&lt;/p&gt;

&lt;p&gt;tcp flags是在tcp连接过程中的一些状态标识，包括SYN, FIN, ACK, PSH, RST,
URG，分别表示：建立连接，关闭连接，响应，有无data传输，连接重置，紧急指针。&lt;/p&gt;

&lt;p&gt;Window为滑动窗口，它是用来获得最优的连接速率，因为一般情况下我们的数据发送端和接收端处理速率不会相同，该字段用来控制传输流速率。&lt;/p&gt;

&lt;p&gt;Tcp options一个可选的数据，它有如下一些类型：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image7.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.607075678040245in”}&lt;/p&gt;

&lt;h2 id=&quot;滑动窗口&quot;&gt;滑动窗口&lt;/h2&gt;

&lt;p&gt;以下例子我们忽略操作系统缓冲区的变化，假定client端和server端的可用窗口是不变的，但实际情况下，我们的可用窗口是和操作系统的缓冲区相关的，并不是一直不变的！&lt;/p&gt;

&lt;h3 id=&quot;发送窗口&quot;&gt;发送窗口&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image8.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.342361111111111in”}&lt;/p&gt;

&lt;p&gt;如上图，#1部分代表已发送并确认的数据，#2代表已发送未收到，#3代表未发送但总大小满足接收方的处理范围，#4代表超出接收方处理范围的数据。&lt;/p&gt;

&lt;p&gt;当我们将46~51的字节数也发送给接收方后，如果过程中没有收到接收方的ack确认报文，我们将变为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image9.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”2.01875in”}&lt;/p&gt;

&lt;p&gt;此时我们的可用窗口耗尽，此时不能再向接收方发送数据，知道收到ack确认：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image10.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.2104166666666667in”}&lt;/p&gt;

&lt;p&gt;如上图，32~36的数据收到了ack确认，并且发送窗口的大小没有改变时，我们的发送窗口发生移动，右移5个字节，此时52~56字节成为了我们可用窗口。&lt;/p&gt;

&lt;h3 id=&quot;接收窗口&quot;&gt;接收窗口&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image11.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”2.9in”}&lt;/p&gt;

&lt;h2 id=&quot;重传策略&quot;&gt;重传策略&lt;/h2&gt;

&lt;h3 id=&quot;乐观发送&quot;&gt;乐观发送&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image12.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.571527777777778in”}&lt;/p&gt;

&lt;p&gt;为什么client无法告知收到了part4？&lt;/p&gt;

&lt;p&gt;TCP的报文到达确认（ACK），是对接收到的数据的最高序列号的确认，并向发送端返回一个下次接收时期望的TCP数据包的序列号（Ack
Number）。&lt;/p&gt;

&lt;p&gt;TCP数据包中的序列号（Sequence
Number）不是以报文段来进行编号的，而是将连接生存周期内传输的所有数据当作一个字节流，序列号就是整个字节流中每个字节的编号。&lt;/p&gt;

&lt;p&gt;如果回复了part4，代表着part4之前的全部收到了。&lt;/p&gt;

&lt;h3 id=&quot;悲观发送&quot;&gt;悲观发送&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image13.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.6909722222222223in”}&lt;/p&gt;

&lt;h3 id=&quot;快速重传&quot;&gt;快速重传&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image14.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.714583333333333in”}&lt;/p&gt;

&lt;p&gt;失序ACK，ack的值是缺失的报文的编号。&lt;/p&gt;

&lt;h3 id=&quot;sack&quot;&gt;SACK&lt;/h3&gt;

&lt;p&gt;选择性重传：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image15.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.1368055555555556in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image16.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.8583333333333334in”}&lt;/p&gt;

&lt;p&gt;TCP的报文到达确认（ACK），是对接收到的数据的最高序列号的确认，并向发送端返回一个下次接收时期望的TCP数据包的序列号（Ack
Number）。SACK标识已经收到了哪些失序报文。&lt;/p&gt;

&lt;p&gt;例如，server发送的当前数据序号是400，数据长度是100，则client收到后会返回一个确认号是501的确认号给client。但是700-800
已经到达了client，Client
的ack中会确认号为501，SACK标识失序报文为700-800。那么server就可以直接将500-700的重传就ok了。&lt;/p&gt;

&lt;h2 id=&quot;tcp慢启动与拥塞避免&quot;&gt;TCP慢启动与拥塞避免&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image17.png&quot; alt=&quot;&quot; /&gt;{width=”3.773480971128609in”
height=”2.809440069991251in”}&lt;/p&gt;

&lt;p&gt;最开始我们只发送一个mss，当我们收到ack后，第二次发送2个mss，收到ack并没有发生丢包后，我们发送4个mss，之后发送8个，以此类推，这是一个指数级增长的过程。它解决的问题是我们的tcp连接不清楚当前的网络状况，所以最开始我们试探性的发很小量的包，当我们确认网络中没有发生丢包之后，之后快速增长，当下我们慢启动的初始窗口是10个mss。&lt;/p&gt;

&lt;p&gt;由于慢启动的过程中我们发送的mss是以指数形式上升的，如果发生丢包，那么丢包的数量将非常多，而拥塞避免就是为了解决这个问题。它解决问题的方式是定义了一个慢启动阈值，当我们的拥塞窗口到达阈值时，我们的增长速度变为线性增长。当发生丢包时，我们将之前的阈值取1/2，拥塞窗口再降为一个比较小的数重新指数增长，当到达新的阈值后，再次线性增长（拥塞避免算法），之后重复该过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image18.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.3048611111111112in”}&lt;/p&gt;

&lt;p&gt;而当我们慢启动过程中如果还没到达我们的慢启动阈值时就发生了丢包，此时我们根据当前的拥塞窗口的值，取1/2生成新的阈值，重新开始慢启动.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image19.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.9520833333333334in”}&lt;/p&gt;

&lt;h2 id=&quot;nagle算法与延迟确认&quot;&gt;Nagle算法与延迟确认？&lt;/h2&gt;

&lt;p&gt;Nagle算法：&lt;/p&gt;

&lt;p&gt;是为了减少广域网的小分组数目，从而减小网络拥塞的出现；&lt;/p&gt;

&lt;p&gt;该算法要求一个tcp连接上最多只能有一个未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组，tcp需要收集这些少量的分组，并在ack到来时以一个分组的方式发送出去；&lt;/p&gt;

&lt;p&gt;如果不启用nagle算法，将是HELLO每个字符都一个请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image20.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.8354166666666667in”}&lt;/p&gt;

&lt;p&gt;延迟确认：&lt;/p&gt;

&lt;p&gt;如果tcp对每个数据包都发送一个ack确认，那么只是一个单独的数据包为了发送一个ack代价比较高，所以tcp会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ack，如果在延迟ack定时器触发时候，发现ack尚未发送，则立即单独发送；&lt;/p&gt;

&lt;p&gt;同时使用Nagle和延迟ACK的问题：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image21.jpeg&quot; alt=&quot;&quot; /&gt;{width=”3.906464348206474in”
height=”4.237568897637796in”}&lt;/p&gt;

&lt;p&gt;TCP可通过配置进行延迟ACK和Nagle算法的关闭。&lt;/p&gt;

&lt;p&gt;KCP可选择关闭延迟确认机制，并且没有使用Nagle算法。&lt;/p&gt;

&lt;h2 id=&quot;rto&quot;&gt;RTO&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image22.png&quot; alt=&quot;&quot; /&gt;{width=”4.159762685914261in”
height=”4.795580708661418in”}&lt;/p&gt;

&lt;p&gt;TCP是一个很可靠的消息协议，建立连接和断开连接以及通讯过程中，会需要发送ack包用于消息的确认。&lt;/p&gt;

&lt;p&gt;如果没有收到ACK会怎么样？重传。&lt;/p&gt;

&lt;p&gt;RTO: TCP超时重传机制(RTO：Retransmission Timeout) &lt;/p&gt;

&lt;p&gt;RTT: 往返时延(Round-Trip Time):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image23.png&quot; alt=&quot;&quot; /&gt;{width=”4.548202099737533in”
height=”3.823205380577428in”}&lt;/p&gt;

&lt;p&gt;超时重传指的是，发送数据包在一定的时间内没有收到相应的ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为RTO，即重传超时时间。&lt;/p&gt;

&lt;p&gt;TCP的默认RTO为上一次RTO的2倍，linux默认重试策略为3次，这样连续丢三次包就变成RTOx8了。&lt;/p&gt;

&lt;p&gt;在TCP协议中，定义了发送窗口和接收窗口。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image8.png&quot; alt=&quot;&quot; /&gt;{width=”4.845304024496938in”
height=”2.807662948381452in”}&lt;/p&gt;

&lt;p&gt;结合刚才的RTO，当32的ack包没有收到时，窗口将不会后移，接受新的数据。所以8RTO对于网速敏感的应用很不友好，KCP急速模式下把RTO将为1.5倍而不是8。&lt;/p&gt;

&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;KCP是一个快速可靠ARQ（自动重传请求Automatic
Repeat-reQuest，ARQ）协议，能以比
TCP浪费10%-20%的带宽的代价，换取平均延迟降低
30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以
callback的方式提供给 KCP。&lt;/p&gt;

&lt;p&gt;KCP是通过UDP定制化用于网络加速的类TCP协议。&lt;/p&gt;

&lt;h1 id=&quot;技术特性&quot;&gt;技术特性&lt;/h1&gt;

&lt;p&gt;TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而
KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比
TCP快30%-40%的传输速度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RTO翻倍vs不翻倍：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖，而KCP启动快速模式后不x2，只是x1.5（实验证明1.5这个值相对比较好），提高了传输速度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;选择性重传 vs 全部重传：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;快速重传：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4,
5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;延迟ACK vs 非延迟ACK：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大
RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UNA vs ACK+UNA：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而
KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非退让流控：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取了开着BT都能流畅传输的效果。&lt;/p&gt;

&lt;h1 id=&quot;协议逻辑&quot;&gt;协议逻辑&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image24.png&quot; alt=&quot;https://img-blog.csdnimg.cn/20181221090526734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvbmdrYWkwMjE0,size_16,color_FFFFFF,t_70&quot; /&gt;{width=”5.768055555555556in”
height=”2.1475251531058617in”}&lt;/p&gt;

&lt;p&gt;KCP通过ikcp_create
创建一个KCP对象，每个不同的会话将产生不同的对象。因为KCP协议本身并没有提供网络部分的代码，所以需要将UDP发送函数的回调设置到KCP中，在有需要时，调用回调函数即可。KCP也支持外部的内存分配与日志回调，为用户提供了非常充分的自由度。&lt;/p&gt;

&lt;p&gt;整个KCP协议主要依靠一个循环ikcp_update来驱动整个算法的运转，所有的数据发送，接收，状态变化都依赖于此，所以如果有操作占用每一次update的周期过长，或者设置内部刷新的时间间隔过大，都会导致整个算法的效率降低。在ikcp_update中最终调用的是ikcp_flush，这是协议中的一个核心函数，将数据，确认包，以及窗口探测和应答发送到对端。&lt;/p&gt;

&lt;p&gt;KCP使用ikcp_send发送数据，该函数调用ikcp_output发送数据，实际上最终调用事先注册的发送回调发送数据。KCP通过ikcp_recv将数据接收出来，如果被分片发送，将在此自动重组，数据将与发送前保持一致。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yongkai0214/article/details/85156452&quot;&gt;https://blog.csdn.net/yongkai0214/article/details/85156452&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;数据结构&quot;&gt;数据结构&lt;/h1&gt;

&lt;p&gt;下图是发送的数据结构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image25.png&quot; alt=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180616162543447-2120702410.png&quot; /&gt;{width=”5.768055555555556in”
height=”3.1633902012248467in”}&lt;/p&gt;

&lt;p&gt;如上图中，snd_queue待发送队列中有4个KCP包等待发送，这个时候snd_nxt下一个发送的kcp包序列号为11，snd_una下一个确认的KCP包为9（8已经确认，9，10已经发送但是还没得到接收方的确认）。因为cwnd=5，发送队列中还有2个发送了但是还未得到确认，所以可以从待发送队列中取前面的3个KCP包放入到发送队列中，序列号分别设置为11,12,13。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wetest/p/9190786.html&quot;&gt;https://www.cnblogs.com/wetest/p/9190786.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;kcptun&quot;&gt;KCPTUN&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image26.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.3868055555555556in”}&lt;/p&gt;

&lt;p&gt;KCPTUN是一个使用KCP建立的安全和高效的隧道。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/xtaci/kcptun&quot;&gt;https://github.com/xtaci/kcptun&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image27.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.772222222222222in”}&lt;/p&gt;

&lt;h1 id=&quot;其他&quot;&gt;其他&lt;/h1&gt;

&lt;h2 id=&quot;mtu-1500576&quot;&gt;MTU 1500？576？&lt;/h2&gt;

&lt;p&gt;MTU是网络连接中允许在一个物理帧中传输的最大数据量，TCP/IP驱动程序需要知道这个数值以便设置合适的数据包长度，以避免出现不必要的拆分过程。不同网络的MTU缺省值不一样，以太网的标准值为1500，而多数ISP提供的拨号网络的标准值为576，原因是Internet上不少路由器也为576。原则上来说，只要网络连接稳定性高，MTU越大则传输效率越高。但是，如果接收机器所在网络或传输路径上路由器的MTU小的话，数据帧将不得不再次被拆分，这样反而降低了效率。&lt;/p&gt;

&lt;p&gt;普遍使用的MTU以下可参考：&lt;/p&gt;

&lt;p&gt;FDDI协议：4352字节&lt;/p&gt;

&lt;p&gt;以太网（Ethernet）协议：1500字节&lt;/p&gt;

&lt;p&gt;PPPoE（ADSL）协议：1492字节&lt;/p&gt;

&lt;p&gt;X.25协议（Dial Up/Modem）：576字节&lt;/p&gt;

&lt;p&gt;Point-to-Point：4470字节&lt;/p&gt;

&lt;p&gt;ipv4协议规定ip层的最小重组缓冲区大小为576！，最小重组缓冲区大小 (minimum
reassembly buffer size) 是指 IPv4/IPv6
都必须保证支持的最小数据报大小，其值 IPv4 为 576
字节。比如，对于IPv4来说，目的主机小于576字节的数据报都可以被接受。&lt;/p&gt;

&lt;p&gt;通常MTU 576
会与UDP一起讨论。UDP是一种不可靠的传输协议，所以当使用时尽量符合MTU小于576，避免一些链路上的问题，避免被丢包。&lt;/p&gt;

&lt;p&gt;**&lt;/p&gt;

&lt;p&gt;X.25
是一个使用电话或者ISDN设备作为网络硬件设备来架构广域网的ITU-T网络协议。它的实体层，数据链路层和网络层（1－3层）都是按照OSI模型来架构的。在国际上X.25的提供者通常称X.25为分封交换网（Packet
switched
network），尤其是那些国营的电话公司。它们的复合网络从80年代到90年代覆盖全球，在现在仍然应用于交易系统中。&lt;br /&gt;
&lt;a href=&quot;https://zh.wikipedia.org/wiki/X.25&quot;&gt;https://zh.wikipedia.org/wiki/X.25&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;write写成功了&quot;&gt;Write写成功了？&lt;/h2&gt;

&lt;p&gt;Socket write阻塞写返回之后，是指什么？成功传输到对方网络？&lt;/p&gt;

&lt;p&gt;对于发送数据来说，应用程序将数据拷贝到各自TCP发送缓冲区内（也就是发送滑动窗口），然后系统的所有TCP套接字上发送缓冲区（也就是发送滑动窗口）内的数据都将数据拷贝到内核发送缓冲区内，然后内核触发将内核缓冲区的数据经过网卡发送出去。&lt;/p&gt;

&lt;p&gt;TCP的发送/接受缓冲区（也就是发送/接受滑动窗口），是针对某一个具体的TCP连接来说的，每一个TCP连接都会有相应的滑动窗口，但是内核的发送/接受缓冲区是针对整个系统的，里面存放着整个系统的所有TCP连接的接收/发送的数据。&lt;/p&gt;

&lt;h2 id=&quot;udp-有滑动窗口吗&quot;&gt;UDP 有滑动窗口吗？&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image28.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.3645833333333335in”}&lt;/p&gt;

&lt;p&gt;TCP有一个发送缓冲区，每次TCP发送数据的时候，都会先将数据发送到发送缓冲区里面，之后，发送缓冲区中的数据可能会被封装成一个或多个TCP报文段发出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/KCP学习/image29.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.053472222222222in”}&lt;/p&gt;

&lt;p&gt;它的发送端每次执行一次写操作，UDP就将其封装成一个数据报发送出去，接收端必须及时对每个UDP数据报进行写操作，否则将会丢包。此外，如果客户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将会被截断。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ljh0302/article/details/49738191&quot;&gt;https://blog.csdn.net/ljh0302/article/details/49738191&lt;/a&gt;
&lt;a href=&quot;http://www.pianshen.com/article/1818281353/&quot;&gt;http://www.pianshen.com/article/1818281353/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;资源&quot;&gt;资源&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://kaiyuan.me/2017/07/29/KCP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&quot;&gt;http://kaiyuan.me/2017/07/29/KCP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&lt;/a&gt;
&lt;a href=&quot;https://github.com/skywind3000/kcp&quot;&gt;https://github.com/skywind3000/kcp&lt;/a&gt;
&lt;a href=&quot;https://www.cnblogs.com/wetest/p/9190786.html&quot;&gt;https://www.cnblogs.com/wetest/p/9190786.html&lt;/a&gt;
&lt;a href=&quot;https://github.com/xtaci/kcptun&quot;&gt;https://github.com/xtaci/kcptun&lt;/a&gt;
&lt;a href=&quot;https://www.cnblogs.com/purpleraintear/p/6403053.html&quot;&gt;https://www.cnblogs.com/purpleraintear/p/6403053.html&lt;/a&gt;
&lt;a href=&quot;https://blog.csdn.net/yusiguyuan/article/details/28625129&quot;&gt;https://blog.csdn.net/yusiguyuan/article/details/28625129&lt;/a&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53849089&quot;&gt;https://zhuanlan.zhihu.com/p/53849089&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/kcp%E5%AD%A6%E4%B9%A0&quot;&gt;KCP学习&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on September 09, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[polardb源码学习]]></title>
  <link>http://yangqiju.github.io/polardb%E5%AD%A6%E4%B9%A0</link>
  <id>http://yangqiju.github.io/polardb学习</id>
  <published>2019-08-21T00:00:00-04:00</published>
  <updated>2019-08-21T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://neoremind.com/2018/12/2018-polar-race-java-no-1/&quot;&gt;http://neoremind.com/2018/12/2018-polar-race-java-no-1/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参加天池大赛-阿里云第一届PolarDB数据库性能大赛，比赛以NVME Optane
SSD为背景，在此之上开发单机存储引擎比拼性能，支持C++和Java语言。完赛成绩是Java语言排名第一，总排名20（共1653人参赛，队伍名称：neoremind），与C++第一差距在2.1%（&amp;lt;9s）。&lt;/p&gt;

&lt;h1 id=&quot;赛题介绍&quot;&gt;赛题介绍&lt;/h1&gt;

&lt;p&gt;使用Intel Optane
SSD作为存储，cgroup限制内存3G（针对Java）。实现一个简化、高效的kv存储引擎，支持Write、Read、Range接口。&lt;/p&gt;

&lt;p&gt;评测程序分为2个阶段：&lt;/p&gt;

&lt;p&gt;1. 正确性评测&lt;/p&gt;

&lt;p&gt;此阶段评测程序会并发写入特定数据（key 8B、value 4KB）同时进行任意次kill
-9来模拟进程意外退出（参赛引擎需要保证进程意外退出时数据持久化不丢失），接着重新打开DB，调用Read、Range接口来进行正确性校验。&lt;/p&gt;

&lt;p&gt;2. 性能评测&lt;/p&gt;

&lt;p&gt;2.1
随机写入：64个线程并发随机写入，每个线程使用Write各写100万次随机数据（key
8B、value 4KB）。&lt;/p&gt;

&lt;p&gt;2.2
随机读取：64个线程并发随机读取，每个线程各使用Read读取100万次随机数据。&lt;/p&gt;

&lt;p&gt;2.3
顺序读取：64个线程并发顺序读取，每个线程使用Range全局顺序迭代DB数据2次。&lt;/p&gt;

&lt;p&gt;补充下：&lt;/p&gt;

&lt;p&gt;1）每个阶段结束后都会清page cache，清理时间也算在总时长里。&lt;/p&gt;

&lt;p&gt;2）Read、Range会验证key、value是否match，Range验证是否保序。&lt;/p&gt;

&lt;h1 id=&quot;知识点&quot;&gt;知识点&lt;/h1&gt;

&lt;h2 id=&quot;lsm-tree&quot;&gt;LSM-tree&lt;/h2&gt;

&lt;p&gt;Log Structured Merge Tree，下面简称 LSM。&lt;/p&gt;

&lt;p&gt;2006年，Google 发表了 BigTable 的论文。这篇论文提到 BigTable
单机上所使用的数据结构就是 LSM。目前，LSM
被很多存储产品作为存储结构，比如 Apache HBase, Apache Cassandra, MongoDB
的 Wired Tiger 存储引擎, LevelDB 存储引擎, RocksDB 存储引擎等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image1.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.5236111111111112in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image2.png&quot; alt=&quot;https://img-blog.csdn.net/20180320194747640?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3NkdWxpYmg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; /&gt;{width=”5.5in”
height=”4.323611111111111in”}&lt;/p&gt;

&lt;p&gt;简单地说，LSM 的设计目标是提供比传统的 B+
树更好的写性能。LSM通过将磁盘的随机写转化为顺序写来提高写性能，而付出的代价就是牺牲部分读性能、写放大（B+树同样有写放大的问题）。LSM
相比 B+ 树能提高写性能的本质原因是无论磁盘还是
SSD，其随机读写都要慢于顺序读写。&lt;/p&gt;

&lt;p&gt;随机读写比顺序读写慢？&lt;/p&gt;

&lt;h2 id=&quot;随机读写比顺序读写慢&quot;&gt;随机读写比顺序读写慢&lt;/h2&gt;

&lt;p&gt;在HDD（Hard Disk
Drive，硬件驱动器）的时代，要考虑磁头。Hdd的单位是扇区，通常是512byte，ssd是以页为单位，通常是4k。&lt;/p&gt;

&lt;p&gt;SSD不是用的磁头了，那为什么相比之下随机读写还是慢呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image3.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.1631944444444446in”}&lt;/p&gt;

&lt;p&gt;SSD以Page为单位做读写，以Block为单位做垃圾回收，Page一般有16KB大小，Block一般有几MB大小（例如256
KB and 4 MB），SSD写数据的逻辑是：&lt;/p&gt;

&lt;p&gt;1）将该Block块数据所在的Page读出&lt;/p&gt;

&lt;p&gt;2）修改该Page中该Block块数据的内容&lt;/p&gt;

&lt;p&gt;3）找出一个新的空闲Block将2)中的Page写入，并将1)中提到的Page所在的Block中的Page标志为脏。&lt;/p&gt;

&lt;p&gt;由于随机数据通常由多个应用程序写入，因此页面顺序写入闪存的各个块中。随机写会导致随机的页面失效，顺序写会导致连续的大块页面失效。页面随机失效时，要回收block，需要将block中的有效页面读出并写到新位置，然后erase
block，而连续的大块页面失效时，由于要erase的block中一般已没有有效页面，拷贝写到新位置的过程就没有了。&lt;/p&gt;

&lt;h2 id=&quot;wisckey&quot;&gt;WiscKey&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image4.jpeg&quot; alt=&quot;https://ask.qcloudimg.com/http-save/developer-news/032ygdzn3u.jpeg?imageView2/2/w/1620&quot; /&gt;{width=”5.217361111111111in”
height=”4.282638888888889in”}&lt;/p&gt;

&lt;p&gt;LSM-tree的问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;读放大。LSM-Tree
的读操作需要从新到旧（从上到下）一层一层查找，直到找到想要的数据。这个过程可能需要不止一次
I/O。特别是 range query 的情况，影响很明显。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;空间放大。因为所有的写入都是顺序写（append-only）的，不是 in-place
update ，所以过期数据不会马上被清理掉。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写放大。compaction 时为了保证数据有序进行大量数据（key 和
value）重写。层层合并。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际上，需要保持有序的只有 key，如果将 key 和 value 分开存储，compaction
重写数据的时候，就只需要重写 key（和 value 的位置，简称 vpos）。这在 key
size （简称 ksize）远小于 value size （简称
vsize）的场景（现实场景基本都是这样）降低写放大的效果十分明显。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;LSM-Tree Compaction 不需要重写 value，大大减小写放大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LSM-Tree 不存储 value，体积更小，一个 block 能存更多的
key，有利于减少读 LSM-Tree 的 I/O。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LSM-Tree 的体积小，cache 效果应该会更好。LSM-Tree
的上面几层基本都可以 cache 在内存中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参赛者的设计结构&quot;&gt;参赛者的设计结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image5.png&quot; alt=&quot;http://neoremind.com/wp-content/uploads/data_storage_format.png&quot; /&gt;{width=”5.768055555555556in”
height=”4.663152887139107in”}&lt;/p&gt;

&lt;p&gt;wal（Write Ahead
Log）存key和value在vlog中的offset，vlog是顺序写入的value，wal和vlog都是append-only的定长写入，所以wal只用存vlog的sequence，vlog
seq用4byte
Int表示存储，大尾端/小尾端程序自己定，然后乘以4096就是在vlog文件中的偏移量。wal和vlog都是顺序IO写入，不存在LSM-tree模型的写放大问题。&lt;/p&gt;

&lt;p&gt;由于kv分离，写入必须lock，有锁就会限制性能，由于是随机写入，所以按照分治的思路，减少冲突即可，数据要分片sharding。我的策略是按照key的字典序分成1024个分片。把key的第一个字节8byte+第二个字节的前2个bit取出，转成int，经过分区函数就可以路由到正确的分片上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image6.png&quot; alt=&quot;http://neoremind.com/wp-content/uploads/shareddb.png&quot; /&gt;{width=”5.768055555555556in”
height=”1.9387084426946632in”}&lt;/p&gt;

&lt;h2 id=&quot;高速写入的实现&quot;&gt;高速写入的实现&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image7.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”4.20625in”}&lt;/p&gt;

&lt;p&gt;Mmap是程序写入到page
cache就算写成功了，默认系统调用刷盘，所以是写内存，速度很快。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image8.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.497916666666667in”}&lt;/p&gt;

&lt;p&gt;这里面vlog是用mmap写入的，而wal使用dio+mmap实现的。&lt;/p&gt;

&lt;p&gt;mmap写入快，所以vlog使用mmap进行数据操作，这个好理解。&lt;/p&gt;

&lt;p&gt;但是wal为什么是dio+mmap？&lt;/p&gt;

&lt;p&gt;先说一下为什么要DIO？&lt;/p&gt;

&lt;h2 id=&quot;高速读取&quot;&gt;高速读取&lt;/h2&gt;

&lt;p&gt;顺序读为什么会比随机读要快？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image9.gif&quot; alt=&quot;PageCache&quot; /&gt;{width=”5.768055555555556in”
height=”1.7203488626421697in”}&lt;/p&gt;

&lt;p&gt;以顺序读为例，当用户发起一个 fileChannel.read(4kb)
之后，实际发生了两件事&lt;/p&gt;

&lt;p&gt;操作系统从磁盘加载了 16kb 进入 PageCache，这被称为预读&lt;/p&gt;

&lt;p&gt;操作通从 PageCache 拷贝 4kb 进入用户内存&lt;/p&gt;

&lt;p&gt;最终我们在用户内存访问到了
4kb，为什么顺序读快？很容量想到，当用户继续访问接下来的[4kb,16kb]的磁盘内容时，便是直接从
PageCache 去访问了。试想一下，当需要访问 16kb
的磁盘内容时，是发生4次磁盘 IO 快，还是发生1次磁盘 IO+4 次内存 IO
快呢？答案是显而易见的，这一切都是 PageCache 带来的优化。&lt;/p&gt;

&lt;p&gt;那如果是随机读怎么办呢？&lt;/p&gt;

&lt;p&gt;当使用 fileChannel.read() 这类会触发 PageCache 预读的 IO
方式时，我们其实并不希望操作系统帮我们干太多事，除非真的踩了狗屎运，随机读都能命中
PageCache，但几率可想而知。&lt;/p&gt;

&lt;p&gt;所以这种情况下，我们是希望绕过page cache的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image10.png&quot; alt=&quot;linux io&quot; /&gt;{width=”5.376388888888889in”
height=”4.5in”}&lt;/p&gt;

&lt;h2 id=&quot;为什么要diommap&quot;&gt;为什么要DIO+MMAP&lt;/h2&gt;

&lt;p&gt;评测程序分为2个阶段中，第一阶段正确性评测中，提到进行任意次kill
-9来模拟进程意外退出（参赛引擎需要保证进程意外退出时数据持久化不丢失）。&lt;/p&gt;

&lt;p&gt;Kill -9
只是杀了进程，但是mmap的内容是还在的，所以当写了vlog，所以value还在page
cache中，可以恢复，但是如果是wal只是dio操作，那数据就丢失了key
offsize了。&lt;/p&gt;

&lt;p&gt;所以在wal写的时候，是先写了个tmp文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image11.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.5680555555555555in”}&lt;/p&gt;

&lt;p&gt;而在启动的时候，进行数据的恢复。也就是将page cache 的内容写到文件中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image12.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.3854166666666667in”}&lt;/p&gt;

&lt;h2 id=&quot;随机读的实现&quot;&gt;随机读的实现&lt;/h2&gt;

&lt;p&gt;读取测试方法：&lt;/p&gt;

&lt;p&gt;随机读取：64个线程并发随机读取，每个线程各使用Read读取100万次随机数据。&lt;/p&gt;

&lt;p&gt;首先要创建索引，通过key查找value。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image13.png&quot; alt=&quot;http://neoremind.com/wp-content/uploads/data_storage_format.png&quot; /&gt;{width=”3.3176476377952757in”
height=”2.682133639545057in”}&lt;/p&gt;

&lt;p&gt;总的wal文件大小=（8byte key+4byte vlog
seq）*64并发*100w=768MB。完全可以放内存中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image14.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.0277777777777777in”}&lt;/p&gt;

&lt;p&gt;在读之前先进行初始化：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;多线程（10个线程）同时通过mmap加载1024个wal文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;申请同样大小的堆外内存，通过堆外内存进行排序，构建出一个index，用于二分查找&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用DIO的方式初始化vlog&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;初始化完成后，就可以通过二分查找找到key，在通过偏移量找到value&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image15.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.5229166666666667in”}&lt;/p&gt;

&lt;h2 id=&quot;scan扫描&quot;&gt;Scan扫描&lt;/h2&gt;

&lt;p&gt;测试方法：&lt;/p&gt;

&lt;p&gt;顺序读取：64个线程并发顺序读取，每个线程使用Range全局顺序迭代DB数据2次。&lt;/p&gt;

&lt;p&gt;题目中会64并发Range2次，相当于128次全数据扫描，肯定是有问题的。&lt;/p&gt;

&lt;p&gt;作者先描述了搭车模型，再使用了滑动窗口。但感觉事后先描述滑动窗口，再描述搭车模型就更加明白。&lt;/p&gt;

&lt;p&gt;基本思想就是顺序遍历1024个分片，每个分片放到内存中访问，无缝的衔接每个分片，走完即可。每个分片的访问都分为3个步骤。&lt;/p&gt;

&lt;p&gt;1）prefetch预读：wal排序好建立索引，vlog load到内存。&lt;/p&gt;

&lt;p&gt;2）Range读取：iterate排序好的wal，针对每个key和vlog
seq找value，就变成了内存访问，也就是”并发内存查询”的精髓。&lt;/p&gt;

&lt;p&gt;3）评测程序visit：评测程序需要验证有序、值正确等，也有一定消耗。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image16.png&quot; alt=&quot;http://neoremind.com/wp-content/uploads/slidingwindow.png&quot; /&gt;{width=”5.768055555555556in”
height=”3.009304461942257in”}&lt;/p&gt;

&lt;p&gt;为了无缝衔接1024个分片做上述3个步骤，使用滑动窗口，如下图，滑动窗口分为5类：&lt;/p&gt;

&lt;p&gt;– 已访问结束的&lt;/p&gt;

&lt;p&gt;– 正在Range读取的和visit的&lt;/p&gt;

&lt;p&gt;– prefetch预读结束，准备被读取的&lt;/p&gt;

&lt;p&gt;– prefetching中&lt;/p&gt;

&lt;p&gt;– 未访问的&lt;/p&gt;

&lt;p&gt;滑动窗口最大容量是3个分片，占用内存最大=vlog（256MB*3）+wal索引（750KB*3）=770MB。&lt;/p&gt;

&lt;p&gt;这样只要将64个并发线程控制在这滑动窗口中，就相当于全是内存操作了。所以搭车模型就可以运用如下了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image17.png&quot; alt=&quot;http://neoremind.com/wp-content/uploads/acc_runner.png&quot; /&gt;{width=”5.768055555555556in”
height=”2.1248239282589676in”}&lt;/p&gt;

&lt;h1 id=&quot;扩展点&quot;&gt;扩展点&lt;/h1&gt;

&lt;h2 id=&quot;kernel-bypass&quot;&gt;Kernel bypass&lt;/h2&gt;

&lt;p&gt;kernel
bypass(绕过内核)是解决系统网络栈和存储栈性能瓶颈的另外一种方式，与传统的中断机制不同，kernel
bypass的核心思想是：内核只用来处理控制流，所有数据流相关操作都在用户态进行处理，从而规避内核的包拷贝、线程调度、系统调用、中断等性能瓶颈，并辅以各种性能调优手段(如：CPU
pin、无锁队列)，从而达到更高的性能。&lt;/p&gt;

&lt;h3 id=&quot;dpdk&quot;&gt;DPDK&lt;/h3&gt;

&lt;p&gt;DPDK(Data Plane Development
Kit)是由Intel发起，主要基于Linux系统运行，用于快速数据包处理的函数库与驱动集合，可以极大提高数据处理性能和吞吐量，提高数据平面应用程序的工作效率。DPDK使用了轮询(polling)而不是中断来处理数据包。在收到数据包时，经DPDK重载的网卡驱动不会通过中断通知CPU，而是直接将数据包存入内存，交付应用层软件通过DPDK提供的接口来直接处理，这样节省了大量的CPU中断时间和内存拷贝时间。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/qcloud1001/p/9585724.html&quot;&gt;https://www.cnblogs.com/qcloud1001/p/9585724.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;spdk&quot;&gt;SPDK&lt;/h3&gt;

&lt;p&gt;众所周知，在Linux起源之初，文件系统io栈针对机械盘进行了众多优化，包括page、cache等多种优化方式。内核采用中断的方式进行DMA将数据从内核态拷贝回用户态，再交由用户程序处理，这是机械硬盘时代的io处理方式。而随着nvme-ssd的出现，如果再采用此种方式就会导致大量的硬盘空闲，浪费硬盘性能。为了帮助上游的应用厂商以及存储厂商更好的发挥ssd磁盘的性能，intel开发了一套基于nvme-ssd的开发套件，SPDK。SPDK的目标是通过使用Intel的网络，处理，存储技术，将固态存储介质出色的功效发挥到极致。&lt;/p&gt;

&lt;p&gt;首先，将设备驱动代码运行在用户态，避免内核上下文切换和中断将会节省大量的处理开销，允许更多的时钟周期被用来做实际的数据存储。其次，采用轮询模式改变了传统I/O的基本模型。在传统的I/O模型中，应用程序提交读写请求后进入睡眠状态，一旦I/O完成，中断就会将其唤醒。轮询的工作方式则不同，应用程序提交读写请求后继续执行其他工作，以一定的时间间隔回头检查I/O是否已经完成。这种方式避免了中断带来的延迟和开销，并使得应用程序提高了I/O效率。&lt;/p&gt;

&lt;p&gt;SPDK用于加速使用NVMe
SSD作为后端存储的应用软件加速库，该软件库的核心是用户态、异步、轮询方式的NVMe驱动。与内核态的NVMe驱动相比，它可以大幅度降低延迟，同时提升单CPU核的IOPS。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image18.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.6583333333333334in”}&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zlarm/article/details/79140299&quot;&gt;https://blog.csdn.net/zlarm/article/details/79140299&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;rdma&quot;&gt;RDMA&lt;/h3&gt;

&lt;p&gt;RDMA(Remote Direct Memory
Access)全称远程直接数据存取，就是为了解决网络传输中服务器端数据处理的延迟而产生的。RDMA通过网络把资料直接传入计算机的存储区，将数据从一个系统快速移动到远程系统存储器中，而不对操作系统造成任何影响，这样就不需要用到多少计算机的处理功能。它消除了外部存储器复制和上下文切换的开销，因而能解放内存带宽和CPU周期用于改进应用系统性能。下图直观的展示了传统模式和RDMA模式下的差异。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/polardb源码学习/image19.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.0756944444444443in”}&lt;/p&gt;

&lt;h2 id=&quot;细节是魔鬼&quot;&gt;细节是魔鬼&lt;/h2&gt;

&lt;p&gt;这里有一个小点可以避免频繁的Young GC，64个线程通过ThreadLocal读4k
value，避免频繁的分配内存。&lt;/p&gt;

&lt;h2 id=&quot;dio库&quot;&gt;DIO库&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/smacke/jaydio&quot;&gt;https://github.com/smacke/jaydio&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;据说java 10
会添加上（&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8164900&quot;&gt;https://bugs.openjdk.java.net/browse/JDK-8164900&lt;/a&gt;）&lt;/p&gt;

&lt;h2 id=&quot;重点&quot;&gt;重点&lt;/h2&gt;

&lt;p&gt;作为Java选手要克服上面的困难，必然要使出一些大杀器，下面依次总结下。&lt;/p&gt;

&lt;p&gt;1、mmap&lt;/p&gt;

&lt;p&gt;写入阶段写wal，保证crash
consistency。JDK提供原生的API，但是释放相对麻烦。&lt;/p&gt;

&lt;p&gt;2、direct io&lt;/p&gt;

&lt;p&gt;JNA封装，或者使用jaydio，拼接小IO为大块IO写入。FileChannel在本次比赛都没有使用，原因就是内部有个position
lock并且走buffer
io，在这个场景不适合，但是大多数Java涉及IO的场景，NIO的FileChannel都是首选。&lt;/p&gt;

&lt;p&gt;3、堆外内存&lt;/p&gt;

&lt;p&gt;offheap可以用DirectBuffer，或者Unsafe的malloc、free。&lt;/p&gt;

&lt;p&gt;4、gc控制&lt;/p&gt;

&lt;p&gt;比赛用参数如下，&lt;/p&gt;

&lt;p&gt;-server -XX:-UseBiasedLocking -Xms2000m -Xmx2000m -XX:NewSize=1400m
-XX:MaxMetaspaceSize=32m -XX:MaxDirectMemorySize=1G -XX:+UseG1GC&lt;/p&gt;

&lt;p&gt;write和read阶段young
gc都很少，主要为range阶段使用，由于使用了多级流水线架构，所以吃内存比较严重，young
gc相对频繁，但没有full gc所以可接受。&lt;/p&gt;

&lt;p&gt;5、池化技术&lt;/p&gt;

&lt;p&gt;DirectMemory先分配好，然后池化，使用时候反复擦写，可以复用资源。read阶段用ThreadLocal复用value避免频繁young
gc。&lt;/p&gt;

&lt;p&gt;6、锁控制&lt;/p&gt;

&lt;p&gt;kv分离的写入，必然加锁。read阶段的direct io
load同一块内存，然后返回给user
space的过程也需要加锁，尽量小的控制锁粒度，分散锁的冲突，就像ConcurrentHashMap思想一样，就可以把锁的消耗降到最低。&lt;/p&gt;

&lt;p&gt;7、并发利器&lt;/p&gt;

&lt;p&gt;java.util.concurrent要用好，Range阶段的搭车模型，并行load
vlog，滑动窗口都用到了线程池、lock、condition、mutex等。同时一些无锁并发的类库例如ConcurrentLinkedQueue，jctools的MpmcArrayQueue，disruptor的无锁队列也可以尝试，比赛中都有实验，其实无锁就足够了，瓶颈在IO，这些可以忽略。&lt;/p&gt;

&lt;p&gt;8、减少上下文切换&lt;/p&gt;

&lt;p&gt;由于比赛使用了Alijdk，而Alijdk有个Wisp
API，可以做Java协程，在一些资源释放无需等待的场景可以使用，亲试后通过vmstat
-w 1命令看cs列确实少了一些，但是对提高成绩没有很大帮忙。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/polardb%E5%AD%A6%E4%B9%A0&quot;&gt;polardb源码学习&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on August 21, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[go shadowsocks源码分析]]></title>
  <link>http://yangqiju.github.io/go-shadowsocks</link>
  <id>http://yangqiju.github.io/go-shadowsocks</id>
  <published>2019-08-17T00:00:00-04:00</published>
  <updated>2019-08-17T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;

&lt;p&gt;Shadowsocks用作最熟悉的翻墙软件，是程序员面向google开发的利器。&lt;/p&gt;

&lt;p&gt;本章通过学习go-shadowsocks源码，了解一下内部实现原理。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/shadowsocks/go-shadowsocks2&quot;&gt;https://github.com/shadowsocks/go-shadowsocks2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ss：ss作者是clowwindy，大约两年前，他自己为了翻墙写了shadowsocks，简称ss或者叫影梭。&lt;/p&gt;

&lt;p&gt;ssr：在ss作者被喝茶之后，github上出现了一个叫breakwa11(破娃)的帐号，声称ss容易被防火墙检测到，所以在混淆和协议方面做了改进，更加不容易被检测到，而且兼容ss，改进后的项目叫shadowsocks-R，简称ssr，&lt;/p&gt;

&lt;h1 id=&quot;屏蔽原理&quot;&gt;屏蔽原理&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image1.jpeg&quot; alt=&quot;image&quot; /&gt;{width=”5.768055555555556in”
height=”3.8453707349081365in”}&lt;/p&gt;

&lt;p&gt;当用户需要获取信息，都经过了
GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW
的过滤规则的时候，就会收到 Connection Reset
这样的响应内容，而无法接收到正常的内容。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sulangsss.github.io/2018/12/18/Network/SS%20SSR%20%E5%8E%9F%E7%90%86/&quot;&gt;https://sulangsss.github.io/2018/12/18/Network/SS%20SSR%20%E5%8E%9F%E7%90%86/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;dns污染劫持&quot;&gt;DNS污染/劫持&lt;/h2&gt;

&lt;p&gt;在进行域名访问时，首先会将域名通过dns解析为对应的真实IP，然后通过IP进行HTTP访问，所谓DNS攻击手段，即通过某种手段使得客户机发起DNS查询但得到的却是错误的IP，导致客户机无法正常访问。
防火长城会在骨干网出口的53端口进行IDS入侵检测，检测到黑名单域名等，会伪装成域名服务器向客户机发送虚假的回应，由于DNS查询请求一般是基于UDP无连接传输层协议，该协议特征是无状态连接、不可靠传输，DNS查询会接收最先到达的请求，抛弃之后到达的请求，因此导致客户机被欺骗，请求被重定位到虚假IP。&lt;/p&gt;

&lt;h2 id=&quot;ip封锁&quot;&gt;IP封锁&lt;/h2&gt;

&lt;p&gt;在客户机发送请求到服务器的过程中会经过一系列路由的转发，在路由器转发的过程中会根据路由表中存储的表项来决定下一跳的路由器或主机，选择的下一跳地址会根据路由协议来决定。
早期使用的是ACL（访问控制列表）来进行IP黑名单限制，现在更高效的路由扩散技术来进行对特定的IP进行封锁。早期路由器都是采用静态路由协议，每一条路由需要进行人工来配置路由表项，或者配置一些策略，在决定路由转发，这时可以通过检测，对相应要封锁的IP配置一条错误的路由，将之牵引到一个不做任何操作的服务器（黑洞服务器），此服务器所要做的就是丢包，这样便无声息封锁掉了。动态路由协议的出现可以更高效的进行屏蔽，动态路由协议可以让路由器通过交换路由表信息来动态更新路由表，并通过寻址算法来决定最优化的路径。因此可以通过动态路由协议的路由重分发功能将错误的信息散播到整个网络，从而达到屏蔽目的。&lt;/p&gt;

&lt;h2 id=&quot;ip端口黑名单&quot;&gt;IP/端口黑名单&lt;/h2&gt;

&lt;p&gt;该手段可以结合上边提到的IP封锁技术，将封锁精确到具体的端口，使该IP的具体端口接收不到请求，从而达到更细粒度的封锁。&lt;/p&gt;

&lt;p&gt;经常被封锁的端口如下：&lt;/p&gt;

&lt;p&gt;SSH的TCP协议22端口&lt;/p&gt;

&lt;p&gt;HTTP的80端口&lt;/p&gt;

&lt;p&gt;PPTP类型VPN使用的TCP协议1723端口&lt;/p&gt;

&lt;p&gt;L2TP类型VPN使用的UDP协议1701端口&lt;/p&gt;

&lt;p&gt;IPSec类型VPN使用的UDP协议500端口和4500端口&lt;/p&gt;

&lt;p&gt;OpenVPN默认使用的TCP协议和UDP协议的1194端口&lt;/p&gt;

&lt;p&gt;TLS/SSL/HTTPS的TCP协议443端口&lt;/p&gt;

&lt;p&gt;Squid Cache的TCP协议3128端口&lt;/p&gt;

&lt;h2 id=&quot;无状态tcp连接重置&quot;&gt;无状态TCP连接重置&lt;/h2&gt;

&lt;p&gt;TCP连接会有三次握手，此种攻击方式利用了该特点来进行攻击，gfw会对特定IP的所有数据包进行监控，会对特定黑名单动作进行监控（如TLS加密连接），当进行TCP连接时，会在TCP连接的第二部SYNC-ACK阶段，伪装成客户端和服务器同时向真实的客户端和服务器发送RESET重置，以很低的成本来达到切断双方连接的目的。与丢弃客户机的包相比，在丢包后客户机会不断的发起重试，这样会加重黑洞服务器的负担，利用TCP连接重置来断开连接，客户机也不必发送ACK来确认，这样成本就要低得多。&lt;/p&gt;

&lt;h2 id=&quot;tcp协议关键字阻断&quot;&gt;TCP协议关键字阻断&lt;/h2&gt;

&lt;p&gt;该手段在无状态TCP连接重置手段之上，加入了关键字过滤功能，当协议的头部包含特定的关键字便对其连接进行重置，比如HTTP协议、ED2K协议等等。&lt;/p&gt;

&lt;h2 id=&quot;深度包检测&quot;&gt;深度包检测&lt;/h2&gt;

&lt;p&gt;深度数据包检测（Deep packet
inspection,DPI）是一种于应用层对网络上传递的数据进行侦测与处理的技术，被广泛用于入侵检测、流量分析及数据挖掘。就字面意思考虑，所谓”深度”是相对于普通的报文检测而言的——DPI可对报文内容和协议特征进行检测。基于必要的硬件设施、适宜的检测模型及相应的模式匹配算法，gfw能够精确且快速地从实时网络环境中判别出有悖于预期标准的可疑流量，并对此及时作出审查者所期望的应对措施。&lt;/p&gt;

&lt;h1 id=&quot;原理&quot;&gt;原理&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image2.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”2.691666666666667in”}&lt;/p&gt;

&lt;p&gt;Shadowsocks 由两部分组成，运行在本地的 ss-local
和运行在防火墙之外服务器上的 ss-server。&lt;/p&gt;

&lt;p&gt;ss-local
的职责是在本机启动和监听着一个服务，本地软件的网络请求都先发送到
ss-local，ss-local
收到来自本地软件的网络请求后，把要传输的原数据根据用户配置的加密方法和密码进行加密，转换为socks5协议，再转发到墙外的服务器去。&lt;/p&gt;

&lt;p&gt;ss-server 的职责是在墙外服务器启动和监听一个服务，该服务监听来自本机的
ss-local 的请求。在收到来自 ss-local
转发过来的数据时，会先根据用户配置的加密方法和密码对数据进行对称解密，以获得加密后的数据的原内容。同时还会解
SOCKS5 协议，读出本次请求真正的目标服务地址(例如 Google
服务器地址)，再把解密后得到的原数据转发到真正的目标服务。再由ss-server代理进行连接将请求的数据返回给ss-local。&lt;/p&gt;

&lt;p&gt;socks 协议&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1928.txt&quot;&gt;https://www.ietf.org/rfc/rfc1928.txt&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;qa&quot;&gt;Q&amp;amp;A&lt;/h1&gt;

&lt;h2 id=&quot;ssr如何让帮助浏览器代理的&quot;&gt;ssr如何让帮助浏览器代理的&lt;/h2&gt;

&lt;p&gt;chrome的switchyOmega插件可在设置的时候，通过指定代理协议和端口，例如ss-local代理端口为1080协议为socks5协议，即可如下设置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image3.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”2.25625in”}&lt;/p&gt;

&lt;p&gt;以ShadowSocks
macos客户端为例，当打开”小飞机”之后，在网络代理里会添加并设置代理参数，pac（proxy
auto-config）文件，它是一个自动代理配置脚本，包含了很多使用 JavaScript
编写的规则，它能够决定网络流量走默认通道还是代理服务器通道，控制的流量类型包括：HTTP、HTTPS
和 FTP。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image4.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”4.728472222222222in”}&lt;/p&gt;

&lt;p&gt;在pac文件中，标识了代理的端口为macos
安装的shadowsocks的客户端代理的端口1086。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image5.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”3.2979166666666666in”}&lt;/p&gt;

&lt;h2 id=&quot;ssr中pac写的也是1086那1087什么时候使用的&quot;&gt;ssr中pac写的也是1086，那1087什么时候使用的&lt;/h2&gt;

&lt;p&gt;查看Shadowsocks的进程可以看到有ss-local 和
privoxy两个进程，ss-local是做socks5代理的，监听1086端口，而privoxy监听了1087端口，用来将http请求转为socks5，并转发给1086端口的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image6.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”0.5270833333333333in”}&lt;/p&gt;

&lt;p&gt;可通过如下指令测试：&lt;/p&gt;

&lt;p&gt;curl --socks5 127.0.0.1:1086 http://google.com&lt;/p&gt;

&lt;p&gt;curl --proxy 127.0.0.1:1087 http://google.com&lt;/p&gt;

&lt;p&gt;它可以根据配置，进行目标地址选择性代理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image7.png&quot; alt=&quot;&quot; /&gt;{width=”2.618601268591426in” height=”2.661111111111111in”}&lt;/p&gt;

&lt;p&gt;原理如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image8.png&quot; alt=&quot;image&quot; /&gt;{width=”5.768055555555556in” height=”2.306344050743657in”}&lt;/p&gt;

&lt;h2 id=&quot;socks和vpn的区别&quot;&gt;Socks和VPN的区别&lt;/h2&gt;

&lt;p&gt;VPN
比shadowsocks更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发。并且VPN的设置是全局的，即电脑一旦挂上VPN，所有的联网程序都将自动使用VPN。&lt;/p&gt;

&lt;p&gt;虽然可以通过route指定内网ip和外网ip的规则，但这只适合企业少量内网ip访问情况。&lt;/p&gt;

&lt;h2 id=&quot;为什么要混淆&quot;&gt;为什么要混淆？&lt;/h2&gt;

&lt;p&gt;本文中的go-shadowsocks
是直接使用socks协议进行代理的，而ssr（shadowsocksR
&lt;a href=&quot;https://github.com/shadowsocksr-backup/shadowsocksr.git&quot;&gt;https://github.com/shadowsocksr-backup/shadowsocksr.git&lt;/a&gt;
）是在这基础上添加了混淆功能。为什么要混淆？&lt;/p&gt;

&lt;p&gt;简单来说用的人多了GFW聪明了，需要对GFW进行欺骗一下，减少此类代理特征，让GFW无法识别出这是个”梯子”。&lt;/p&gt;

&lt;p&gt;对下面的进行理解，就明白为什么要混淆，并且也应该能知道如何能自己实现一个梯子了，即使实现方式不用socks5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image9.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.5902777777777777in”}&lt;/p&gt;

&lt;h2 id=&quot;混淆的实现&quot;&gt;混淆的实现&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image10.png&quot; alt=&quot;&quot; /&gt;{width=”2.9in” height=”2.1210345581802277in”}&lt;/p&gt;

&lt;p&gt;以我使用的http_simple为例子，它做的工作就是将请求的数据伪装为一个访问王长的http请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image11.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.8715277777777777in”}&lt;/p&gt;

&lt;p&gt;注：http的header和body之间通过回车和换行来区分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image12.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.248611111111111in”}&lt;/p&gt;

&lt;p&gt;通常ssr服务端开启的都是一个随机端口，然后让client进行连接，随着使用人的增加，特征慢慢也多了（机器学习），还是有可能被GFW识别出来，所以有人提出了新的伪装，就是自己开通一个有域名的网站，走80端口，让GFW以为是正常在访问网站。&lt;/p&gt;

&lt;p&gt;其他更多混淆参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mmcooo/article/details/80094194&quot;&gt;https://blog.csdn.net/mmcooo/article/details/80094194&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;https不就是加密的也会被识别&quot;&gt;https不就是加密的，也会被识别？&lt;/h2&gt;

&lt;p&gt;用https内容加密操作，直接代理不久可以了，为什么要用http+body加密？&lt;/p&gt;

&lt;p&gt;以下是ssr作者的回答：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image13.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.0034722222222223in”}&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/clowwindy/5947691&quot;&gt;https://gist.github.com/clowwindy/5947691&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;openwrt里直接安装后如何代理所有wlan的接入&quot;&gt;Openwrt里直接安装后，如何代理所有wlan的接入？&lt;/h2&gt;

&lt;p&gt;翻墙时，需要有个本地端口监听，通过插件或者”小飞机”将流量转发到该端口中才能完成代理，但是openwrt集成shadowsocksr-libev之后，就能代理所有无线网的请求了，怎么实现的？包含代理的固件为（&lt;a href=&quot;https://github.com/coolsnowwolf/&quot;&gt;https://github.com/coolsnowwolf/&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;与之前本地起一个ss-local端口，进行正向代理不同。在linux机器上，通过启动ss-redir和在iptables上定义网络包的转发策略，实现了用户无感知的透明代理，透明代理后，用户将不会在设置浏览器插件。&lt;/p&gt;

&lt;p&gt;实现为如下&lt;/p&gt;

&lt;p&gt;通过iptables，对局域网的流量进行过滤，其他流量都走监听端口，在此示例中，ss-redir监听端口为
12345,（该监听端口为ss-redir端口，而不是ss-local端口）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image14.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”4.095833333333333in”}&lt;/p&gt;

&lt;p&gt;该固件是在实现了 &lt;a href=&quot;https://github.com/shadowsocksrr/shadowsocksr-libev&quot;&gt;https://github.com/shadowsocksrr/shadowsocksr-libev&lt;/a&gt;
的基础上，增加了luci-app-ssr-plus（&lt;a href=&quot;https://github.com/coolsnowwolf/lede/tree/9eeb898ee39567d5eef5d7e87c3db062ce9c860b/package/lean/luci-app-ssr-plus&quot;&gt;https://github.com/coolsnowwolf/lede/tree/9eeb898ee39567d5eef5d7e87c3db062ce9c860b/package/lean/luci-app-ssr-plus&lt;/a&gt;
）插件。&lt;/p&gt;

&lt;p&gt;通过ipset定义管理了gfwlist的ip集合和名为china的国内ip的范围，通过iptables进行匹配选择是否走代理。比如下面描述，匹配了目标地址为gfwlist，目标地址不为china
的ip集合的就跳转到SS_SPEC_WAN_FW
chain中，在SS_SPEC_WAN_FW里定义了内网就return，其他的就走local_port
也就是上面提到的12345端口。更多参考文件（/usr/bin/ssr-rules）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image15.png&quot; alt=&quot;&quot; /&gt;{width=”4.597458442694663in”
height=”0.5694739720034996in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image16.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.1722222222222223in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image17.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.670138888888889in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/go_shadowsocks/image18.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.888888888888889in”}&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/zfl9/ss-tproxy&quot;&gt;https://github.com/zfl9/ss-tproxy&lt;/a&gt;
&lt;a href=&quot;https://www.zfl9.com/ss-redir.html&quot;&gt;https://www.zfl9.com/ss-redir.html&lt;/a&gt;
&lt;a href=&quot;https://vvl.me/2018/06/from-ss-redir-to-linux-nat/&quot;&gt;https://vvl.me/2018/06/from-ss-redir-to-linux-nat/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://sulangsss.github.io/2018/12/18/Network/SS%20SSR%20%E5%8E%9F%E7%90%86/&quot;&gt;https://sulangsss.github.io/2018/12/18/Network/SS%20SSR%20%E5%8E%9F%E7%90%86/&lt;/a&gt;
&lt;a href=&quot;https://sq.163yun.com/blog/article/185530682109534208&quot;&gt;https://sq.163yun.com/blog/article/185530682109534208&lt;/a&gt;
&lt;a href=&quot;https://segmentfault.com/a/1190000011485579&quot;&gt;https://segmentfault.com/a/1190000011485579&lt;/a&gt;
&lt;a href=&quot;https://gist.github.com/clowwindy/5947691&quot;&gt;https://gist.github.com/clowwindy/5947691&lt;/a&gt;
&lt;a href=&quot;http://waimian.me/?thread-95.htm&quot;&gt;http://waimian.me/?thread-95.htm&lt;/a&gt;
&lt;a href=&quot;http://ssr.bingly.cn/user/tutorial&quot;&gt;http://ssr.bingly.cn/user/tutorial&lt;/a&gt;
&lt;a href=&quot;https://choucuoqiong.blogspot.com/p/ssr.html&quot;&gt;https://choucuoqiong.blogspot.com/p/ssr.html&lt;/a&gt;
&lt;a href=&quot;https://github.com/hq450/fancyss_history_package&quot;&gt;https://github.com/hq450/fancyss_history_package&lt;/a&gt;
&lt;a href=&quot;https://github.com/coolsnowwolf/lede&quot;&gt;https://github.com/coolsnowwolf/lede&lt;/a&gt;
&lt;a href=&quot;http://ss.lt8.me/user/node&quot;&gt;http://ss.lt8.me/user/node&lt;/a&gt;
&lt;a href=&quot;http://nulastudio.org/Freedom/&quot;&gt;http://nulastudio.org/Freedom/&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/go-shadowsocks&quot;&gt;go shadowsocks源码分析&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on August 17, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[tcp_tw_recycle问题排查]]></title>
  <link>http://yangqiju.github.io/tcp_tw_recycle%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5</link>
  <id>http://yangqiju.github.io/tcp_tw_recycle网络排查</id>
  <published>2019-08-10T00:00:00-04:00</published>
  <updated>2019-08-10T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;问题描述&quot;&gt;问题描述&lt;/h1&gt;

&lt;p&gt;两台内网机器，通过NAT映射访问一台公网服务器，公网服务器同时开启了tcp_tw_recycle和tcp_timestamps。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/tcp_tw_recycle/image1.png&quot; alt=&quot;&quot; /&gt;{width=”4.327160979877515in”
height=”3.8306780402449694in”}&lt;/p&gt;

&lt;p&gt;将会导致Client1 和 Client2
请求Server服务器时，其中一台（例如Client2）服务器会出现间歇性的连接不上。&lt;/p&gt;

&lt;p&gt;通过在Server上抓包发现，Client1、Client2发送的请求均被Server收到，造成Client2连接不上的现象的原因是因为Server将Client2的SYN包收到后没有选择回复ACK，与Client2建立TCP，而是直接丢弃了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/tcp_tw_recycle/image2.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”1.55in”}&lt;/p&gt;

&lt;p&gt;Google一下”tcp_timestamps问题”或者”tcp_tw_recycle问题”，其实直接就能知道大概出了什么问题：&lt;/p&gt;

&lt;p&gt;由于client1、client2都开启tcp_timestamps，server开启了tcp_timestampls、tcp_tw_recycle，导致了服务端会指挥收同一个IP，时间戳（TSval）较之前更大、递增的连接，否则将会把TSval值小的包当作旧包直接丢弃。&lt;/p&gt;

&lt;p&gt;然而又因为TSval的值是每台机器根据系统启动而来计算的，所以必然Client1和Client2是不一样的。如果TSval大的先连接成功，TSval小的再连接就连接不上了。&lt;/p&gt;

&lt;p&gt;解决方案：&lt;/p&gt;

&lt;p&gt;Server端关闭tcp_tw_recycle即可。方法如下:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;err&quot;&gt;##&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;编辑sysctl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;conf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;修改配置或删除配置&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;##&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;该配置默认为0&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;##&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sysctl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;conf&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ipv4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;tcp_timestamps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;##&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;使配置生效&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sysctl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Timestamps计算：&lt;a href=&quot;https://www.cnblogs.com/good90/p/3911110.html&quot;&gt;https://www.cnblogs.com/good90/p/3911110.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;其他思考&quot;&gt;其他思考&lt;/h1&gt;

&lt;p&gt;以上描述基本就是网上”快餐版”问题描述以及解决方案了，按照上面的操作即可解决问题，但是有些细节还是值得人思考的。&lt;/p&gt;

&lt;h2 id=&quot;丢弃条件是什么&quot;&gt;丢弃条件是什么？&lt;/h2&gt;

&lt;p&gt;不论是问题描述还是测试过程中都会发现，是”时不时”连接不上，并不是小的那台机器所有的SYN不能连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/tcp_tw_recycle/image3.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.0083333333333333in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/tcp_tw_recycle/image4.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”0.9736111111111111in”}&lt;/p&gt;

&lt;p&gt;通过测试也能发现当11:57:25的时候发起SYN，期间server没有回包，client2重试了6次，在11:58:28的时候，server回复了ACK包，随后握手成功。再次连接成功间隔约63秒。&lt;/p&gt;

&lt;p&gt;也就是TSval小的client 2 还是有机会连接成功的，并不是全部丢弃。&lt;/p&gt;

&lt;p&gt;那么丢弃条件是什么呢？&lt;/p&gt;

&lt;p&gt;Linux源码net/ipv4/tcp_input.c的tcp_v4_conn_request方法中有如下描述：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* VJ's idea. We save last timestamp seen
     * from the destination in peer table, when entering
     * state TIME-WAIT, and check against it before
     * accepting new connection request.
     *
     * If &quot;isn&quot; is not zero, this request hit alive
     * timewait bucket, so that all the necessary checks
     * are made in the function processing timewait state.
     */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp_opt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;saw_tstamp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tcp_death_row&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sysctl_tw_recycle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inet_csk_route_req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;peer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rt_get_peer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;peer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v4daddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;saddr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;peer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_ts_stamp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;TCP_PAWS_MSL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;peer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_ts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ts_recent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
                        &lt;span class=&quot;no&quot;&gt;TCP_PAWS_WINDOW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;no&quot;&gt;NET_INC_STATS_BH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock_net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;LINUX_MIB_PAWSPASSIVEREJECTED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drop_and_release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;TCP_PAWS_MSL&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/* Per-host timestamps are invalidated
                     * after this time. It should be equal
                     * (or greater than) TCP_TIMEWAIT_LEN
                     * to provide reliability equal to one
                     * provided by timewait state.
                     */&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;TCP_PAWS_WINDOW&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;cm&quot;&gt;/* Replay window for per-host
                     * timestamps. It must be less than
                     * minimal timewait lifetime.
                     */&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;借用网络上的描述：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/tcp_tw_recycle/image5.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.3006944444444444in”}&lt;/p&gt;

&lt;p&gt;网络文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.just4coding.com/blog/2017/11/09/timewait/&quot;&gt;http://www.just4coding.com/blog/2017/11/09/timewait/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jdonson/p/4760130.html&quot;&gt;https://www.cnblogs.com/jdonson/p/4760130.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;tsval大的成功后60秒小的都不能连接&quot;&gt;TSval大的成功后60秒，小的都不能连接？&lt;/h2&gt;

&lt;p&gt;通过以上描述对具体的原因也应该有了大致的理解了，但是在实际测试过程中，发现并不是只要TSVal大的连接连上后，TSval小的就连接不上。Server端起的nginx服务，分别使用curl和telnet，具体表现并不相同。&lt;/p&gt;

&lt;p&gt;Client1 TSval 值比Client2的大。&lt;/p&gt;

&lt;p&gt;使用curl测试情况如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用curl，无论client端谁先请求，推出都不会出现连接失败&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用telnet测试情况如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;同时使用Client1 Client2 进行telnet，均能连接成功&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Client 2 telnet连接成功后退出，Client1再连接，Client1连接成功&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Client 1 telnet连接成功后退出，Client2再连接，Client2连接失败&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以发现只有当telnet时间戳大的一方连接成功并且退出才会出现问题，并不是文章中描述的只要TSval大的连接成功后，TSval小的就连接失败。那原因是什么呢？&lt;/p&gt;

&lt;p&gt;通过抓包可发现telnet关闭时，并不是client发起了四次挥手，而是server。并且telnet也给了相应的提示：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@automatic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;telnet&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;117&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.*.*.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;154&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt; 
 &lt;span class=&quot;nc&quot;&gt;Trying&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;117&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.*.*.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;154&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;                         
 &lt;span class=&quot;nc&quot;&gt;Connected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;117&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.*.*.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;154&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;                      
 &lt;span class=&quot;nc&quot;&gt;Escape&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;character&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;                        
 &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Connection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closed&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foreign&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;                &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;../images/tcp_tw_recycle/image6.jpeg&quot; alt=&quot;https://img-blog.csdnimg.cn/2018122410082654.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmd6aG91emhvdQ==,size_16,color_FFFFFF,t_70&quot; /&gt;{width=”4.617835739282589in”
height=”3.19371719160105in”}&lt;/p&gt;

&lt;p&gt;和curl不同，curl是client发起了FIN，而telnet是server发起了FIN，只有发起方才会进入TIME_WAIT状态，结合之前的源码上的注释，60秒范围的起始时间并不是上个连接成功的时间，而是TIME_WAIT产生的时间。&lt;/p&gt;

&lt;p&gt;服务器会拿到这个时间，和后续的连接请求发起比较，如果请求与上次的TIME_WAIT间隔在60秒之内，并且timestamp还比上次的小，那么这个包将直接丢弃。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;no&quot;&gt;VJ&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;We&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;save&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destination&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;peer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entering&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;TIME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;WAIT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;check&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;against&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accepting&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;所以需要注意的是比较的时间是上次服务端的TIME_WAIT发生的时间，而不是建立连接成功的时间。&lt;/p&gt;

&lt;p&gt;其他：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Server主动断开会产生TIME_WAIT连接，通常可以通过netstat -n -t
查看，但是可能很难看到，因为tcp_tw_recycle就是为了快速回收TIME_WAIT的连接的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;上面的示例（&lt;a href=&quot;http://www.just4coding.com/blog/2017/11/09/timewait/&quot;&gt;http://www.just4coding.com/blog/2017/11/09/timewait/&lt;/a&gt;）文章做测试的时候，将nginx的keepalive关闭，让server上的nginx主动断开，所以curl也能复现，但实际使用nginx不会这么用，带来了一定的误解。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;其他&quot;&gt;其他&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;tcp_tw_recycle 已经不建议使用，4.12内核中被移除&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;客户端和服务端必须开启tw_timestamp才会出现这种情况&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;引用文章&quot;&gt;引用文章&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/pengzhouzhou/article/details/85229437&quot;&gt;https://blog.csdn.net/pengzhouzhou/article/details/85229437&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4396e46187ca5070219b81773c4e65088dac50cc&quot;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4396e46187ca5070219b81773c4e65088dac50cc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/good90/p/3911110.html&quot;&gt;https://www.cnblogs.com/good90/p/3911110.html&lt;/a&gt;
&lt;a href=&quot;https://www.iteye.com/blog/elf8848-2089414&quot;&gt;https://www.iteye.com/blog/elf8848-2089414&lt;/a&gt;
&lt;a href=&quot;https://www.cnblogs.com/10087622blog/p/11017455.html&quot;&gt;https://www.cnblogs.com/10087622blog/p/11017455.html&lt;/a&gt;
&lt;a href=&quot;https://www.cnblogs.com/jdonson/p/4760130.html&quot;&gt;https://www.cnblogs.com/jdonson/p/4760130.html&lt;/a&gt;
&lt;a href=&quot;https://blog.51cto.com/fuyuan2016/1795998&quot;&gt;https://blog.51cto.com/fuyuan2016/1795998&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/tcp_tw_recycle%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5&quot;&gt;tcp_tw_recycle问题排查&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on August 10, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[java synchronized的实现]]></title>
  <link>http://yangqiju.github.io/java-lock</link>
  <id>http://yangqiju.github.io/java-lock</id>
  <published>2019-08-06T00:00:00-04:00</published>
  <updated>2019-08-06T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h2 id=&quot;锁的实现&quot;&gt;锁的实现&lt;/h2&gt;

&lt;h3 id=&quot;synchronized&quot;&gt;Synchronized&lt;/h3&gt;

&lt;p&gt;当声明 synchronized 代码块时，编译而成的字节码将包含 monitorenter 和 monitorexit
指令。这两种指令均会消耗操作数栈上的一个引用类型的元素（也就是 synchronized
关键字括号里的引用），作为所要加锁解锁的锁对象。&lt;/p&gt;

&lt;p&gt;为了保证正常和异常都能够释放锁，所以在在正常异常退出之前都增加了monitorexit。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/synchronized的实现//ac657b557dddbbf52f6503a3fb267f73.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当用 synchronized 标记方法时，你会看到字节码中方法的访问标记包括
ACC_SYNCHRONIZED。该标记表示在进入该方法时，Java 虚拟机需要进行 monitorenter
操作。而在退出该方法时，不管是正常返回，还是向调用者抛异常，Java
虚拟机均需要进行 monitorexit 操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/synchronized的实现//620ae07c75049397ea29c9ab6b255773.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于 monitorenter 和 monitorexit
的作用，我们可以抽象地理解为每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。&lt;/p&gt;

&lt;p&gt;当执行monitorenter时，如果目标锁对象计数器为0，那么就说明没有被其他线程持有，JVM会将锁对象持有线程的指针指向当前线程，并将计数器加1。&lt;/p&gt;

&lt;p&gt;如果发现锁对象不为0，并且指针指向当前线程，表示当前线程持有锁，那就将计数器加1，就是可重入锁。当monitorexit的时候，再减1，减到0之后就释放了锁。&lt;/p&gt;

&lt;p&gt;如果发现锁对象不为0，并且指针不是指向当前线程，那就进行阻塞等待。&lt;/p&gt;

&lt;p&gt;Java的线程加锁阻塞和唤醒都是依靠操作系统完成的（重量级锁）。对于符合posix接口的操作系统，上述操作时通过pthread的互斥锁mutex来实现，并且涉及到系统用户态和内核态的切换，开销十分大。&lt;/p&gt;

&lt;p&gt;所以JVM做了很多优化，防止直接进入重量级锁。例如自旋锁、偏向锁、轻量级锁。&lt;/p&gt;

&lt;h3 id=&quot;自旋锁&quot;&gt;自旋锁&lt;/h3&gt;

&lt;p&gt;为了尽量避免昂贵的重量级锁操作，JVM会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放。如果此时锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。&lt;/p&gt;

&lt;p&gt;自旋的优点是解决了重量级锁的问题，但是缺点就是cpu空转也浪费了cpu，如果长时间自旋也是得不偿失，所以可以JDK1.6之后默认自旋10次（-XX:PreBlockSpin=10），如果还是无法获得锁，将回归到重量级锁。&lt;/p&gt;

&lt;h3 id=&quot;轻量级锁&quot;&gt;轻量级锁&lt;/h3&gt;

&lt;p&gt;JVM存在着类似的情形：多个线程在不同的时间段请求同一把锁，也就是说没有锁竞争。针对这种情形，JVM采用了轻量级锁，来避免重量级锁的阻塞以及唤醒。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/synchronized的实现/6a9bc2f424f6bc563814347e58dff764.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在对象的对象头中的标记字段（mark
word）。它的最后两位便被用来表示该对象的锁状态。其中，00 代表轻量级锁，01
代表无锁（或偏向锁），10 代表重量级锁，11 则跟垃圾回收算法的标记有关。&lt;/p&gt;

&lt;p&gt;当进行加锁操作时，JVM会判断是否是已经重量级锁。如果不是，他会在当前线程的当前栈帧划出一个空间，作为锁的记录，并将锁对象标记字段复制到该锁记录中。然后JVM尝试CAS替换锁对象标记字段。&lt;/p&gt;

&lt;p&gt;假设当前锁对象的标记字段为 X…XYZ，JVM就会比较该字段是否为
X…X01(无锁)。如果是，则替换为刚才分配的锁记录的地址。该线程成功获得这把锁。&lt;/p&gt;

&lt;p&gt;如果不是 X…X01（无锁），那么有两种可能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;该线程重复获取同一把锁。此时，Java
虚拟机会将锁记录插入一个值为0的记录，以代表该锁被重复获取。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二，其他线程持有该锁。此时，JVM会将这把锁膨胀为重量级锁，并且阻塞当前线程。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当进行解锁操作时，如果当前锁记录的值为
0，则代表重复进入同一把锁，直接返回即可。否则，JVM会尝试用 CAS
操作，比较锁对象的标记字段的值是否为当前锁记录的地址。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果是，则表示当前线程持有锁，就将锁对象的标记字段则替换为锁记录中的值，也就是锁对象原本的标记字段。此时，该线程已经成功释放这把锁。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果不是，则意味着这把锁已经被膨胀为重量级锁。此时，JVM就会进入重量级锁的释放过程，唤醒因竞争该锁而被阻塞了的线程。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;锁膨胀问题&quot;&gt;锁膨胀问题&lt;/h3&gt;

&lt;p&gt;Java6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁、轻量级锁，Java6中锁就有4个状态：无锁、偏向锁、轻量级锁和重量级锁。这几个状态会随着竞争情况逐渐升级，锁可以升级但是不能降级。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/53826114&quot;&gt;https://www.zhihu.com/question/53826114&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/java-lock&quot;&gt;java synchronized的实现&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on August 06, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[openwrt ubus学习]]></title>
  <link>http://yangqiju.github.io/ubus%E5%AD%A6%E4%B9%A0</link>
  <id>http://yangqiju.github.io/ubus学习</id>
  <published>2019-08-03T00:00:00-04:00</published>
  <updated>2019-08-03T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;ubus为openwrt平台开发中的进程间通信提供了一个通用的框架，类似linux桌面操作系统的d-bus，目标是提供系统级的进程间通信（IPC）功能,它让进程间通信的实现变得非常简单，并且ubus具有很强的可移植性，可以很方便地移植到其他linux平台上使用。ubus是为进程间发送消息而设计的，不适合传输大量数据（进程间传输大量数据应采用共享内存）&lt;/p&gt;

&lt;p&gt;ubus源码可通过Git库git://nbd.name/luci2/ubus.git获得，其依赖的ubox库的git库git://nbd.name/luci2/ubox.git。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image1.png&quot; alt=&quot;&quot; /&gt;{width=”4.861360454943132in”
height=”3.5696281714785654in”}&lt;/p&gt;

&lt;p&gt;简单理解它就是一个消息总线，用来串联服务之间的通讯，所有的消息均通过ubus进行转发处理。&lt;/p&gt;

&lt;p&gt;就是我们的消息 Route。&lt;/p&gt;

&lt;h1 id=&quot;基本使用&quot;&gt;基本使用&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image2.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.0659722222222223in”}&lt;/p&gt;

&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;

&lt;p&gt;列出已经注册的服务：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@uplink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:~&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ubus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;network&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;device&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lan&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loopback&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wan&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;添加-v 指令，并查看具体可执行方法&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@uplink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:~&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ubus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lan&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lan&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;099&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f0c8b&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;up&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;down&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;status&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;prepare&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;add_device&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;String&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;remove_device&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;String&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;notify_proto&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;remove&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;set_data&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;调用call方法进行跨进程rpc调用，并获得相应的返回值&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@uplink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:~&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ubus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wan&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;up&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;pending&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;available&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;autostart&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;uptime&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;86017&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;l3_device&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;eth1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;device&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;eth1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;address&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;s&quot;&gt;&quot;address&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;178.25.65.236&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;s&quot;&gt;&quot;mask&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;route&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;s&quot;&gt;&quot;target&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0.0.0.0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;s&quot;&gt;&quot;mask&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;s&quot;&gt;&quot;nexthop&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;178.25.71.254&quot;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;通过listen 监听所有的消息情况&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@uplink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:~&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ubus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@uplink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:~&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ubus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wan&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;down&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;network.interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ifdown&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wan&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@uplink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:~&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ubus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;network&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wan&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;up&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;network.interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ifup&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wan&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;network.interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ifdown&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;he&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;network.interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ifdown&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;v6&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;network.interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ifup&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;he&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;network.interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ifup&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;interface&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;v6&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;通过send发送消息:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@uplink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ubus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;send&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bar\&quot;: \&quot;baz\&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\'&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h1 id=&quot;结构&quot;&gt;结构&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image3.png&quot; alt=&quot;https://img-blog.csdn.net/20170926223729369?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWFtcGlzZmFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; /&gt;{width=”5.594444444444444in”
height=”4.017361111111111in”}&lt;/p&gt;

&lt;p&gt;工程的核心是ubusd精灵进程，它提供了一个总线层，在系统启动时运行，负责进程间的消息路由和传递。&lt;/p&gt;

&lt;p&gt;Ubus
client注册到ubusd进程进行消息的发送和接收，它实际上是一个操作库或接口，相当于sdk。相对于ubusd它是一个客户端，所以称它为ubus
client（ubus service更贴切）。例如下图的session和uci。&lt;/p&gt;

&lt;p&gt;这个接口是用linux文件socket和TVL（Type-length-value）实现的，每一个进程在指定命名空间下注册自己的路径。每一个路径都可以提供带有各种参数的多个函数处理过程。函数处理过程程序可以在完成处理后返回消息。&lt;/p&gt;

&lt;p&gt;Ubus cli 是ubus提供的操作工具，我们通过它能够对ubus进行操作。例如 ubus
list就是中的ubus即为cli。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image4.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.2527777777777778in”}&lt;/p&gt;

&lt;h1 id=&quot;代码分析&quot;&gt;代码分析&lt;/h1&gt;

&lt;p&gt;代码地址：&lt;/p&gt;

&lt;p&gt;根据代码分析可知，ubus是依赖了一个ubox的库，进行相应的socket操作。使得socket编程更为简单。&lt;/p&gt;

&lt;h2 id=&quot;ubusd分析&quot;&gt;ubusd分析&lt;/h2&gt;

&lt;p&gt;ubusd.c中入口&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ubus_socket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;UBUS_UNIX_SOCKET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;SIGPIPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SIG_IGN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//uloop初始化&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;uloop_init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getopt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;s:&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'s'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;ubus_socket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optarg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;usage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;unlink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ubus_socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;umask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0177&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//建立一个非阻塞 sock 服务，并赋值给 server_df&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;server_fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;USOCK_UNIX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;USOCK_SERVER&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;USOCK_NONBLOCK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ubus_socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server_fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;usock&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//添加read 事件监听&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;uloop_fd_add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server_fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ULOOP_READ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ULOOP_EDGE_TRIGGER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//uloop 并阻塞 ，里面会回调 server_fd.cb 方法&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;uloop_run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;unlink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ubus_socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;out:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;uloop_done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;在main函数中，可看到uloop相关都是ubox的标准接口，初始化、添加fd、run、done。按照上面的流程写也能写一个简单的socket
server。&lt;/p&gt;

&lt;p&gt;上面很重要的一个uloop_fd_add(&amp;amp;server_fd)方法。server_fd是一个uloop_fd结构里面需要设置callback方法，用于数据处理。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uloop_fd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server_fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server_cb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uloop_fd&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;uloop_fd_handler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eof&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;registered&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;server_cb 是 uloop_fd_handler ，该类型在uloop.h中已经定义。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt; &lt;span class=&quot;err&quot;&gt;##&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uloop_fd_handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uloop_fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;server_cb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uloop_fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_next_connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;uloop_fd_handler在什么时候被调用呢？可以在uloop_run方法中看到，当事件触发时，会回调cb方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image5.png&quot; alt=&quot;&quot; /&gt;{width=”5.0974846894138235in”
height=”2.138999343832021in”}&lt;/p&gt;

&lt;p&gt;那么重点就是get_next_connection方法了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image6.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”4.472222222222222in”}&lt;/p&gt;

&lt;p&gt;accept是socket的方法，accpet之后，会建立一个socket连接,ubusd_proto_new_client会将client_fd添加到二叉树中，存储所有的client。并注册client_cb。&lt;/p&gt;

&lt;p&gt;client_cb即描述了发送消息，接收消息、处理消息等方法。由于内容较多，这里只描述重要的方法，其他方法可自行查看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image7.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”5.768055555555556in”}&lt;/p&gt;

&lt;p&gt;我们挑选一个rpc的方法进行查看，即ubusd_handle_invoke方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image8.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”3.28125in”}&lt;/p&gt;

&lt;p&gt;由于ubusd是一个转发器，所以它并不处理真实的rpc请求，而是将它转发给实际要执行的client。&lt;/p&gt;

&lt;h2 id=&quot;ubus-service&quot;&gt;ubus service&lt;/h2&gt;

&lt;p&gt;在ubus源码中example文件夹中有server.c，它就是一个ubus service的demo。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image9.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”6.233333333333333in”}&lt;/p&gt;

&lt;p&gt;可以看到同样适用了标准化的init
、add_uloop、done等方法。最主要的是server_main方法，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image10.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.3881944444444443in”}&lt;/p&gt;

&lt;p&gt;ubus_add_object方法进行服务的注册，test_object则是个ubus_object对象，里面定义了name、method等信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image11.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.004166666666667in”}&lt;/p&gt;

&lt;p&gt;这里挑选一个hello方法进行查看。Hello方法收到消息后，对数据进行解析，并组合需要返回的内容，由于本service的名字为test，即test
receiverd a message %s ,%s为具体接收到的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image12.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.752083333333333in”}&lt;/p&gt;

&lt;h2 id=&quot;ubus-cli&quot;&gt;ubus cli&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image13.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”5.3875in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image14.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.907638888888889in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image15.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.3215277777777779in”}&lt;/p&gt;

&lt;h2 id=&quot;demo&quot;&gt;demo&lt;/h2&gt;

&lt;p&gt;将源码在openwrt的编译环境编译后，放到openwrt中，先执行service&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image17.png&quot; alt=&quot;&quot; /&gt;{width=”5.583619860017498in”
height=”1.027830271216098in”}&lt;/p&gt;

&lt;p&gt;再执行client&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image18.png&quot; alt=&quot;&quot; /&gt;{width=”5.2502701224846895in”
height=”1.2083956692913387in”}&lt;/p&gt;

&lt;h2 id=&quot;官方的log&quot;&gt;官方的log&lt;/h2&gt;

&lt;p&gt;通过执行ubus –v list，可以看到log 有
read、write方法，我们可以借此来分析一下源码，以确认我们前面的推理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image19.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”0.55625in”}&lt;/p&gt;

&lt;p&gt;Log的service源码是在ubox中，名字为logd.c。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image20.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”5.7555555555555555in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image21.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.0118055555555556in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image22.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.83125in”}&lt;/p&gt;

&lt;h2 id=&quot;rpcd&quot;&gt;Rpcd&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image23.png&quot; alt=&quot;image.png&quot; /&gt;{width=”5.768055555555556in”
height=”2.2503215223097115in”}&lt;/p&gt;

&lt;p&gt;Rpcd是一个比较特殊的实现，它在实现了ubus
service的基础上，进行了扩展，可以实现通过 http 来访问 ubus
总线（luci实现），并且也支持了加载本地shell。&lt;/p&gt;

&lt;p&gt;这里介绍一下本地shell的加载(mwan3的通过该方法实现ubus调用)&lt;/p&gt;

&lt;p&gt;下载rpcd源码进行查看，发现session、uci、iwinfo、file是通过rpcd实现的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image24.png&quot; alt=&quot;&quot; /&gt;{width=”5.028035870516185in”
height=”4.2502187226596675in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image25.png&quot; alt=&quot;&quot; /&gt;{width=”5.278048993875766in”
height=”5.028035870516185in”}&lt;/p&gt;

&lt;p&gt;Rpcd加载shell的目录如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image26.png&quot; alt=&quot;&quot; /&gt;{width=”5.583619860017498in”
height=”0.6805905511811023in”}&lt;/p&gt;

&lt;p&gt;按照过则编辑一个脚本：/usr/libexec/rpcd/foo&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$1&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;arg1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;arg2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;arg3&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;str&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;toto&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$2&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                                &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optionally&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;call&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$2&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$input&quot;&lt;/span&gt;
                                &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;world&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;toto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;item1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;item2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;item3&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;esac&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;esac&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;/etc/init.d/rpcd reload 或 重启。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image27.png&quot; alt=&quot;&quot; /&gt;{width=”3.180718503937008in”
height=”1.4584087926509186in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image28.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”0.8625in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image29.png&quot; alt=&quot;&quot; /&gt;{width=”3.597407042869641in”
height=”1.0000513998250218in”}&lt;/p&gt;

&lt;h1 id=&quot;其他&quot;&gt;其他&lt;/h1&gt;

&lt;h2 id=&quot;什么是tvl&quot;&gt;什么是TVL&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.wtango.com/tlv%E7%BC%96%E7%A0%81%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1/&quot;&gt;http://www.wtango.com/tlv%E7%BC%96%E7%A0%81%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;bus的意义是什么&quot;&gt;Bus的意义是什么？&lt;/h2&gt;

&lt;p&gt;有人整理了Unix/Linux IPC的七大分类：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image30.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”4.064583333333333in”}&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://github.com/robbie-cao/kb-openwrt/blob/master/UBUS.md&quot;&gt;https://github.com/robbie-cao/kb-openwrt/blob/master/UBUS.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这有涉及到SOA中esb相关知识了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zdz8207/p/java-esb.html&quot;&gt;https://www.cnblogs.com/zdz8207/p/java-esb.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ubus源码分析/image31.png&quot; alt=&quot;https://images2018.cnblogs.com/blog/47685/201806/47685-20180627204743899-564991765.png&quot; /&gt;{width=”5.768055555555556in”
height=”3.365980971128609in”}&lt;/p&gt;

&lt;h2 id=&quot;我们怎么使用&quot;&gt;我们怎么使用？&lt;/h2&gt;

&lt;p&gt;Mqtt
client可以参考之前的servcie进行实现，通过ubus进行跨进程间的通讯，将数据交付到mqtt
服务中，这样mqtt client与mqtt borker就只有一个连接了。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/ubus%E5%AD%A6%E4%B9%A0&quot;&gt;openwrt ubus学习&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on August 03, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[OPENWRT自定义固件]]></title>
  <link>http://yangqiju.github.io/openwrt%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BA%E4%BB%B6</link>
  <id>http://yangqiju.github.io/openwrt自定义固件</id>
  <published>2019-07-21T00:00:00-04:00</published>
  <updated>2019-07-21T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;本文讲述自定义固件相关操作。&lt;/p&gt;

&lt;h1 id=&quot;自定义固件&quot;&gt;自定义固件&lt;/h1&gt;

&lt;h2 id=&quot;下载源代码&quot;&gt;下载源代码&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/openwrt/openwrt&quot;&gt;https://github.com/openwrt/openwrt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文示例为17.0.6&lt;/p&gt;

&lt;h2 id=&quot;申明镜像&quot;&gt;申明镜像&lt;/h2&gt;

&lt;p&gt;根据cpu选择相应的架构，例如我们选择ramips的mt7621 cpu。&lt;/p&gt;

&lt;p&gt;vi openwrt-17.01.6/target/linux/ramips/image/mt7621.mk&lt;/p&gt;

&lt;p&gt;添加如下自定义（xcv1）&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Device&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g3&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;DTS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;UNLTO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;G3&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;IMAGE_SIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ralink_default_fw_size_16M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;DEVICE_TITLE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g3&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;DEVICE_PACKAGES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kmod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usb3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kmod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ledtrig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usbport&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kmod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kmod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ahci&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;endef&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;TARGET_DEVICES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;添加板子基本配置&quot;&gt;添加板子基本配置&lt;/h2&gt;

&lt;h3 id=&quot;添加名称对应&quot;&gt;添加名称对应&lt;/h3&gt;

&lt;p&gt;在 target/linux/ramips/base-files/lib/ramips.sh 文件中添加新设备名称。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image1.png&quot; alt=&quot;&quot; /&gt;{width=”2.7in” height=”1.4574398512685913in”}&lt;/p&gt;

&lt;h3 id=&quot;添加led-sys灯支持&quot;&gt;添加led sys灯支持&lt;/h3&gt;

&lt;p&gt;编辑 target/linux/ramips/base-files/etc/diag.sh&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image2.png&quot; alt=&quot;&quot; /&gt;{width=”5.153042432195975in”
height=”1.6945319335083115in”}&lt;/p&gt;

&lt;h3 id=&quot;network设置&quot;&gt;Network设置&lt;/h3&gt;

&lt;p&gt;编辑 target/linux/ramips/base-files/etc/board.d/02_network&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image3.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.6916666666666667in”}&lt;/p&gt;

&lt;p&gt;注意：因为我们主板的特殊性， 0是wan口，4是lan口，所以需要调整&lt;/p&gt;

&lt;h3 id=&quot;添加&quot;&gt;添加&lt;/h3&gt;

&lt;p&gt;编辑openwrt-17.01.6/target/linux/ramips/image/mt7621.mk文件，添加内容&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Device&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g3&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;DTS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;UNLTO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;G3&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;IMAGE_SIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ralink_default_fw_size_16M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;DEVICE_TITLE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g3&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;DEVICE_PACKAGES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kmod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usb3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kmod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ledtrig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usbport&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kmod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kmod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ahci&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;endef&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;TARGET_DEVICES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unlto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;添加硬件配置&quot;&gt;添加硬件配置&lt;/h2&gt;

&lt;p&gt;在openwrt-17.01.6/target/linux/ramips/dts 目录中添加UNLTO-G3.dts&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;mt7621.dtsi&quot;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bindings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;h&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;UNLTO-G3&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;memory&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;device_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;memory&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;##&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;内存大小&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8000000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;chosen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;##&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;115200&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;调试串口波特率&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;bootargs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;console=ttyS0,115200&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;gpio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;compatible&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gpio-leds&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

                &lt;span class=&quot;n&quot;&gt;buzzer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;buzzer&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;aerial&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;aerial&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sim&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;sim&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;modpower&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;modpower&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;stormgreen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;storm:green&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;stormred&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;storm:red&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;wangreen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wan:green&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;wanred&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wan:red&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
                &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;4g:1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
                &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;4g:2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
                &lt;span class=&quot;err&quot;&gt;###&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;每组gpio为32&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g3为32所以修改为gpio1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; 
                &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;4g:3&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

	&lt;span class=&quot;nl&quot;&gt;palmbus:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;palmbus&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;i2c&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;900&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;okay&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

			&lt;span class=&quot;nl&quot;&gt;pcf8563:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtc&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;51&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;okay&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;compatible&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;nxp,pcf8563&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x51&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;gpio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;polled&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;compatible&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gpio-keys-polled&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cells&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cells&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;reset&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;gpios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;linux&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;KEY_RESTART&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sdhci&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;okay&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;okay&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;


&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spi0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;okay&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;m25p80&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cells&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cells&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;compatible&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;jedec,spi-nor&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;spi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frequency&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m25p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chunked&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;u-boot&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x30000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;only&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;u-boot-env&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x30000&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;only&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

		&lt;span class=&quot;nl&quot;&gt;factory:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;factory&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x40000&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;firmware&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x50000&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1fb0000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

        &lt;span class=&quot;err&quot;&gt;##&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;这里单独做了一份32m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;的rootfs_data&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;是因为uboot要求会从0x2000000开始识别&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;用于存储uboot需要的数据&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;rootfs_data&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x2000000&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2000000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pcie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;okay&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;pcie0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;mt76&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0000&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;device_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;pci&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;mediatek&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mtd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eeprom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;ieee80211&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000000&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6000000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;mtd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xe000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;pcie1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;mt76&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0000&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;device_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;pci&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;mediatek&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mtd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eeprom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;ieee80211&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2400000&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2500000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;mtd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xe000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ethernet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;mtd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factory&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xe000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pinctrl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nl&quot;&gt;state_default:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pinctrl0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;gpio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;ralink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wdt&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;rgmii2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;jtag&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;mdio&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;ralink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gpio&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;执行&quot;&gt;执行&lt;/h2&gt;

&lt;p&gt;删除openwrt/tmp 执行make menuconfig&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image4.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”6.094444444444444in”}&lt;/p&gt;

&lt;h1 id=&quot;编译自己的软件&quot;&gt;编译自己的软件&lt;/h1&gt;

&lt;p&gt;参考
《openwrt,Lede深入学习笔记v2.0.pdf》中编译软件的方法。这里描述了一个compile
c的方法并将代码打成安装包。&lt;/p&gt;

&lt;p&gt;还有另外一种，直接将执行文件拷贝的方法，例如mwan3.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;TOPDIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mk&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;PKG_NAME:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mwan3&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;PKG_VERSION:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;PKG_RELEASE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;PKG_MAINTAINER:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Florian&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Eckert&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fe&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@dev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;tdt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;de&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;PKG_LICENSE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;GPLv2&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;INCLUDE_DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)/&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;.mk&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Package&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mwan3&lt;/span&gt;
   &lt;span class=&quot;nl&quot;&gt;SECTION:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;
   &lt;span class=&quot;nl&quot;&gt;CATEGORY:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Network&lt;/span&gt;
   &lt;span class=&quot;nl&quot;&gt;SUBMENU:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Routing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Redirection&lt;/span&gt;
   &lt;span class=&quot;nl&quot;&gt;DEPENDS:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iptables&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iptables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conntrack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extra&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iptables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipopt&lt;/span&gt;
   &lt;span class=&quot;nl&quot;&gt;TITLE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Multiwan&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hotplug&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tracking&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;support&lt;/span&gt;
   &lt;span class=&quot;nl&quot;&gt;PKGARCH:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;endef&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Package&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mwan3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conffiles&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mwan3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;endef&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Compile&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;endef&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Package&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mwan3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;install&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;CP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/*&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;endef&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BuildPackage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mwan3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h1 id=&quot;打包基础固件&quot;&gt;打包基础固件&lt;/h1&gt;

&lt;p&gt;通过openwert编译后，会生成一个基本可用能上网的路由器固件，但是如果我们有一些特殊的业务需要持续增加的时候怎么办呢？例如向增加一个/etc/config/test&lt;/p&gt;

&lt;p&gt;Openwrt提供了 image builder 的功能，make
menuconfig的时候，选择相应的选项后，会在bin/targets目录下生成镜像的同时，也生成一个builder。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image5.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.9472222222222224in”}&lt;/p&gt;

&lt;p&gt;解压后，在文件夹下创建一个files目录，files/etc/config/test，并执行&lt;/p&gt;

&lt;p&gt;make image FILES=files/ PROFILE=unlto-g3 PACKAGES=&quot; mwan3 &quot;&lt;/p&gt;

&lt;p&gt;这个语句会将
files里面的文件直接覆盖到系统的/下，packages执行将那些软件打入image中。&lt;/p&gt;

&lt;p&gt;编译成功后，会在bin/targets/ramips/mt7621/ 目录下生成相应的bin。&lt;/p&gt;

&lt;h1 id=&quot;注意问题&quot;&gt;注意&amp;amp;问题&lt;/h1&gt;

&lt;h2 id=&quot;设定一个大的可写空间&quot;&gt;设定一个大的可写空间&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image6.png&quot; alt=&quot;https://img-blog.csdn.net/20180724131607373?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nhb2Zlbmd0YW8xMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; /&gt;{width=”4.552777777777778in”
height=”4.282638888888889in”}&lt;img src=&quot;../images/openwrt自定义固件/image7.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”5.151388888888889in”}&lt;/p&gt;

&lt;p&gt;在linux系统中对闪存类存储器是采用MTD（内存技术设备）类设备驱动实现的，MTD是用于访问闪存类设备(ROM,FLASH)的linux驱动子系统。在openwrt中会将flash进行分区，内容为上图。固件中只有rootfs_data区域是可以写的。如果需要写入，并且重启不会消失。&lt;/p&gt;

&lt;p&gt;这样就需要在dts配置里添加一个名字为rootfs_data的32m的分区，但是由于在默认情况下，rootfs中就会包含一个rootfs_data，所以就会出现两个rootfs_data。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image8.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.482638888888889in”}&lt;/p&gt;

&lt;p&gt;这种情况下就需要修改配置 target/linux/ramips/mt7621/config-4.4
,添加如下配置，这样就明确申明不需要从rootfs中切分出一个小的rootfs_data，而是用我们申明的32m空间。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;# CONFIG_MTD_SPLIT_SQUASHFS_ROOT is not set
  ————————————————–&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image9.png&quot; alt=&quot;&quot; /&gt;{width=”5.222490157480315in”
height=”2.2640048118985128in”}&lt;/p&gt;

&lt;h2 id=&quot;双镜像uboot&quot;&gt;双镜像uboot&lt;/h2&gt;

&lt;p&gt;双镜像的uboot&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/angusding/witi-uboot&quot;&gt;https://github.com/angusding/witi-uboot&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;reboot-卡死问题&quot;&gt;Reboot 卡死问题&lt;/h2&gt;

&lt;p&gt;MT7621完美支持32M SPI Flash(W25Q256) 修复 soft reset fail&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yubing_615/article/details/52649489&quot;&gt;https://blog.csdn.net/yubing_615/article/details/52649489&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;添加第三方包&quot;&gt;添加第三方包&lt;/h2&gt;

&lt;p&gt;默认的openwrt只有核心源码，如果需要拓展新的功能，就需要导入packages，checkout到相应的版本，进行导入。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/openwrt/packages&quot;&gt;https://github.com/openwrt/packages&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;模组上网方式不同&quot;&gt;模组上网方式不同&lt;/h2&gt;

&lt;p&gt;红茶的模组使用了移远和广和通的模组，启动模组后通过ifconfig -a
可进行查看。&lt;/p&gt;

&lt;p&gt;移远为usb0
  ————–
  广和同为eth1&lt;/p&gt;

&lt;p&gt;为什么有这样的区别呢？猜测（）&lt;/p&gt;

&lt;p&gt;广和通用的是 cdc Ethernet
support，系统分为为eth1（因为eth0已经给默认网卡了），而移远使用usb
support的 cdc acm，分配为usb0。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image10.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.636111111111111in”}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image11.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.171527777777778in”}&lt;/p&gt;

&lt;h2 id=&quot;wan口也需要dhcp&quot;&gt;Wan口也需要dhcp？&lt;/h2&gt;

&lt;p&gt;平常我们接触到的是，电脑连接路由器，路由器会有dhcp服务，分给电脑一个ip。那问题来了，路由器的ip谁给分的呢？&lt;/p&gt;

&lt;p&gt;所以不论是wan口插线，还是4g信号联网，很重要的一部也是需要发起dhcp
client请求，让server分配一个ip。对应到openwrt配置里面，就是proto=dhcp。&lt;/p&gt;

&lt;p&gt;例如使用uci 设置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image12.png&quot; alt=&quot;&quot; /&gt;{width=”3.0557130358705162in”
height=”1.2639534120734908in”}&lt;/p&gt;

&lt;h2 id=&quot;主板相关信息&quot;&gt;主板相关信息&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image13.jpeg&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”4.361805555555556in”}&lt;/p&gt;

&lt;h1 id=&quot;刷机流程&quot;&gt;刷机流程&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;所有操作在windows上完成&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将设备的console口通过串口线与电脑连接，将lan口通过网线与电脑连接&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将电脑的IP地址设为固定IP:192.168.128.10,不要设置网关&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过windows的设备管理理器器查看串口的编号地址，一般为COM3（查看硬件设备可获知）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用putty连接设备的串口连接&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image14.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”5.348611111111111in”}&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;开启TFTP服务，设置IP和固件存放的目录&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image15.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”4.884722222222222in”}&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将设备断电重连，会在putty看到设备启动时候的日志，当出现数字选项时(0-9的数
字)，快速输入9(快速输⼊入防⽌止⾃自动进⼊入默认的选项，9对应的应该是:Load
U-Boot code then write to Flash via
TFTP，以实际的显示为准)，回车，输入IP填
192.168.128.1，输出IP填192.168.128.10，然后输入uboot固件的名称(与固件存放目
录下的⽂文件名保持一致)。回车后开始刷uboot。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;uboot刷成功以后设备会⾃自动重启，再次进⼊入数字选项时输入4，回车进入命令模式，此时输入”erase
linux”命令，擦出旧版本的系统，命令会处理理一段时间，处理完成后执行reset命令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新启动后进入数字选项阶段，此时输入2选项”Load system code then
write to Flash via
TFTP”。操作步骤与刷入uboot相同，只有最后一步的⽂文件名需要改为系统固件的的名称&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;刷机操作需要执行行几分钟，此后不不需要在做其他操作，putty会一直显示设备的操作日志。刷机完成后会进入默认选项，默认选项是启动系统，此时会显示设备启动的相关信
息，包含4G模块，wifi状态及wan口lan口状态，等待一会日志不在刷新时，按回车进入新的系统。出现下图代表刷机成功&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;附件&quot;&gt;附件&lt;/h2&gt;

&lt;h2 id=&quot;uboot刷完后配置参数&quot;&gt;Uboot刷完后配置参数&lt;/h2&gt;

&lt;p&gt;ETH_STATE_ACTIVE!!&lt;/p&gt;

&lt;p&gt;*** ERROR: `ethaddr' not set&lt;/p&gt;

&lt;p&gt;刷完uboot后可能会报上面的错误，这是需要设置相关参数&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;重新上电&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择4 enter boot command line interface&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行erase linux 擦除原系统&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行setenv ethaddr “00:0c:43:0a:0b:0d”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行saveenv保存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行reset重启&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;刷看门狗&quot;&gt;刷看门狗&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;设备先不上电，并且用串口连接看门狗的串口，并按上跳帽&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image18.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
 height=”4.368055555555555in”}&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先按照下图进行配置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../images/openwrt自定义固件/image19.jpeg&quot; alt=&quot;操作指南.jpeg&quot; /&gt;{width=”5.768055555555556in”
height=”4.156944444444444in”}&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;上电&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;附件中的pro_1726_2.hex设定时间为50秒，需要持续喂狗，50秒没有收到信息设备将会重启&lt;/p&gt;

&lt;h2 id=&quot;附件-1&quot;&gt;附件&lt;/h2&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/openwrt%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BA%E4%BB%B6&quot;&gt;OPENWRT自定义固件&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on July 21, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Java虚拟机规范笔记]]></title>
  <link>http://yangqiju.github.io/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E5%BF%AB%E6%9F%A5</link>
  <id>http://yangqiju.github.io/java虚拟机规范快查</id>
  <published>2019-04-03T00:00:00-04:00</published>
  <updated>2019-04-03T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h2 id=&quot;虚拟机结构&quot;&gt;虚拟机结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/Java虚拟机规范笔记/image1.jpeg&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.981540901137358in”}&lt;/p&gt;

&lt;p&gt;Java虚拟机可操作的数据类型分为两类：原始类型（primitive
type）和引用类型（reference
type）。对应的也有原始值和引用值，他们也用于变量赋值、参数传递、方法返回和运算操作。基本类型的变量放的就是数据本身，引用类型的变量存放的是对象引用，真正数据存储在堆中。变量包括类变量（静态字段）、实例变量（非静态字段）、数据元素、方法的参数和局部变量。&lt;/p&gt;

&lt;p&gt;原始数据类型包括数值类型（numeric
type）、boolean类型和returnAddress类型。数值类型又分为整数类型（integral
type）和浮点类型（floating-point type）。&lt;/p&gt;

&lt;p&gt;整数类型包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;byte类型：值为8位有符号二进制补码整数，默认为零，范围-2的7次方到2的7次方-1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;short类型：16位有符号二进制补码整数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;int类型：32位有符号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;long类型：64位有符号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;char类型：16位无符号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;float类型：单精度浮点数集合中的元素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;double类型：双精度浮点集合中的元素&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;returnAddress类型是指向某个操作码（opcode）的指针。&lt;/p&gt;

&lt;p&gt;虚拟机中没有任何供boolean值专用的字节码指令，java语言表达是操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替。boolean类型数组的访问与修改共用byte类型数组的baload和bastore指令。虚拟机会把boolean数组元素中的true用1表示，false用0来表示。&lt;/p&gt;

&lt;p&gt;在oracle的虚拟机里，java语言中的boolean数值将会被编码成java虚拟机的byte数组，每个boolean元素占8位。&lt;/p&gt;

&lt;p&gt;java虚拟机中有三种引用类型：类类型（class type），数组类型（array
type）和接口类型（interface type）。&lt;/p&gt;

&lt;p&gt;数组类型最外面那一维元素的类型叫做该数组类型的组件类型。引用类型的值还有个特殊的值：null，当一个引用不指向任何对象的时候，他的值就是null来表示。一个为null的引用，起初并不具备任何实际的运行期类型，但是他可以转型为任意的引用类型，引用类型的默认值就是null。java虚拟机规范并没有规定null在虚拟机实现中应当怎样用编码表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Java虚拟机规范笔记/image2.png&quot; alt=&quot;JVM_Internal_Architecture.png&quot; /&gt;{width=”5.768055555555556in”
height=”3.4212609361329833in”}&lt;/p&gt;

&lt;p&gt;对上图做个简单的概述，在JVM中，有栈（stack）、非堆（non
heap）、堆（heap）的概念。栈存在于每个线程当中，非堆主要描述code cache
和 永久代（permanent generation），堆主要分为年轻代、老年代。&lt;/p&gt;

&lt;p&gt;每个线程都有pc寄存器、java虚拟栈（stack）、本地方法栈（native
stack）。每执行一个方法就有new一个栈帧（frame），并且放在栈顶。每个栈帧里面又包含本地变量表（local
variable）、操作数栈（operand
stack）和指向当前方法所属的类的运行时常量池的引用和返回值（return
value）。&lt;/p&gt;

&lt;p&gt;非堆包括code cache 和 永久带，永久带中包含 interned strings和
方法区（method area）。interned strings 是JVM为保证string
引入相同的实例，在永久代中存储为Hashtable&amp;lt;oop, Symbol&amp;gt;，即当(&quot;j&quot; +
&quot;v&quot; + &quot;m&quot;).intern() == &quot;jvm&quot;。方法区中存储了栈帧中引用的class
信息。&lt;/p&gt;

&lt;p&gt;堆分为年轻代、老年代。年轻代分为伊甸区（eden space）和幸存区（sunvivor
space），类在伊甸区生成，经过minor
gc后，要么被回收，要么会到幸存区，幸存区经过major gc后到达老年区。&lt;/p&gt;

&lt;p&gt;更多查看：&lt;a href=&quot;http://blog.jamesdbloom.com/JVMInternals.html#jvm_system_threads&quot;&gt;http://blog.jamesdbloom.com/JVMInternals.html#jvm_system_threads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;运行时数据区：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pc寄存器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个线程都有自己的pc（program
 counter）寄存器，在任意时刻，一条java线程只会执行一个方法的代码，该方法被称为当前方法（current
 method）。如果该方法不是native的，那pc寄存器保存正在执行的字节码指令地址，如果是native的，值为undefined。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java虚拟机栈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个线程都有自己的java虚拟栈（java virtual machine
 stack），该栈与线程同时创建，用于存储栈帧（frame）。该栈用于存储局部变量和未计算好的结果。功能只能出栈入栈。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java堆&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;堆（heap）是可供各线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法区（method area）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它是可供各线程共享的运行时内存区域，存储了每个类的结构信息。例如：运行时常量池（runtime
 constant
 pool）、字段和方法数据、构造函数和普通方法的字节码内容，还包括类、实例、接口初始化时用到的特殊方法。它在虚拟机启动时创建，是堆的逻辑组成部分，可选择该区域不实现gc与压缩。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;运行时常量（runtime constant pool）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它是class文件或接口的常量池表（constant_pool
 table）的运行时表示形式，包括了常量、编译期可知的数值字面量和编译后才能获得的方法或字段引用。它类似与符号表（symbol
 table）。常量池在方法区中分配，在类和接口加载后创建。主要存放：字面量（literal）和符号引用（symbolic
 reference），字面量包括整数、浮点数和字符串字面量；符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;本地方法栈（native method stack）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它是用于支持虚拟机实现使用到传统的栈（例如 c
 stack），用来支持native方法的执行。在线程创建时，按线程分配。&lt;/p&gt;

&lt;p&gt;栈帧：&lt;/p&gt;

&lt;p&gt;frame是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接（dynamic
linking）、方法返回值和异常分派（dispatch
exception）。它随方法创建而创建，随方法结束而销毁。它的存储空间由创建它的线程分配在java虚拟栈，每个都有本地变量表（local
variable）、操作数栈（operand
stack）和指向当前方法所属的类的运行时常量池的引用。&lt;/p&gt;

&lt;p&gt;在线程执行过程总，只有正在执行的栈帧是活动的，它被称为当前栈帧（current
frame），对应的方法叫当前方法（current
method），方法的类叫当前类（current
class）。战争是线程私有数据，不可能在一个战争中引入另一个线程的栈帧。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;局部变量表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可保存类型为boolean、byte、char、short、int、float、reference、或returnAddress的数据，两个局部变量保存long或double。它用来完成方法调用时的参数传递，调用时从0位置开始，第0个一定是所在对象（this），后续参数从1开始。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;操作数栈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个栈帧都包含一个操作数栈，它后进先出。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动态链接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个栈帧都包含一个指向当前方法所在类型的运行时常量池的引用，以便对当前方法的代码实现动态链接。在class文件里，一个方法要调用其他方法，或访问成员变量，需要通过符号引用（symbolic
 reference）来表示，动态链接就是将这些符号引用所表示的方法转换为对实现方法的引用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法调用正常完成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是指执行没有异常。栈帧承担恢复调用者状态的责任，包括恢复调用者的局部变量表和操作数栈，以及正确传递长须计数器。调用者代码在被调用方法的返回值压入调用者栈帧操作数栈后，继续执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法调用异常完成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是指执行时某些指令导致了虚拟机异常或athrow字节码指令。异常调用不会有返回值给调用者。&lt;/p&gt;

&lt;p&gt;特殊方法：&lt;/p&gt;

&lt;p&gt;构造器以名为&amp;lt;init&amp;gt;的特殊实例初始化方法的形式出现，它在实例初始化期间，通过invokespecial指令调用，并且是在没有初始化的实例上。&lt;/p&gt;

&lt;p&gt;一个类或接口最多可以包换不超过一个类或接口的初始化方法，通过它完成初始化，该方法不包含参数、返回类型为void，名称为&amp;lt;clinit&amp;gt;。版本号大于51.0时，该方法必须设置ACC_STATIC标志。&lt;/p&gt;

&lt;p&gt;&amp;lt;clinit&amp;gt;被称为类构造器，java在编译之后会在字节码文件中生成该方法，它会将父类静态变量初始化、父类静态语句块、子类静态变量初始化、子类静态语句块放到&amp;lt;clinit&amp;gt;方法中，在类加载的过程中执行，且在&amp;lt;init&amp;gt;之前执行。&lt;/p&gt;

&lt;p&gt;&amp;lt;init&amp;gt;被称为实例构造器，它会将父类变量初始化、父类语句块、父类构造器、子类变量初始化、子类语句块、子类构造器方法放入&amp;lt;init&amp;gt;方法中，在类实例被初始化时被执行。&lt;/p&gt;

&lt;p&gt;异常：&lt;/p&gt;

&lt;p&gt;使用Throwable或其子类表示，抛异常的本质是程序控制，从异常抛出地方转换到处理异常的地方。&lt;/p&gt;

&lt;p&gt;异常有三种原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;athrow字节码被执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;程序操作发生异常&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚拟机内部异常，线程异步异常&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;字节码指令集：&lt;/p&gt;

&lt;p&gt;虚拟机指令由一个字节的操作码（opcode）和跟随其后0到多个代表参数的操作数（operand）构成。执行时是从pc寄存器中取出。&lt;/p&gt;

&lt;p&gt;数据类型与助记符关系：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  &lt;span class=&quot;n&quot;&gt;符号&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;------&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-----&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;------&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-------&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;------&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;------&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-------&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--------&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-----------&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;类型&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;

 &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;例如iload，指将一个int变量从本地变量加载到操作数栈中。&lt;/p&gt;

&lt;p&gt;指令分为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加载与存储指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如将本地变量加载到stack：lload。将stack的值存到局部变量表：istore。从常量池中提取并入stack：ldc，iconst_m1等。扩充局部变量表的访问索引或立即数：wide。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;算数指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如加法：iadd，ladd。比较：dcmpg等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类型转换指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如i2l,f2d等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象的创建于操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如：new、newarrary。访问字段getfield，putstatic等。把数组元素加载到stack：baload、aaload。将stack值存储到数组元素：bastore。取数组长度：arraylength。检查实例或数组类型：instanceof、checkcast。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;操作数栈管理指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pop、dup、swap等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;控制转移指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;条件分支：ifeq、iflt等。符合条件分支：taleswitch。无条件分支：got、ret。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法调用和返回指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;invokevirtual用于调用实例方法。&lt;/p&gt;

&lt;p&gt;invokeinterface调用接口方法。&lt;/p&gt;

&lt;p&gt;invokespecial调用特殊方法。&lt;/p&gt;

&lt;p&gt;invokestatic调用静态方法。&lt;/p&gt;

&lt;p&gt;invokedynamic调用以绑定了invokedynamic指令的调用点对象作为目标方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;抛出异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;athrow。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同步&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标识java语言中的synchronized块，指令为monitorenter和monitorexit两个指令。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E5%BF%AB%E6%9F%A5&quot;&gt;Java虚拟机规范笔记&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on April 03, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Rocketmq学习]]></title>
  <link>http://yangqiju.github.io/rocketmq%E5%AD%A6%E4%B9%A0</link>
  <id>http://yangqiju.github.io/rocketmq学习</id>
  <published>2019-03-04T00:00:00-05:00</published>
  <updated>2019-03-04T00:00:00-05:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;RocketMQ是一个分布式开放消息中间件，底层基于队列模型来实现消息收发功能。RocketMQ集群中包含4个模块：Namesrv,Broker, Producer, Consumer。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Namesrv: 存储当前集群所有Brokers信息、Topic跟Broker的对应关系。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Broker:
集群最核心模块，主要负责Topic消息存储、消费者的消费位点管理（消费进度）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Producer:
消息生产者，每个生产者都有一个ID(编号)，多个生产者实例可以共用同一个ID。同一个ID下所有实例组成一个生产者集群。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Consumer:
消息消费者，每个订阅者也有一个ID(编号)，多个消费者实例可以共用同一个ID。同一个ID下所有实例组成一个消费者集群。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/Rocketmq学习/image1.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in” height=”3.436111111111111in”}&lt;/p&gt;

&lt;h2 id=&quot;设计理念&quot;&gt;设计理念&lt;/h2&gt;

&lt;p&gt;RocketMq设计基于主题的发育与订阅模式，其核心功能包括消息发送、消息存储、消息消费，整体设计追求简单与性能第一，主要体现在如下三个方面。&lt;/p&gt;

&lt;p&gt;首先NameServer设计极其简单，摒弃了业界常用的zookeeper充当信息管理的注册中心，而是自研NameServer来实现元数据的管理（topic路由信息等），从实际需求出发，应为topic路由信息无需在集群之间保持
 一直，追求最终一致性，并且能容忍分钟级的不一致，正式基于此情况，RocketMQ的NameServer集群之间互不通讯，极大的降低了NameServer实现的复杂程度，对网络的要求也降低了不少，但是性能相比较Zookeeper有了极大的提升。&lt;/p&gt;

&lt;p&gt;其次是高效的IO存储机制，RokcetMQ最求消息发送到高吞吐量，RocketMQ的消息存储文件设计成文件组的概念，组内单个文件大小固定，方便引入内存映射机制，所有主题的消息存储基于顺序写，极大的提供了消息写性能，同时为了兼顾消息消费与消息查找，映入了消息消费队列与索引文件队列。&lt;/p&gt;

&lt;p&gt;最后是容忍存在的设计缺陷，如何保证消息一定能被消费者消费，并且只能消费一次，这个问题让使用中间件的人员用业务来实现，保证了内核的简化。&lt;/p&gt;

&lt;h2 id=&quot;路由通讯&quot;&gt;路由通讯&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/Rocketmq学习/image2.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
 height=”3.234722222222222in”}&lt;/p&gt;

&lt;p&gt;结合部署结构图，描述集群工作流程:&lt;/p&gt;

&lt;p&gt;1，启动Namesrv，Namesrv起来后监听端口，等待Broker、Produer、Consumer连上来，相当于一个路由控制中心。&lt;/p&gt;

&lt;p&gt;2，Broker启动，跟所有的Namesrv保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有topic信息。注册成功后，namesrv集群中就有Topic跟Broker的映射关系。&lt;/p&gt;

&lt;p&gt;3，收发消息前，先创建topic，创建topic时需要指定该topic要存储在哪些Broker上。也可以在发送消息时自动创建Topic。&lt;/p&gt;

&lt;p&gt;4，Producer发送消息，启动时先跟Namesrv集群中的其中一台建立长连接，并从Namesrv中获取当前发送的Topic存在哪些Broker上，然后跟对应的Broker建立长连接，直接向Broker发消息。&lt;/p&gt;

&lt;p&gt;5，Consumer跟Producer类似。跟其中一台Namesrv建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。&lt;/p&gt;

&lt;h2 id=&quot;与kafka存储的不同&quot;&gt;与kafka存储的不同&lt;/h2&gt;

&lt;p&gt;Kafka的存储设计：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Rocketmq学习/image3.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
 height=”2.2895833333333333in”}&lt;/p&gt;

&lt;p&gt;中每个topic_partition对应一个日志文件，Producer对该日志文件进行”顺序写”，Consumer对该文件进行”顺序读”。这种存储方式，对于每个文件来说是顺序IO，但是当并发的读写多个partition的时候，对应多个文件的顺序IO，表现在文件系统的磁盘层面，还是随机IO。因此出现了当partition或者topic个数过多时，Kafka的性能急剧下降。&lt;/p&gt;

&lt;p&gt;RocketMQ的存储文件设计：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Rocketmq学习/image4.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
 height=”1.7763888888888888in”}&lt;/p&gt;

&lt;p&gt;为了解决上述问题，RocketMQ采用了单一的日志文件，即把同1台机器上面所有topic的所有queue的消息，存放在一个文件里面，从而避免了随机的磁盘写入。所有消息都存在一个单一的CommitLog文件里面，然后有后台线程异步的同步到ConsumeQueue，再由Consumer进行消费。&lt;/p&gt;

&lt;p&gt;对于ConsumeQueue，是完全的顺序读写。可是对于CommitLog，Producer对其”顺序写”，Consumer却是对其”随机读”。&lt;/p&gt;

&lt;p&gt;对于这样的一个大型文件，又要随机读，如何提高读写效率呢？&lt;/p&gt;

&lt;p&gt;答案就是”内存映射文件”。关于内存映射文件的原理，以后有机会，可以在LInux的篇章中，详细分析。此处就不展开了。&lt;/p&gt;

&lt;p&gt;对于RocketMQ来说，它是把内存映射文件串联起来，组成了链表。因为内存映射文件本身大小有限制，只能是2G。所以需要把多个内存映射文件串联成一个链表，来和一个屋里文件对应起来。&lt;/p&gt;

&lt;p&gt;所以：当topic很多的时候，RocketMQ是个好的选择&lt;/p&gt;

&lt;p&gt;原文： &lt;a href=&quot;https://blog.csdn.net/chunlongyu/article/details/54576649&quot;&gt;https://blog.csdn.net/chunlongyu/article/details/54576649&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ms架构&quot;&gt;M/S架构&lt;/h2&gt;

&lt;p&gt;高可用性几乎是每个分布式系统在设计时必须要考虑的一个重要特性，在遵 循
 CAP 原则(即:一致性、可用性和分区容错性三者无法在分布式系统中被同
 时满足，并且最多只能满足其中两个)基础上，业界也提出了一些针对分布式系
 统通用的高可用解决方案，如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Rocketmq学习/image5.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.390972222222222in”}&lt;/p&gt;

&lt;p&gt;其中，行代表了分布式系统中通用的高可用解决方案，包括冷备、
 Master/Slave、Master/Master、两阶段提交以及基于 Paxos 算法的解决方案;
 列代表了分布式系统所关心的各项指标，包括数据一致性、事务支持程度、数据
 延迟、系统吞吐量、数据丢失可能性、故障自动恢复方式。&lt;/p&gt;

&lt;p&gt;从图中可以看出，不同的解决方案对各项指标的支持程度各有侧重。基于 CAP
 原则，很难设计出一种高可用方案能同时够满足所有指标的最优值，以
 Master/Slave 为例，一般满足如下几个特性:&lt;/p&gt;

&lt;p&gt;1) Slave 是 Master 的备份，可以根据数据的重要程度设置 Slave 的个数。
 数据写请求命中 Master，读请求可命中 Master 或者 Slave。&lt;/p&gt;

&lt;p&gt;2) 写请求命中 Master 之后，数据可通过同步或者异步的方式从 Master&lt;/p&gt;

&lt;p&gt;复制到 Slave 上;其中同步复制模式需要保证 Master 和 Slave
 均写成功后才反馈给客户端成功;异步复制模式只需要保证Master
 写成功即可反馈给客户端成 功。&lt;/p&gt;

&lt;p&gt;数据通过同步或者异步方式从 Master 复制到 Slave 上，因此 Master/Slave
 结构至少能保证数据的最终一致性;异步复制模式下，数据在 Master 写成功后
 即可反馈给客户端成功，因此系统拥有较低的延迟和较高的吞吐量，但同时会带
 来 Master 故障丢数据的可能性;如期望异步复制模式下 Master 故障时数据仍
 不丢，Slave 只能以 Read-Only 的方式等待 Master
 的恢复，即延长了系统的故障恢复时间。相反，Master/Slave
 结构中的同步复制模式会以增大数据写入延迟、降低系统吞吐量的代价来保证机器故障时数据不丢，同时降低系统故障恢复时间。&lt;/p&gt;

&lt;p&gt;RocketMQ 以 Master/Slave 结构实现多机房对等部署，消息的写请求会命中
 Master，然后通过同步或者异步方式复制到 Slave
 上进行持久化存储;消息的读请求会优先命中Master，当消息堆积导致磁盘压力大时，读请求转移至
 Slave。&lt;/p&gt;

&lt;p&gt;出于对系统复杂性以及消息引擎本身对 CAP 原则适配的考虑，RocketMQ
 高可用架构的设计采用了 Master/Slave 结构，在提供低延迟、高吞吐量消息服
 务的基础上，采用主备同步复制的方式避免故障时消息的丢失。数据同步过程中，
 通过维护一个递增的全局唯一 SequenceID 来保证数据强一致。同时引入故障
 自动恢复机制以降低故障恢复时间，提升系统的可用性。&lt;/p&gt;

&lt;h3 id=&quot;到底会不会丢数据&quot;&gt;到底会不会丢数据？&lt;/h3&gt;
&lt;p&gt;首先消息borker收到消息后会顺序写入CommitLog，数据会同步或者异步的方式进行master/slave复制，然后异步刷盘（默认，要求数据安全性的可改成同步）。所以当主从复制是异步的，刷盘也是异步的时候，主从都挂的情况下，数据就丢了。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/eece39beee20&quot;&gt;https://www.jianshu.com/p/eece39beee20&lt;/a&gt;
 &lt;a href=&quot;https://blog.51cto.com/13925625/2276357&quot;&gt;https://blog.51cto.com/13925625/2276357&lt;/a&gt;
 &lt;a href=&quot;https://www.songma.com/news/txtlist_i24016v.html&quot;&gt;https://www.songma.com/news/txtlist_i24016v.html&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/rocketmq%E5%AD%A6%E4%B9%A0&quot;&gt;Rocketmq学习&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on March 04, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[nacos学习]]></title>
  <link>http://yangqiju.github.io/nacos%E5%AD%A6%E4%B9%A0</link>
  <id>http://yangqiju.github.io/nacos学习</id>
  <published>2019-01-19T00:00:00-05:00</published>
  <updated>2019-01-19T00:00:00-05:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;Nacos是阿里巴巴开源的微服务注册中心与配置中心。Nacos
提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。Nacos
帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos
是构建以”服务”为中心的现代应用架构 (例如微服务范式、云原生范式)
的服务基础设施。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务发现与服务管理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在采用以”服务(Service)”为中心的诸如微服务及云原生方式的现代应用架构时，动态服务发现至关重要。
 Nacos同时支持基于DNS和基于RPC（如Dubbo/gRPC）的服务发现，并为您提供服务的实时的健康检查以防止将请求发送给不健康的主机，基于Nacos您也可以更方便的实现服务断路器。Nacos提供的强大的服务的元数据管理，路由及流量管理策略也能够帮助您更好的构建更强壮的微服务平台。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动态配置管理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;动态配置服务允许您在所有环境中以集中和动态的方式管理所有应用程序或服务的配置。动态配置消除了配置更新时重新部署应用程序和服务的需要。可以更方便的帮助您实现无状态服务，更轻松地实现按需弹性扩展服务实例。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动态DNS服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;支持权重路由的动态DNS服务使您可以更轻松地在数据中心内的生产环境中实施中间层负载平衡，灵活的路由策略，流量控制和简单的DNS解析服务，帮助您更容易的实现DNS-based服务发现。&lt;/p&gt;

&lt;p&gt;以下是nacos的路线图，官方宣称0.8版本将能用于生产环境。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/nacos学习/image1.png&quot; alt=&quot;https://oscimg.oschina.net/oscnet/3232feabcda991788193ccf426112c338a9.jpg&quot; /&gt;{width=”5.768055555555556in”
height=”3.2592268153980752in”}&lt;/p&gt;

&lt;h1 id=&quot;与主流开源生态关系&quot;&gt;与主流开源生态关系&lt;/h1&gt;

&lt;p&gt;阿里开源生态体系如Dubbo等自身的支持，也非常强调融入其它的开源生态，这里就包括Java的微服务生态体系Spring
Cloud，Kubernetes/CNCF云原生生态体系，正如Nacos的未来全景图展示的那样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/nacos学习/image2.png&quot; alt=&quot;https://oscimg.oschina.net/oscnet/a4a851f2787f6b7727fc27e7df4c9a47217.jpg&quot; /&gt;{width=”5.768055555555556in”
height=”3.267014435695538in”}&lt;/p&gt;

&lt;h2 id=&quot;dubbo&quot;&gt;Dubbo&lt;/h2&gt;

&lt;p&gt;在阿里巴巴生产环境上，Dubbo和Nacos天然就是长在一起的，因为Nacos的缺失，传统的注册中心解决方案让Dubbo在服务治理、流量治理、服务运营和管理等方面的威力被限制和削弱了，Nacos的开源和开放会在采用Dubbo的用户环境中释放这些威力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/nacos学习/image3.png&quot; alt=&quot;https://oscimg.oschina.net/oscnet/bc7fd51e8b426ef176a633d007755682ff2.jpg&quot; /&gt;{width=”5.768055555555556in”
height=”3.267014435695538in”}&lt;/p&gt;

&lt;h2 id=&quot;spring-cloud&quot;&gt;Spring Cloud&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/nacos学习/image4.png&quot; alt=&quot;https://oscimg.oschina.net/oscnet/46f41a92dcd73b2c4e624db78f4d02ed802.jpg&quot; /&gt;{width=”5.768055555555556in”
height=”3.2700907699037622in”}&lt;/p&gt;

&lt;h2 id=&quot;kubernetes-dns-based-service-discovery&quot;&gt;Kubernetes DNS-based Service Discovery&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/nacos学习/image5.png&quot; alt=&quot;https://oscimg.oschina.net/oscnet/d092dedfa8250ee6eb7472798fd6f0cda22.jpg&quot; /&gt;{width=”5.768055555555556in”
height=”3.2700907699037622in”}&lt;/p&gt;

&lt;p&gt;未来会有越来越多java生态的用户会选择 Kubernetes+Spring Cloud
组合，但不幸的是，在服务发现和配置管理的解决方案上，这2个体系都采用了完全不同的方案，这给同时采用2个体系的用户在注册中心和配置中心的需求上带来了非常大的不必要的复杂性。Nacos会尝试填补2者的鸿沟，以便在2套体系下可以采用同一套服务发现和配置管理的解决方案，这将大大的简化使用和维护的成本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/nacos学习/image6.png&quot; alt=&quot;https://oscimg.oschina.net/oscnet/b949bee5440753f456505fa8c6b4dfaf28c.jpg&quot; /&gt;{width=”5.768055555555556in”
height=”3.2743799212598423in”}&lt;/p&gt;

&lt;h2 id=&quot;service-mesh&quot;&gt;Service Mesh&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/nacos学习/image7.png&quot; alt=&quot;https://oscimg.oschina.net/oscnet/ae6e463a303957c1ac533ddafa2c5778470.jpg&quot; /&gt;{width=”5.768055555555556in”
height=”3.2767235345581804in”}&lt;/p&gt;

&lt;h1 id=&quot;架构&quot;&gt;架构&lt;/h1&gt;

&lt;h2 id=&quot;基本架构及概念&quot;&gt;基本架构及概念&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/nacos学习/image8.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.6215277777777777in”}&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务 (Service)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos
支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者
Spring Cloud RESTful Service.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务注册中心 (Service Registry)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;服务注册中心，它是服务，其实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查
API 来验证它是否能够处理请求。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务元数据 (Service Metadata)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务提供方 (Service Provider)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是指提供可复用和可调用服务的应用方&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务消费方 (Service Consumer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是指会发起对某个服务调用的应用方&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;配置 (Configuration)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如
WAR，JAR
包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;配置管理 (Configuration Management)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;名字服务 (Naming Service)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;提供分布式系统中所有对象(Object)、实体(Entity)的”名字”到关联的元数据之间的映射管理服务，例如
ServiceName -\ Endpoints Info, Distributed Lock Name -\ Lock
Owner/Status Info, DNS Domain Name -\ IP List, 服务发现和 DNS
就是名字服务的2大场景。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;配置服务 (Configuration Service)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者。&lt;/p&gt;

&lt;h2 id=&quot;逻辑架构及其组件介绍&quot;&gt;逻辑架构及其组件介绍&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/nacos学习/image9.jpeg&quot; alt=&quot;\\Mac\Home\Library\Containers\com.tencent.qq\Data\Library\Application
Support\QQ\Users\362991493\QQ\Temp.db\1F7838B5-937C-4466-A91A-A4FBD58F3646.png&quot; /&gt;{width=”5.768055555555556in”
height=”4.246773840769904in”}&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;服务管理：实现服务CRUD，域名CRUD，服务健康状态检查，服务权重管理等功能&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置管理：实现配置管CRUD，版本管理，灰度管理，监听管理，推送轨迹，聚合数据等功能&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;元数据管理：提供元数据CURD 和打标能力&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;插件机制：实现三个模块可分可合能力，实现扩展点SPI机制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;事件机制：实现异步化事件通知，sdk数据变化异步通知等逻辑&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;日志模块：管理日志分类，日志级别，日志可移植性（尤其避免冲突），日志格式，异常码+帮助文档&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;回调机制：sdk通知数据，通过统一的模式回调用户处理。接口和数据结构需要具备可扩展性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻址模式：解决ip，域名，nameserver、广播等多种寻址模式，需要可扩展&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;推送通道：解决server与存储、server间、server与sdk间推送性能问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;容量管理：管理每个租户，分组下的容量，防止存储被写爆，影响服务可用性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;流量管理：按照租户，分组等多个维度对请求频率，长链接个数，报文大小，请求流控进行控制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缓存机制：容灾目录，本地缓存，server缓存机制。容灾目录使用需要工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动模式：按照单机模式，配置模式，服务模式，dns模式，或者all模式，启动不同的程序+UI&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一致性协议：解决不同数据，不同一致性要求情况下，不同一致性机制。这里面用的raft&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;存储模块：解决数据持久化、非持久化存储，解决数据分片问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nameserver：解决namespace到clusterid的路由问题，解决用户环境与nacos物理环境映射问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CMDB：解决元数据存储，与三方cmdb系统对接问题，解决应用，人，资源关系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Metrics：暴露标准metrics数据，方便与三方监控系统打通&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Trace：暴露标准trace，方便与SLA系统打通，日志白平化，推送轨迹等能力，并且可以和计量计费系统打通&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接入管理：相当于阿里云开通服务，分配身份、容量、权限过程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户管理：解决用户管理，登录，sso等问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;权限管理：解决身份识别，访问控制，角色管理等问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;审计系统：扩展接口方便与不同公司审计系统打通&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通知系统：核心数据变更，或者操作，方便通过SMS系统打通，通知到对应人数据变更&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OpenAPI：暴露标准Rest风格HTTP接口，简单易用，方便多语言集成&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Console：易用控制台，做服务管理、配置管理等操作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SDK：多语言sdk&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Agent：dns-f类似模式，或者与mesh等方案集成&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CLI：命令行对产品进行轻量化管理，像git一样好用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;集群部署&quot;&gt;集群部署&lt;/h2&gt;

&lt;p&gt;官方建议集群模式部署：&lt;/p&gt;

&lt;p&gt;推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nacos.com/&quot;&gt;http://nacos.com&lt;/a&gt;:port/openAPI 域名 +
VIP模式，可读性好，而且换ip方便，推荐模式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/nacos学习/image10.jpeg&quot; alt=&quot;96D273CF-416B-4637-A784-9071AC613771.png&quot; /&gt;{width=”5.768055555555556in”
height=”2.5017902449693787in”}&lt;/p&gt;

&lt;p&gt;作为配置中心，nacos可将配置存放在mysql中。&lt;/p&gt;

&lt;p&gt;作为注册中心，nacos使用底层的raft进行服务注册，保证数据一致性。&lt;/p&gt;

&lt;h1 id=&quot;其他&quot;&gt;其他&lt;/h1&gt;

&lt;h2 id=&quot;zookeeper同步工具&quot;&gt;Zookeeper同步工具&lt;/h2&gt;

&lt;p&gt;在使用dubbo框架中，我们通常将zookeeper作为注册中心，但是zookeeper作为一个CP系统（CAP理论中的数据一致性为重点），不是一个AP系统（CAP中，A强调可用性）。作为注册中心，AP系统更加适合。&lt;/p&gt;

&lt;p&gt;Zookeeper三个节点，挂两个之后不可用。&lt;/p&gt;

&lt;p&gt;详情查看：&lt;a href=&quot;https://www.infoq.cn/article/why-doesnot-alibaba-use-zookeeper&quot;&gt;https://www.infoq.cn/article/why-doesnot-alibaba-use-zookeeper&lt;/a&gt;
官方提供了一个nacos和zookeeper数据同步的工具：
&lt;a href=&quot;https://github.com/nacos-group/nacos-sync&quot;&gt;https://github.com/nacos-group/nacos-sync&lt;/a&gt;
示例如下：
&lt;a href=&quot;https://github.com/paderlol/nacos-sync-example&quot;&gt;https://github.com/paderlol/nacos-sync-example&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/nacos%E5%AD%A6%E4%B9%A0&quot;&gt;nacos学习&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on January 19, 2019.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[虚拟机类加载机制]]></title>
  <link>http://yangqiju.github.io/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6</link>
  <id>http://yangqiju.github.io/虚拟机类加载机制</id>
  <published>2018-04-10T00:00:00-04:00</published>
  <updated>2018-04-10T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;章节&quot;&gt;章节&lt;/h1&gt;

&lt;h2 id=&quot;类加载的时机&quot;&gt;类加载的时机&lt;/h2&gt;

&lt;p&gt;类从被加载到虚拟机内存开始，到卸载出内存，整个生命周期分为：加载（loading）、验证（verification）、准备（preparation）、解析（resolution）、初始化（initialization）、使用（using）、卸载（unloading）7个阶段，其中验证、准备、解析统称连接（Linking）。&lt;/p&gt;

&lt;p&gt;虚拟机严格规定有且只有5中情况必须立即对类进行”初始化”：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;遇到new、getstaic、putstatic或者invokestatic这四个字节码指令，如果类没有初始化，则需要先触发其初始化。场景为：使用new关键字实例化对象时、读取或设置一个类的静态字段时（被final修饰、已在编译期把结果放入常量池的静态字段除外）、以及调用类的静态方法时。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用java.lang.reflect包的方法对类进行反射调用的时候&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化类时，先触发父类的初始化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当虚拟机启动时，它会先初始化指定的主类（有main方法的类）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并这个方法的句柄所对应的类没有实例化。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;加载过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/虚拟机类加载机制/image1.png&quot; alt=&quot;&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加载&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;获取类的二进制流，转化为方法区的运行时数据结构，在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;验证&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;确保class文件字节流的信息符合虚拟机要求&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  文件格式验证

2.  元数据验证

3.  字节码验证

4.  符号引用验证
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;准备&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;为类变量分配内存并设置初始值，变量使用的内存都在方法区。例如（static int value=123）在这个阶段会被初始化为0，把value赋值运算的putstatic指令编译后放在了 clinit方法中，所以初始化阶段才会将value赋值为123。但如果value修饰为static final，则准备阶段就会赋值为123。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解析&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;clinit&gt;()方法是由编译器收集类变量的赋值动作和静态语句块合并产生的，如果两个都没有，则不生成该方法。它不需要显示调用父类构造器，虚拟机自动执行（&lt;init&gt;不会）。父类的&lt;clinit&gt;先执行，所以父类的静态语句要优先于子类。但接口不需要执行父类的&lt;clinit&gt;方法。接口的实现和子接口在初始化时，接口都不会被初始化，除非调用了变量。（接口没有静态方法块）。虚拟机用锁保证了&lt;clinit&gt;的多线程安全，有阻塞的可能。
&lt;/clinit&gt;&lt;/clinit&gt;&lt;/clinit&gt;&lt;/init&gt;&lt;/clinit&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;类加载器&quot;&gt;类加载器&lt;/h2&gt;

&lt;p&gt;比较两个类是否”相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。这里的”相等”包括类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。&lt;/p&gt;

&lt;p&gt;类加载器：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;启动器加载器（Bootstrap classLoader）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个类加载器负责加载java_home\lib目录中的jar，或者被-Xbootclasspath参数所指定的路径的，如果需要把加载请求委派给它，直接使用null代替&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;扩展类加载器（Extension ClassLoader）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载java_home\lib\ext目录中的，或者被java.ext.dirs系统变量指定路径的所有类库&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;应用程序类加载器（Application ClassLoader）或系统加载器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个类加载器有sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径（ClassPath）上所指定的类库。它是ClassLoader中的getSystemClassLoader()方法的返回值，所以也叫系统加载器，通常就是程序的默认加载器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/虚拟机类加载机制/image2.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中这种关系被称为类加载器的双亲委派模型，除了bootstrap
classloader其他的类加载器都有自己的父类加载器。父子关系不是用继承，而是组合的方式复用父类加载器的代码。&lt;/p&gt;

&lt;p&gt;它的工作过程是：如果有一个类加载器收到了类加载的请求，它首先不自己加载这个类，而是委托给父类去加载，每个层次的类加载都是如此，只有父加载器反馈自己无法完成加载请求（它的搜索范围没有找到这个类），子加载器才会自己加载。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findLoaderClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loadClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findBootstrapClassOrNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;resolveClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;破坏双亲委派&quot;&gt;破坏双亲委派&lt;/h2&gt;

&lt;p&gt;破坏双亲委派最直接的例子就是OSGi和java的SPI（service provider
interface）了。&lt;/p&gt;

&lt;p&gt;举个SPI的例子JDBC来说：&lt;/p&gt;

&lt;p&gt;最简单的实现就是：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Connection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DriverManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getConnection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;passwd&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//conn execute sql&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;先通过Class.forName进行注册&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.mysql.jdbc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Driver&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NonRegisteringDriver&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Driver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 注册到DriverManager&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DriverManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;registerDriver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Driver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SQLException&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RuntimeException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Can't register driver!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Driver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SQLException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Required for Class.forName().newInstance()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;然后就执行DriverManager.getConnection方法&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.sql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DriverManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//执行ServiceLoader.load(Driver.class);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;loadInitialDrivers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;JDBC DriverManager initialized&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;loadInitialDrivers方法会直接利用SPI加载Driver。因为驱动里面已经实现了SPI的配置。如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/虚拟机类加载机制/image3.jpeg&quot; alt=&quot;5FD56F7C-23EF-43F3-B3B5-ECED51EEE8F3.png&quot; /&gt;{width=”5.768055555555556in”
height=”1.640384951881015in”}&lt;/p&gt;

&lt;p&gt;所以在loadInitialDrivers执行的时候，会通过ServiceLoader把他们加载器来。这时候问题来了，DriverManager的代码是在rt.jar
的java.sql包里面，根据上面双亲委派的图来看能加载它的也就只有Bootstarp
ClassLoder来加载DriverManager了，但是如果他要想加载mysql驱动的话是不可能的，它只能加载java_home\lib下的包，所以可以看到在ServiceLoader.load(Driver.class)的时候，有些技巧。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServiceLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getContextClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServiceLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;通过代码可以看到，在加载Driver的时候指定了Thread.&lt;em&gt;currentThread&lt;/em&gt;().getContextClassLoader()进行加载，而Thread在init的时候会将AppClassLoader设置ContentClassLoader，所以当进行JDBC进行加载的时候就又回到了加载器的最底层，加载的步骤为BootStrap-\Ext-\App。&lt;/p&gt;

&lt;p&gt;有些容器（例如Glassfish）会将JDBC驱动放到lib\ext下面，这样的话直接使用ExtClassLoader就加载成功了，而有的程序（main方法直接跑）加载就是用了AppClassLoader进行加载了。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&quot;&gt;虚拟机类加载机制&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on April 10, 2018.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[ThreadLocal代码解析]]></title>
  <link>http://yangqiju.github.io/ThreadLocal%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90</link>
  <id>http://yangqiju.github.io/ThreadLocal代码解析</id>
  <published>2018-04-05T00:00:00-04:00</published>
  <updated>2018-04-05T00:00:00-04:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private
static类型的，用于关联线程和线程的上下文。&lt;/p&gt;

&lt;h1 id=&quot;源码解析&quot;&gt;源码解析&lt;/h1&gt;

&lt;p&gt;ThreadLocal
在很多开源框架中使用的还是比较广泛的，通常使用时都是用set、get、remove还有initialValue。jdk8源码示例如下，李东initialValue方法和get方法可以获得一个获得线程id的方法。get方法线程安全，每个线程都会获得不一样的id编号。&lt;/p&gt;

&lt;p&gt;+———————————————————————–+
| private static final AtomicInteger nextId = new AtomicInteger(0);     |
|                                                                       |
| // Thread local variable containing each thread's ID                 |
|                                                                       |
| private static final ThreadLocal&amp;lt;Integer\ threadId =                |
|                                                                       |
| new ThreadLocal&amp;lt;Integer() {                                        |
|                                                                       |
| \@Override                                                            |
|                                                                       |
| protected Integer initialValue() {                                    |
|                                                                       |
| return nextId.getAndIncrement();                                      |
|                                                                       |
| }                                                                     |
|                                                                       |
| };                                                                    |
|                                                                       |
| // Returns the current thread's unique ID, assigning it if necessary |
|                                                                       |
| public static int get() {                                             |
|                                                                       |
| return threadId.get();                                                |
|                                                                       |
| }                                                                     |
+———————————————————————–+&lt;/p&gt;

&lt;p&gt;在我们普遍使用过程中，通常会是使用set、get、remove。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ThreadLocal代码解析/image1.jpeg&quot; alt=&quot;1F3A247C-092E-4867-B2BA-191EB02116E4.png&quot; /&gt;{width=”5.768055555555556in”
height=”1.3908912948381453in”}&lt;/p&gt;

&lt;h2 id=&quot;set方法&quot;&gt;Set方法&lt;/h2&gt;

&lt;p&gt;+—————————————————————-+
| public void set(T value) {                                     |
|                                                                |
| Thread t = Thread.currentThread();                             |
|                                                                |
| //获得一个map，map是当前线程的threadLocals变量                 |
|                                                                |
| ThreadLocalMap map = getMap(t);                                |
|                                                                |
| if (map != null)                                               |
|                                                                |
| //map 的key 是ThreadLocal value是set的值                       |
|                                                                |
| map.set(this, value);                                          |
|                                                                |
| else                                                           |
|                                                                |
| createMap(t, value);                                           |
|                                                                |
| }                                                              |
|                                                                |
| //返回的map是当前线程的threadLocals变量                        |
|                                                                |
| ThreadLocalMap getMap(Thread t) {                              |
|                                                                |
| return t.threadLocals;                                         |
|                                                                |
| }                                                              |
|                                                                |
| //new了个ThreadLocalMap，并设置给了当前线程的threadLocals 变量 |
|                                                                |
| void createMap(Thread t, T firstValue) {                       |
|                                                                |
| t.threadLocals = new ThreadLocalMap(this, firstValue);         |
|                                                                |
| }                                                              |
+—————————————————————-+&lt;/p&gt;

&lt;p&gt;可以看出来，当调用ThreadLocal的Set方法的时候，是从当前线程里面拿出了一个Map，也就是每个线程都有自己的Map，所以这个方法是绝对安全的，不涉及到共享数据。而这个map以ThreadLocal这个对象为key，需要set的值为value，set到map里。&lt;/p&gt;

&lt;p&gt;也就是这个值存在了每个线程的threadLocals
里，对应的类型为ThreadLocalMap。它是ThreadLocal的一个内部类。而存储使用Entry数组，Entry继承了弱引用，如果有这个key（ThreadLocal）没有外部强引用引用它，在系统GC的时候，Key会被回收，变为null。&lt;/p&gt;

&lt;p&gt;+—————————————————————–+
| static class ThreadLocalMap {                                   |
|                                                                 |
| static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?\ {  |
|                                                                 |
| Object value;                                                   |
|                                                                 |
| Entry(ThreadLocal&amp;lt;?\ k, Object v) {                           |
|                                                                 |
| super(k);                                                       |
|                                                                 |
| value = v;                                                      |
|                                                                 |
| }                                                               |
|                                                                 |
| }                                                               |
|                                                                 |
| ThreadLocalMap(ThreadLocal&amp;lt;?\ firstKey, Object firstValue) {  |
|                                                                 |
| // INITIAL_CAPACITY 为16，指定一个entry数组用于存储            |
|                                                                 |
| table = new Entry[INITIAL_CAPACITY];                         |
|                                                                 |
| int i = firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - 1); |
|                                                                 |
| table[i] = new Entry(firstKey, firstValue);                   |
|                                                                 |
| size = 1;                                                       |
|                                                                 |
| setThreshold(INITIAL_CAPACITY);                                |
|                                                                 |
| }                                                               |
+—————————————————————–+&lt;/p&gt;

&lt;p&gt;ThreadLocalMap 的set方法如下：&lt;/p&gt;

&lt;p&gt;+————————————————————-+
| private void set(ThreadLocal&amp;lt;?\ key, Object value) {      |
|                                                             |
| Entry[] tab = table;                                      |
|                                                             |
| int len = tab.length;                                       |
|                                                             |
| //获得该ThreadLocal的索引位置                               |
|                                                             |
| int i = key.threadLocalHashCode &amp;amp; (len-1);                  |
|                                                             |
| //通过索引位置查找存储的Entry，                             |
|                                                             |
| for (Entry e = tab[i];                                    |
|                                                             |
| e != null;                                                  |
|                                                             |
| e = tab[i = nextIndex(i, len)]) {                         |
|                                                             |
| ThreadLocal&amp;lt;?\ k = e.get();                               |
|                                                             |
| //Entry的ThreadLocal对象对应上了，就赋值                    |
|                                                             |
| if (k == key) {                                             |
|                                                             |
| e.value = value;                                            |
|                                                             |
| return;                                                     |
|                                                             |
| }                                                           |
|                                                             |
| //key已经是null，说明被回收了，                             |
|                                                             |
| //该索引Entry没用了，用要保存的键值替换该位置上的 Entry     |
|                                                             |
| if (k == null) {                                            |
|                                                             |
| replaceStaleEntry(key, value, i);                           |
|                                                             |
| return;                                                     |
|                                                             |
| }                                                           |
|                                                             |
| }                                                           |
|                                                             |
| //要存放的索引位置没有 Entry，                              |
|                                                             |
| //将当前键值作为一个 Entry 保存在该位置                     |
|                                                             |
| tab[i] = new Entry(key, value);                           |
|                                                             |
| int sz = ++size;                                            |
|                                                             |
| //清除一些无效的条目并判断 table 中的条目数是否已经超出阈值 |
|                                                             |
| if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz = threshold)             |
|                                                             |
| //扩容两倍                                                  |
|                                                             |
| rehash();                                                   |
|                                                             |
| }                                                           |
+————————————————————-+&lt;/p&gt;

&lt;h2 id=&quot;get方法&quot;&gt;Get方法&lt;/h2&gt;

&lt;p&gt;+————————————————–+
| &lt;strong&gt;public&lt;/strong&gt; T get() {                             |
|                                                  |
| Thread t = Thread.&lt;em&gt;currentThread&lt;/em&gt;();             |
|                                                  |
| ThreadLocalMap map = getMap(t);                  |
|                                                  |
| &lt;strong&gt;if&lt;/strong&gt; (map != &lt;strong&gt;null&lt;/strong&gt;) {                       |
|                                                  |
| //直接调用map的getEntry方法                      |
|                                                  |
| ThreadLocalMap.Entry e = map.getEntry(&lt;strong&gt;this&lt;/strong&gt;); |
|                                                  |
| &lt;strong&gt;if&lt;/strong&gt; (e != &lt;strong&gt;null&lt;/strong&gt;) {                         |
|                                                  |
| \@SuppressWarnings(&lt;strong&gt;&quot;unchecked&quot;&lt;/strong&gt;)            |
|                                                  |
| T result = (T)e.&lt;strong&gt;value&lt;/strong&gt;;                       |
|                                                  |
| &lt;strong&gt;return&lt;/strong&gt; result;                               |
|                                                  |
| }                                                |
|                                                  |
| }                                                |
|                                                  |
| //没有则初始化一个,过程类似set可以设置初始值     |
|                                                  |
| &lt;strong&gt;return&lt;/strong&gt; setInitialValue();                    |
|                                                  |
| }                                                |
|                                                  |
| &lt;strong&gt;private&lt;/strong&gt; T setInitialValue() {                |
|                                                  |
| T value = initialValue();                        |
|                                                  |
| Thread t = Thread.&lt;em&gt;currentThread&lt;/em&gt;();             |
|                                                  |
| ThreadLocalMap map = getMap(t);                  |
|                                                  |
| &lt;strong&gt;if&lt;/strong&gt; (map != &lt;strong&gt;null&lt;/strong&gt;)                         |
|                                                  |
| map.set(&lt;strong&gt;this&lt;/strong&gt;, value);                        |
|                                                  |
| &lt;strong&gt;else&lt;/strong&gt;                                         |
|                                                  |
| createMap(t, value);                             |
|                                                  |
| &lt;strong&gt;return&lt;/strong&gt; value;                                |
|                                                  |
| }                                                |
|                                                  |
| &lt;strong&gt;protected&lt;/strong&gt; T initialValue() {                 |
|                                                  |
| &lt;strong&gt;return null&lt;/strong&gt;;                                 |
|                                                  |
| }                                                |
+————————————————–+&lt;/p&gt;

&lt;p&gt;map的getEntry方法&lt;/p&gt;

&lt;p&gt;+———————————————————————-+
| &lt;strong&gt;private&lt;/strong&gt; Entry getEntry(ThreadLocal&amp;lt;?\ key) {                   |
|                                                                      |
| &lt;strong&gt;int&lt;/strong&gt; i = key.&lt;strong&gt;threadLocalHashCode&lt;/strong&gt; &amp;amp; (&lt;strong&gt;table&lt;/strong&gt;.&lt;strong&gt;length&lt;/strong&gt; -    |
| 1);                                                                  |
|                                                                      |
| //通过hash后的值获得entry                                            |
|                                                                      |
| Entry e = &lt;strong&gt;table&lt;/strong&gt;[i];                                            |
|                                                                      |
| //因为有hash碰撞的可能，需要比较一下对象                             |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (e != &lt;strong&gt;null&lt;/strong&gt; &amp;amp;&amp;amp; e.get() == key)                             |
|                                                                      |
| &lt;strong&gt;return&lt;/strong&gt; e;                                                        |
|                                                                      |
| &lt;strong&gt;else&lt;/strong&gt;                                                             |
|                                                                      |
| &lt;strong&gt;return&lt;/strong&gt; getEntryAfterMiss(key, i, e);                             |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;strong&gt;private&lt;/strong&gt; Entry getEntryAfterMiss(ThreadLocal&amp;lt;?\ key, &lt;strong&gt;int&lt;/strong&gt; i, |
| Entry e) {                                                           |
|                                                                      |
| Entry[] tab = &lt;strong&gt;table&lt;/strong&gt;;                                           |
|                                                                      |
| &lt;strong&gt;int&lt;/strong&gt; len = tab.&lt;strong&gt;length&lt;/strong&gt;;                                        |
|                                                                      |
| //从i坐标以后循环着找，知道获得null                                  |
|                                                                      |
| &lt;strong&gt;while&lt;/strong&gt; (e != &lt;strong&gt;null&lt;/strong&gt;) {                                          |
|                                                                      |
| ThreadLocal&amp;lt;?\ k = e.get();                                        |
|                                                                      |
| //能对上就返回                                                       |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (k == key)                                                    |
|                                                                      |
| &lt;strong&gt;return&lt;/strong&gt; e;                                                        |
|                                                                      |
| //key为null被GC回收了，清理                                          |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (k == &lt;strong&gt;null&lt;/strong&gt;)                                               |
|                                                                      |
| expungeStaleEntry(i);                                                |
|                                                                      |
| &lt;strong&gt;else&lt;/strong&gt;                                                             |
|                                                                      |
| i = &lt;em&gt;nextIndex&lt;/em&gt;(i, len);                                             |
|                                                                      |
| e = tab[i];                                                        |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;strong&gt;return null&lt;/strong&gt;;                                                     |
|                                                                      |
| }                                                                    |
+———————————————————————-+&lt;/p&gt;

&lt;h2 id=&quot;remove方法&quot;&gt;Remove方法&lt;/h2&gt;

&lt;p&gt;+——————————————————+
| &lt;strong&gt;public void&lt;/strong&gt; remove() {                           |
|                                                      |
| ThreadLocalMap m = getMap(Thread.&lt;em&gt;currentThread&lt;/em&gt;()); |
|                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (m != &lt;strong&gt;null&lt;/strong&gt;)                               |
|                                                      |
| m.remove(&lt;strong&gt;this&lt;/strong&gt;);                                  |
|                                                      |
| }                                                    |
+——————————————————+&lt;/p&gt;

&lt;p&gt;map的remove&lt;/p&gt;

&lt;p&gt;+—————————————————-+
| &lt;strong&gt;private void&lt;/strong&gt; remove(ThreadLocal&amp;lt;?\ key) {    |
|                                                    |
| Entry[] tab = &lt;strong&gt;table&lt;/strong&gt;;                         |
|                                                    |
| &lt;strong&gt;int&lt;/strong&gt; len = tab.&lt;strong&gt;length&lt;/strong&gt;;                      |
|                                                    |
| &lt;strong&gt;int&lt;/strong&gt; i = key.&lt;strong&gt;threadLocalHashCode&lt;/strong&gt; &amp;amp; (len-1); |
|                                                    |
| &lt;strong&gt;for&lt;/strong&gt; (Entry e = tab[i];                       |
|                                                    |
| e != &lt;strong&gt;null&lt;/strong&gt;;                                     |
|                                                    |
| e = tab[i = &lt;em&gt;nextIndex&lt;/em&gt;(i, len)]) {              |
|                                                    |
| //如果key对上了就清除                              |
|                                                    |
| &lt;strong&gt;if&lt;/strong&gt; (e.get() == key) {                          |
|                                                    |
| e.clear();                                         |
|                                                    |
| expungeStaleEntry(i);                              |
|                                                    |
| &lt;strong&gt;return&lt;/strong&gt;;                                        |
|                                                    |
| }                                                  |
|                                                    |
| }                                                  |
|                                                    |
| }                                                  |
+—————————————————-+&lt;/p&gt;

&lt;h2 id=&quot;清理方法&quot;&gt;清理方法&lt;/h2&gt;

&lt;p&gt;expungeStaleEntry是主要的清理方法，里面主要就是将key已经被回收的和需要回收的key和value都设置为null，等待gc回收。&lt;/p&gt;

&lt;p&gt;+———————————————————————-+
| &lt;strong&gt;private int&lt;/strong&gt; expungeStaleEntry(&lt;strong&gt;int&lt;/strong&gt; staleSlot) {               |
|                                                                      |
| Entry[] tab = &lt;strong&gt;table&lt;/strong&gt;;                                           |
|                                                                      |
| &lt;strong&gt;int&lt;/strong&gt; len = tab.&lt;strong&gt;length&lt;/strong&gt;;                                        |
|                                                                      |
| &lt;em&gt;//值和引用都设置null&lt;/em&gt;                                               |
|                                                                      |
| tab[staleSlot].&lt;strong&gt;value&lt;/strong&gt; = &lt;strong&gt;null&lt;/strong&gt;;                               |
|                                                                      |
| tab[staleSlot] = &lt;strong&gt;null&lt;/strong&gt;;                                         |
|                                                                      |
| &lt;strong&gt;size&lt;/strong&gt;--;                                                         |
|                                                                      |
| Entry e;                                                             |
|                                                                      |
| &lt;strong&gt;int&lt;/strong&gt; i;                                                           |
|                                                                      |
| //找到                                                               |
| i坐标后面连续的有值的，因为hash碰撞，相同的hash值会存放在一个坐标，  |
| 如果有值了就往后排，所以清理的时候也需要向后查找，直到坐标内容为null |
|                                                                      |
| &lt;strong&gt;for&lt;/strong&gt; (i = &lt;em&gt;nextIndex&lt;/em&gt;(staleSlot, len);                            |
|                                                                      |
| (e = tab[i]) != &lt;strong&gt;null&lt;/strong&gt;;                                          |
|                                                                      |
| i = &lt;em&gt;nextIndex&lt;/em&gt;(i, len)) {                                           |
|                                                                      |
| ThreadLocal&amp;lt;?\ k = e.get();                                        |
|                                                                      |
| //key被gc回收，则把value也回收了                                     |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (k == &lt;strong&gt;null&lt;/strong&gt;) {                                             |
|                                                                      |
| e.&lt;strong&gt;value&lt;/strong&gt; = &lt;strong&gt;null&lt;/strong&gt;;                                              |
|                                                                      |
| tab[i] = &lt;strong&gt;null&lt;/strong&gt;;                                                 |
|                                                                      |
| &lt;strong&gt;size&lt;/strong&gt;--;                                                         |
|                                                                      |
| } &lt;strong&gt;else&lt;/strong&gt; {                                                         |
|                                                                      |
| //如果找到entry，计算出他不应该在这个位置，就往后挪，                |
|                                                                      |
| //并且把这个位置设置为null                                           |
|                                                                      |
| &lt;strong&gt;int&lt;/strong&gt; h = k.&lt;strong&gt;threadLocalHashCode&lt;/strong&gt; &amp;amp; (len - 1);                   |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (h != i) {                                                    |
|                                                                      |
| tab[i] = &lt;strong&gt;null&lt;/strong&gt;;                                                 |
|                                                                      |
| &lt;strong&gt;while&lt;/strong&gt; (tab[h] != &lt;strong&gt;null&lt;/strong&gt;)                                     |
|                                                                      |
| h = &lt;em&gt;nextIndex&lt;/em&gt;(h, len);                                             |
|                                                                      |
| tab[h] = e;                                                        |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;strong&gt;return&lt;/strong&gt; i;                                                        |
|                                                                      |
| }                                                                    |
+———————————————————————-+&lt;/p&gt;

&lt;h2 id=&quot;内存泄漏&quot;&gt;内存泄漏&lt;/h2&gt;

&lt;p&gt;ThreadLocal的结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ThreadLocal代码解析/image2.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.2555555555555555in”}&lt;/p&gt;

&lt;p&gt;每个Thread 维护一个 ThreadLocalMap 映射表，这个映射表的 key 是
ThreadLocal 实例本身，value 是真正需要存储的 Object。ThreadLocal
本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取
value。&lt;/p&gt;

&lt;p&gt;值得注意的是图中的虚线，表示 ThreadLocalMap 是使用 ThreadLocal
的弱引用作为 Key 的，意味着没有强引用指向 ThreadLocal
变量时，ThreadLocal会在 GC 时被回收。&lt;/p&gt;

&lt;p&gt;如果是强引用的话ThreadLocal就不会被回收了，造成了内存泄漏。&lt;/p&gt;

&lt;p&gt;由于是弱引用，没有强引用指向ThreadLocal变量了，GC后将ThreadLocal对象回收了，所以key就变成null了，也就没有人访问key为null的entry了，如果线程不销毁那value就无法被GC了。&lt;/p&gt;

&lt;p&gt;所以在ThreadLocal中的get、set、remove都根据条件调用了ThreadLocalMap的expungeStaleEntry，用来将key已经成为null的内容清理掉。已经失效的value只能在下一次调用这几个方法的时候才能被清理，所以在结束使用ThreadLocal时，调用remove方法清理。&lt;/p&gt;

&lt;p&gt;ThreadLocal使用通常被申明为static，意味着多个相同的对象只会在方法区中存在一份，JDK建议将ThreadLocal变量定义成private
static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。&lt;/p&gt;

&lt;p&gt;生命周期的变成使得操作不当，造成内存泄漏，例如以下示例:&lt;/p&gt;

&lt;p&gt;&amp;lt;http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/&lt;/p&gt;

&lt;p&gt;调用remove解决。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&amp;lt;http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/&lt;/p&gt;

&lt;p&gt;&amp;lt;https://www.zhihu.com/question/35250439&lt;/p&gt;

&lt;p&gt;&amp;lt;https://blog.csdn.net/winwill2012/article/details/71625570&lt;/p&gt;

&lt;h2 id=&quot;例子&quot;&gt;例子&lt;/h2&gt;

&lt;p&gt;&amp;lt;http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/&lt;/p&gt;

&lt;p&gt;+———————————————————————-+
| public class MyCounter {                                             |
|                                                                      |
| private int count = 0;                                               |
|                                                                      |
| public void increment() {                                            |
|                                                                      |
| count++;                                                             |
|                                                                      |
| }                                                                    |
|                                                                      |
| public int getCount() {                                              |
|                                                                      |
| return count;                                                        |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
|                                                                      |
| public class MyThreadLocal extends ThreadLocal&amp;lt;MyCounter\ {        |
|                                                                      |
| }                                                                    |
|                                                                      |
| public class LeakingServlet extends HttpServlet {                    |
|                                                                      |
| private static MyThreadLocal myThreadLocal = new MyThreadLocal();    |
|                                                                      |
| protected void doGet(HttpServletRequest request,                     |
|                                                                      |
| HttpServletResponse response) throws ServletException, IOException { |
|                                                                      |
| MyCounter counter = myThreadLocal.get();                             |
|                                                                      |
| if (counter == null) {                                               |
|                                                                      |
| counter = new MyCounter();                                           |
|                                                                      |
| myThreadLocal.set(counter);                                          |
|                                                                      |
| }                                                                    |
|                                                                      |
| response.getWriter().println(                                        |
|                                                                      |
| &quot;The current thread served this servlet &quot; + counter.getCount()     |
|                                                                      |
| + &quot; times&quot;);                                                      |
|                                                                      |
| counter.increment();                                                 |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
+———————————————————————-+&lt;/p&gt;

&lt;p&gt;在 Tomcat 中，下面的代码都在 webapp
内，会导致WebappClassLoader泄漏，无法被回收。上面的代码中，只要LeakingServlet被调用过一次，且执行它的线程没有停止，就会导致WebappClassLoader泄漏。每次你
reload 一下应用，就会多一份WebappClassLoader实例，最后导致 PermGen
OutOfMemoryException。&lt;/p&gt;

&lt;p&gt;tomcat请求线程是个线程池，所以当调用完set之后，myThreadLocal就被设置到了线程池的thread里的threadLocalMap变量，而myThreadLocal又是static的。所以类的引用一直存在。所以需要调用remove方法清理myThreadLocal
和Thrad引用。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/ThreadLocal%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90&quot;&gt;ThreadLocal代码解析&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on April 05, 2018.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[infer 对idea和jenkins的支持]]></title>
  <link>http://yangqiju.github.io/infer-gradle-jenkins</link>
  <id>http://yangqiju.github.io/infer-gradle-jenkins</id>
  <published>2018-02-06T00:00:00-05:00</published>
  <updated>2018-02-06T00:00:00-05:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/infer&quot;&gt;infer&lt;/a&gt;是facebook开源的代码检查工具，里面提供了findbugs、阿里pmd所没有的竞态的资源问题。
在终端上执行infer相关命令没有问题，但是结合gradle 执行infer 相关命令时，在idea或者jenkins下
就会有问题(当前2018-02-06)。&lt;/p&gt;

&lt;p&gt;错误信息如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;nc&quot;&gt;Caused&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;by:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;IOException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;such&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;directory&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;UNIXProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forkAndExec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Native&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;UNIXProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;UNIXProcess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;248&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ProcessImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ProcessImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;134&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ProcessBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ProcessBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1029&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;91&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;more&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;原因就是因为在运行idea或jenkins时，infer的路径不在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/usr/local/bin&lt;/code&gt;中，所以需要在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PATH&lt;/code&gt;中
加上。
idea可参考&lt;a href=&quot;http://depressiverobot.com/2016/02/05/intellij-path.html&quot;&gt;此内容&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;jenkins可以直接在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;系统设置&lt;/code&gt;中添加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;环境变量&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;键&lt;/code&gt;为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PATH&lt;/code&gt;,值为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$PATH:/usr/local/bin&lt;/code&gt;,重启即可.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/infer-gradle-jenkins&quot;&gt;infer 对idea和jenkins的支持&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on February 06, 2018.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[springmvc代码解析]]></title>
  <link>http://yangqiju.github.io/springmvc%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90</link>
  <id>http://yangqiju.github.io/springmvc代码解析</id>
  <published>2018-01-02T00:00:00-05:00</published>
  <updated>2018-01-02T00:00:00-05:00</updated>
  <author>
    <name>yangqiju</name>
    <uri>http://yangqiju.github.io</uri>
    <email>362991493@qq.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;信息版本为：3.1.x&lt;/p&gt;

&lt;p&gt;springmvc支持纯javaconfig模式，这里记录的为xml配置模式。&lt;/p&gt;

&lt;p&gt;这次代码解析主要想弄明白以下几个部分内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;标签如何被加载（例如：RequestMapping）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;请求如何被处理到指定处理类&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何用标签进行数据格式的转换&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;异常是如何处理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;请求参数如何映射&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Servlet多线程在哪里实现&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;标签如何被加载&quot;&gt;标签如何被加载&lt;/h1&gt;

&lt;p&gt;RequestMapping标签的加载必然是在启动过程中了，web项目直接加载web.xml。&lt;/p&gt;

&lt;p&gt;以下为一个简单的web.xml配置，里面常用的配置用颜色标注。&lt;/p&gt;

&lt;p&gt;+———————————————————————-+
| &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?\                         |
|                                                                      |
| &amp;lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    |
|                                                                      |
| xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;                          |
|                                                                      |
| xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee               |
| http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;                |
|                                                                      |
| version=&quot;3.0&quot;\                                                    |
|                                                                      |
| &amp;lt;display-name\webtest&amp;lt;/display-name\                             |
|                                                                      |
| &amp;lt;!-- 提供ContextLoaderListener 并设置相关参数 --\                |
|                                                                      |
| &amp;lt;context-param\                                                    |
|                                                                      |
| &amp;lt;param-name\contextConfigLocation&amp;lt;/param-name\                   |
|                                                                      |
| &amp;lt;param-value\classpath:spring-core.xml&amp;lt;/param-value\             |
|                                                                      |
| &amp;lt;/context-param\                                                   |
|                                                                      |
| &amp;lt;listener\                                                         |
|                                                                      |
| &amp;lt;listener-class\org.                                               |
| springframework.web.context.ContextLoaderListener&amp;lt;/listener-class\ |
|                                                                      |
| &amp;lt;/listener\                                                        |
|                                                                      |
| &amp;lt;servlet\                                                          |
|                                                                      |
| &amp;lt;servlet-name\webtest&amp;lt;/servlet-name\                             |
|                                                                      |
| &amp;lt;servlet-class\                                                     |
| org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class\ |
|                                                                      |
| &amp;lt;load-on-startup\1&amp;lt;/load-on-startup\                             |
|                                                                      |
| &amp;lt;/servlet\                                                         |
|                                                                      |
| &amp;lt;servlet-mapping\                                                  |
|                                                                      |
| &amp;lt;servlet-name\webtest&amp;lt;/servlet-name\                             |
|                                                                      |
| &amp;lt;url-pattern\/&amp;lt;/url-pattern\                                     |
|                                                                      |
| &amp;lt;/servlet-mapping\                                                 |
|                                                                      |
| &amp;lt;filter\                                                           |
|                                                                      |
| &amp;lt;filter-name\Set Character Encoding&amp;lt;/filter-name\                |
|                                                                      |
| &amp;lt;filter-class\org                                                  |
| .springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class\ |
|                                                                      |
| &amp;lt;init-param\                                                       |
|                                                                      |
| &amp;lt;param-name\encoding&amp;lt;/param-name\                                |
|                                                                      |
| &amp;lt;param-value\utf8&amp;lt;/param-value\                                  |
|                                                                      |
| &amp;lt;/init-param\                                                      |
|                                                                      |
| &amp;lt;/filter\                                                          |
|                                                                      |
| &amp;lt;filter-mapping\                                                   |
|                                                                      |
| &amp;lt;filter-name\Set Character Encoding&amp;lt;/filter-name\                |
|                                                                      |
| &amp;lt;url-pattern\/*&amp;lt;/url-pattern\                                   |
|                                                                      |
| &amp;lt;/filter-mapping\                                                  |
|                                                                      |
| &amp;lt;/web-app\                                                         |
+———————————————————————-+&lt;/p&gt;

&lt;p&gt;主要分为三类标签（其他标签作为辅助），listener、servlet、filter。&lt;/p&gt;

&lt;p&gt;先看一下tomcat是如何加载它们的，tomcat启动时会调用
StandardContext的startInternal：&lt;/p&gt;

&lt;p&gt;+———————————————————————-+
| //省略之前                                                           |
|                                                                      |
| &lt;em&gt;// 加载listener&lt;/em&gt;                                                    |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (ok) {                                                        |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (!listenerStart()) {                                          |
|                                                                      |
| &lt;strong&gt;&lt;em&gt;log                                                               |
| **&lt;/em&gt;.error(&lt;/strong&gt;&lt;em&gt;sm&lt;/em&gt;&lt;strong&gt;.getString(&lt;/strong&gt;&quot;standardContext.listenerFail&quot;&lt;strong&gt;)); |
|                                                                      |
| ok = **false&lt;/strong&gt;;                                                      |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
|                                                                      |
| //省略                                                               |
|                                                                      |
| &lt;em&gt;// 加载fileter&lt;/em&gt;                                                     |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (ok) {                                                        |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (!filterStart()) {                                            |
|                                                                      |
| &lt;strong&gt;&lt;em&gt;l                                                                 |
| og&lt;/em&gt;&lt;/strong&gt;.error(&lt;strong&gt;&lt;em&gt;sm&lt;/em&gt;&lt;/strong&gt;.getString(&lt;strong&gt;&quot;standardContext.filterFail&quot;&lt;/strong&gt;)); |
|                                                                      |
| ok = &lt;strong&gt;false&lt;/strong&gt;;                                                      |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;em&gt;// 加载初始化”load on startup”的servlet&lt;/em&gt;                            |
|                                                                      |
| &lt;em&gt;// Load and initialize all &quot;load on startup&quot; servlets&lt;/em&gt;            |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (ok) {                                                        |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (!loadOnStartup(findChildren())){                             |
|                                                                      |
| &lt;strong&gt;&lt;em&gt;lo                                                                |
| g&lt;/em&gt;&lt;/strong&gt;.error(&lt;strong&gt;&lt;em&gt;sm&lt;/em&gt;&lt;/strong&gt;.getString(&lt;strong&gt;&quot;standardContext.servletFail&quot;&lt;/strong&gt;)); |
|                                                                      |
| ok = &lt;strong&gt;false&lt;/strong&gt;;                                                      |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
+———————————————————————-+&lt;/p&gt;

&lt;p&gt;以上内容省略了其他的加载执行步骤，但是可以看到这三个加载顺序，在这里内容如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;listener&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在web.xml中加载spring
 web的ContextLoaderListener，启动会调用contextInitialized方法，会根据加载spring容器，示例中会加载spring-core.xml配置文件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;filter&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;加载配置中的Fileter，例如示例中的encoding处理&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;servlet&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;servlet的加载和处理，在示例中就是springmvc核心的DispatcherServlet，在启动时会springmvc的配置文件，默认以项目名加”-servlet.xml”的配置文件，启动后所有的servlet请求都会到这里进行统一分发处理。&lt;/p&gt;

&lt;p&gt;DispatcherServlet是springmvc的核心，所有的请求都是通过它来处理的，类的结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Springmvc源码解析/image1.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.7979166666666666in”}&lt;/p&gt;

&lt;p&gt;通过上图能够看出DispatcherServlet是实现了Servlet，集成了GenericServlet、HttpServlet，这三个都是javax.servlet.http包中的，Servlet提供了基本的init、service、destroy方法，GenericServlet提供了通用的实现，而HttpServlet实现了具体的Http相关的功能（例如：doGet、doPut、doPost、doDelete、doHead、doTrace、doOption）。&lt;/p&gt;

&lt;p&gt;HttpServletBean就是Springmvc的具体的实现了。在FrameworkServlet中实现了构造Springmvc容器（parent
为spring容器）。&lt;/p&gt;

&lt;p&gt;servlet的基本操作如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Springmvc源码解析/image2.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.428472222222222in”}&lt;/p&gt;

&lt;p&gt;比较重要的就是servlet的init、service、destroy了。在tomcat的代码中，tomcat启动项目时，会在StandardWrapper的loadServlet方法中new
Instance出DispatcherServlet，然后执行init方法。&lt;/p&gt;

&lt;p&gt;+———————————————————————-+
| package org.apache.catalina.core;                                    |
|                                                                      |
| public class StandardWrapper extends ContainerBase                   |
|                                                                      |
| implements ServletConfig, Wrapper, NotificationEmitter {             |
|                                                                      |
| //省略                                                               |
|                                                                      |
| public synchronized Servlet loadServlet() throws ServletException {  |
|                                                                      |
| //省略                                                               |
|                                                                      |
| InstanceManager instanceManager =                                    |
| ((StandardContext)getParent()).getInstanceManager();                 |
|                                                                      |
| try {                                                                |
|                                                                      |
| //这里的servletClass                                                 |
| 就是org.springframework.web.servlet.DispatcherServlet                |
|                                                                      |
| // newInstance                                                       |
| 方法实现为通过类加载器找到class，然后clazz.newInstance()             |
|                                                                      |
| servlet = (Servlet) instanceManager.newInstance(servletClass);       |
|                                                                      |
| } catch (ClassCastException e) {                                     |
|                                                                      |
| //省略                                                               |
|                                                                      |
| //调用servlet的init方法                                              |
|                                                                      |
| initServlet(servlet);                                                |
|                                                                      |
| //省略                                                               |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
+———————————————————————-+&lt;/p&gt;

&lt;p&gt;在init方法执行后，会调用FrameworkServlet的initServletBean方法，进行springmvc的容器加载。加载过程中，会将spring容器设为parent容器，并加载servlet配置文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Springmvc源码解析/image3.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”4.315972222222222in”}&lt;/p&gt;

&lt;p&gt;加载配置文件会进行解析，解析过程使用org.springframework.web.servlet.config.
AnnotationDrivenBeanDefinitionParser进行处理，例如&amp;lt;mvc:annotation-driven\、&amp;lt;mvc:argument-resolvers\等等标签。在处理这些标签的同时，会构建RequestMappingHandlerMapping实例的定义，并注册到Springmvc容器中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Springmvc源码解析/image4.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”1.9854166666666666in”}&lt;/p&gt;

&lt;p&gt;然后会执行ApplicationContext的refresh动作，对类进行实例化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Springmvc源码解析/image5.jpeg&quot; alt=&quot;\\psf\Home\Library\Containers\com.tencent.qq\Data\Library\Application
Support\QQ\Users\362991493\QQ\Temp.db\9B8B3230-E611-4CB3-B9CD-6496222229EC.png&quot; /&gt;{width=”5.768055555555556in”
height=”3.642652012248469in”}&lt;/p&gt;

&lt;h1 id=&quot;方法如何执行&quot;&gt;方法如何执行&lt;/h1&gt;

&lt;p&gt;由于对tomcat注册了DispatchServlet，所以当有符合该项目路径进行请求后，tomcat会分配当该模块中，例如请求时个Post方法，则会调用doPost方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Springmvc源码解析/image6.jpeg&quot; alt=&quot;\\psf\Home\Library\Containers\com.tencent.qq\Data\Library\Application
Support\QQ\Users\362991493\QQ\Temp.db\5F8A9939-8871-413F-B9E1-66C27E074ABE.png&quot; /&gt;{width=”5.768055555555556in”
height=”1.8624376640419948in”}&lt;/p&gt;

&lt;p&gt;然后会调用到DispatchServlet的doService，最后会执行到doDispatch方法。&lt;/p&gt;

&lt;p&gt;+———————————————————————-+
| &lt;strong&gt;protected void&lt;/strong&gt; doDispatch(HttpServletRequest request,            |
| HttpServletResponse response) &lt;strong&gt;throws&lt;/strong&gt; Exception {                 |
|                                                                      |
| HttpServletRequest processedRequest = request;                       |
|                                                                      |
| HandlerExecutionChain mappedHandler = &lt;strong&gt;null&lt;/strong&gt;;                      |
|                                                                      |
| &lt;strong&gt;boolean&lt;/strong&gt; multipartRequestParsed = &lt;strong&gt;false&lt;/strong&gt;;                      |
|                                                                      |
| WebAsyncManager asyncManager =                                       |
| WebAsyncUtils.&lt;em&gt;getAsyncManager&lt;/em&gt;(request);                            |
|                                                                      |
| &lt;strong&gt;try&lt;/strong&gt; {                                                            |
|                                                                      |
| ModelAndView mv = &lt;strong&gt;null&lt;/strong&gt;;                                          |
|                                                                      |
| Exception dispatchException = &lt;strong&gt;null&lt;/strong&gt;;                              |
|                                                                      |
| &lt;strong&gt;try&lt;/strong&gt; {                                                            |
|                                                                      |
| processedRequest = checkMultipart(request);                          |
|                                                                      |
| multipartRequestParsed = processedRequest != request;                |
|                                                                      |
| &lt;em&gt;// Determine handler for the current request.根据请求，找到handler&lt;/em&gt; |
|                                                                      |
| mappedHandler = getHandler(processedRequest, &lt;strong&gt;false&lt;/strong&gt;);             |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (mappedHandler == &lt;strong&gt;null&lt;/strong&gt; || mappedHandler.getHandler() == |
| &lt;strong&gt;null&lt;/strong&gt;) {                                                          |
|                                                                      |
| noHandlerFound(processedRequest, response);                          |
|                                                                      |
| &lt;strong&gt;return&lt;/strong&gt;;                                                          |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;em&gt;// Determine handler adapter for the current                        |
| request.获得handler的adapter&lt;/em&gt;                                        |
|                                                                      |
| HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());   |
|                                                                      |
| &lt;em&gt;// Process last-modified header, if supported by the handler.&lt;/em&gt;      |
|                                                                      |
| &lt;em&gt;//如果是get或者head，可以考虑换从相关的内容&lt;/em&gt;                        |
|                                                                      |
| String method = request.getMethod();                                 |
|                                                                      |
| &lt;strong&gt;boolean&lt;/strong&gt; isGet = &lt;strong&gt;&quot;GET&quot;&lt;/strong&gt;.equals(method);                      |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (isGet || &lt;strong&gt;&quot;HEAD&quot;&lt;/strong&gt;.equals(method)) {                    |
|                                                                      |
| &lt;strong&gt;long&lt;/strong&gt; lastModified = ha.getLastModified(request,                  |
| mappedHandler.getHandler());                                         |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (&lt;strong&gt;logger&lt;/strong&gt;.isDebugEnabled()) {                               |
|                                                                      |
| &lt;strong&gt;logger&lt;/strong&gt;.debug(&lt;strong&gt;&quot;Last-Modified value for [&quot;&lt;/strong&gt; +                |
| &lt;em&gt;getRequestUri&lt;/em&gt;(request) + &lt;strong&gt;&quot;] is: &quot;&lt;/strong&gt; + lastModified);          |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (&lt;strong&gt;new&lt;/strong&gt; ServletWebRequest(request,                           |
| response).checkNotModified(lastModified) &amp;amp;&amp;amp; isGet) {                 |
|                                                                      |
| &lt;strong&gt;return&lt;/strong&gt;;                                                          |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (!mappedHandler.applyPreHandle(processedRequest, response)) { |
|                                                                      |
| &lt;strong&gt;return&lt;/strong&gt;;                                                          |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;strong&gt;try&lt;/strong&gt; {                                                            |
|                                                                      |
| &lt;em&gt;// Actually invoke the handler.&lt;/em&gt;                                    |
|                                                                      |
| &lt;em&gt;//执行方法&lt;/em&gt;                                                         |
|                                                                      |
| mv = ha.handle(processedRequest, response,                           |
| mappedHandler.getHandler());                                         |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;strong&gt;finally&lt;/strong&gt; {                                                        |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (asyncManager.isConcurrentHandlingStarted()) {                |
|                                                                      |
| &lt;strong&gt;return&lt;/strong&gt;;                                                          |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
|                                                                      |
| applyDefaultViewName(request, mv);                                   |
|                                                                      |
| mappedHandler.applyPostHandle(processedRequest, response, mv);       |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;strong&gt;catch&lt;/strong&gt; (Exception ex) {                                           |
|                                                                      |
| dispatchException = ex;                                              |
|                                                                      |
| }                                                                    |
|                                                                      |
| processDispatchResult(processedRequest, response, mappedHandler, mv, |
| dispatchException);                                                  |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;strong&gt;catch&lt;/strong&gt; (Exception ex) {                                           |
|                                                                      |
| triggerAfterCompletion(processedRequest, response, mappedHandler,    |
| ex);                                                                 |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;strong&gt;catch&lt;/strong&gt; (Error err) {                                              |
|                                                                      |
| triggerAfterCompletionWithError(processedRequest, response,          |
| mappedHandler, err);                                                 |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;strong&gt;finally&lt;/strong&gt; {                                                        |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (asyncManager.isConcurrentHandlingStarted()) {                |
|                                                                      |
| &lt;em&gt;// Instead of postHandle and afterCompletion&lt;/em&gt;                       |
|                                                                      |
| mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest,  |
| response);                                                           |
|                                                                      |
| &lt;strong&gt;return&lt;/strong&gt;;                                                          |
|                                                                      |
| }                                                                    |
|                                                                      |
| &lt;em&gt;// Clean up any resources used by a multipart request.&lt;/em&gt;             |
|                                                                      |
| &lt;strong&gt;if&lt;/strong&gt; (multipartRequestParsed) {                                    |
|                                                                      |
| cleanupMultipart(processedRequest);                                  |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
|                                                                      |
| }                                                                    |
+———————————————————————-+&lt;/p&gt;

&lt;p&gt;通过上面代码可以看到，先是根据request请求，找到模块启动时注册的handler，然后进行执行。具体的执行方法在InvocableHandlerMethod类中的invokeForRequest体现。&lt;/p&gt;

&lt;p&gt;+———————————————————————-+
| &lt;strong&gt;public final&lt;/strong&gt; Object invokeForRequest(NativeWebRequest request,   |
| ModelAndViewContainer mavContainer,                                  |
|                                                                      |
| Object... providedArgs) &lt;strong&gt;throws&lt;/strong&gt; Exception {                      |
|                                                                      |
| //获得请求参数                                                       |
|                                                                      |
| Object[] args = getMethodArgumentValues(request, mavContainer,     |
| providedArgs);                                                       |
|                                                                      |
| //通过反射执行                                                       |
|                                                                      |
| Object returnValue = invoke(args);                                   |
|                                                                      |
| &lt;strong&gt;return&lt;/strong&gt; returnValue;                                              |
|                                                                      |
| }                                                                    |
+———————————————————————-+&lt;/p&gt;

&lt;p&gt;该方法先是获得请求内容，也就是方法中的具体参数，然后执行invoke反射，执行具体的RequestMapping方法。&lt;/p&gt;

&lt;p&gt;而获得参数的方法，这里会进行数据转换的判断和具体的转换方案。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Springmvc源码解析/image7.jpeg&quot; alt=&quot;\\psf\Home\Library\Containers\com.tencent.qq\Data\Library\Application
Support\QQ\Users\362991493\QQ\Temp.db\570FD148-A874-4F62-A7DB-72B8746C0089.png&quot; /&gt;{width=”5.768055555555556in”
height=”3.5730391513560806in”}&lt;/p&gt;

&lt;p&gt;而argumentResolver就是请求的转换处理了，比如常用的\@RequestParam、\@PathVariable等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Springmvc源码解析/image8.jpeg&quot; alt=&quot;\\psf\Home\Library\Containers\com.tencent.qq\Data\Library\Application
Support\QQ\Users\362991493\QQ\Temp.db\245A6BD0-8F74-42C5-801A-F59BB25088EE.png&quot; /&gt;{width=”5.768055555555556in”
height=”5.798038057742782in”}&lt;/p&gt;

&lt;p&gt;当请求处理完成后，就会进行返回内容的处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Springmvc源码解析/image9.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”3.7222222222222223in”}&lt;/p&gt;

&lt;p&gt;通常我们使用的\@ResponseBody标签就是在AbstractMessageConverterMethodProcessor中进行处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Springmvc源码解析/image10.png&quot; alt=&quot;&quot; /&gt;{width=”5.768055555555556in”
height=”2.5756944444444443in”}&lt;/p&gt;

&lt;p&gt;而转换的内容就是在配置文件中的具体转换器，例如json、xml的格式转换。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/Springmvc源码解析/image11.jpeg&quot; alt=&quot;\\psf\Home\Library\Containers\com.tencent.qq\Data\Library\Application
Support\QQ\Users\362991493\QQ\Temp.db\95AE37F3-DCB4-4AEF-90C1-A7E6092CFB0B.png&quot; /&gt;{width=”5.768055555555556in”
height=”0.7720253718285215in”}&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://yangqiju.github.io/springmvc%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90&quot;&gt;springmvc代码解析&lt;/a&gt; was originally published by yangqiju at &lt;a href=&quot;http://yangqiju.github.io&quot;&gt;Orange&lt;/a&gt; on January 02, 2018.&lt;/p&gt;</content>
</entry>

</feed>
